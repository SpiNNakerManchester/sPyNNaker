
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>spynnaker.pyNN.models.neural_projections.connectors.pool_dense_connector &#8212; sPyNNaker 6.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/sphinxdoc.css" />
    <script data-url_root="../../../../../../" id="documentation_options" src="../../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../../_static/doctools.js"></script>
    <script src="../../../../../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../../index.html">sPyNNaker 6.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../../pyNN.html" accesskey="U">spynnaker.pyNN</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spynnaker.pyNN.models.neural_projections.connectors.pool_dense_connector</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for spynnaker.pyNN.models.neural_projections.connectors.pool_dense_connector</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2021 The University of Manchester</span>
<span class="c1"># Based on work Copyright (c) The University of Sussex,</span>
<span class="c1"># Garibaldi Pineda Garcia, James Turner, James Knight and Thomas Nowotny</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">spinn_utilities.overrides</span> <span class="kn">import</span> <span class="n">overrides</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BYTES_PER_WORD</span><span class="p">,</span> <span class="n">BYTES_PER_SHORT</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyNN.random</span> <span class="kn">import</span> <span class="n">RandomDistribution</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.exceptions</span> <span class="kn">import</span> <span class="n">SynapticConfigurationException</span>
<span class="kn">from</span> <span class="nn">.abstract_connector</span> <span class="kn">import</span> <span class="n">AbstractConnector</span>
<span class="kn">from</span> <span class="nn">data_specification.enums.data_type</span> <span class="kn">import</span> <span class="n">DataType</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.exceptions</span> <span class="kn">import</span> <span class="n">ConfigurationException</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.abstract_models</span> <span class="kn">import</span> <span class="n">HasShapeKeyFields</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.data.spynnaker_data_view</span> <span class="kn">import</span> <span class="n">SpynnakerDataView</span>


<span class="n">_DIMENSION_SIZE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">BYTES_PER_SHORT</span><span class="p">)</span>
<span class="n">_KEY_INFO_SIZE</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
<span class="n">_CONN_SIZE</span> <span class="o">=</span> <span class="n">_KEY_INFO_SIZE</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">BYTES_PER_SHORT</span><span class="p">)</span>
<span class="n">_DIM_DTYPE</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;mask&quot;</span><span class="p">,</span> <span class="s2">&quot;uint32&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;shift&quot;</span><span class="p">,</span> <span class="s2">&quot;uint32&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;pre_start&quot;</span><span class="p">,</span> <span class="s2">&quot;uint16&quot;</span><span class="p">),</span>
              <span class="p">(</span><span class="s2">&quot;pre_in_post_start&quot;</span><span class="p">,</span> <span class="s2">&quot;uint16&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;pre_in_post_end&quot;</span><span class="p">,</span> <span class="s2">&quot;uint16&quot;</span><span class="p">),</span>
              <span class="p">(</span><span class="s2">&quot;pre_in_post_shape&quot;</span><span class="p">,</span> <span class="s2">&quot;uint16&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;recip_pool_stride&quot;</span><span class="p">,</span> <span class="s2">&quot;uint16&quot;</span><span class="p">),</span>
              <span class="p">(</span><span class="s2">&quot;_PADDING&quot;</span><span class="p">,</span> <span class="s2">&quot;uint16&quot;</span><span class="p">)]</span>


<span class="k">class</span> <span class="nc">PoolDenseConnector</span><span class="p">(</span><span class="n">AbstractConnector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Where the pre- and post-synaptic populations are considered as a 2D</span>
<span class="sd">    array. Connect every post(row, column) neuron to many</span>
<span class="sd">    pre(row, column, kernel)</span>
<span class="sd">    through a (kernel) set of weights and/or delays.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;__weights&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__pool_shape&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__pool_stride&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__positive_receptor_type&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__negative_receptor_type&quot;</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">pool_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pool_stride</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">positive_receptor_type</span><span class="o">=</span><span class="s2">&quot;excitatory&quot;</span><span class="p">,</span>
                 <span class="n">negative_receptor_type</span><span class="o">=</span><span class="s2">&quot;inhibitory&quot;</span><span class="p">,</span> <span class="n">safe</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param weights:</span>
<span class="sd">            The synaptic strengths. Can be:</span>

<span class="sd">            * single value: the same value will be used for all weights</span>
<span class="sd">            * :py:class:`list`: the total number of elements must be</span>
<span class="sd">              (number after pooling * number post)</span>
<span class="sd">            * :py:class:`~numpy.ndarray`: As above for list</span>
<span class="sd">            * :py:class:`~spynnaker.pyNN.RandomDistribution`:</span>
<span class="sd">              weights will be drawn at random</span>
<span class="sd">        :type weights:</span>
<span class="sd">            int or float or list(int or float) or ~numpy.ndarray or</span>
<span class="sd">            ~spynnaker.pyNN.RandomDistribution</span>
<span class="sd">        :param pool_shape:</span>
<span class="sd">            Shape of average pooling. If a single value is provided, it will</span>
<span class="sd">            be used for every dimension, otherwise must be the same number of</span>
<span class="sd">            values as there are dimensions in the source.</span>
<span class="sd">        :type pool_shape: int or tuple(int) or None</span>
<span class="sd">        :param pool_stride:</span>
<span class="sd">            Jumps between pooling regions. If a single value is provided, the</span>
<span class="sd">            same stride will be used for all dimensions, otherwise must be</span>
<span class="sd">            the same number of values as there are dimensions in the source.</span>
<span class="sd">            If `None`, and pool_shape is provided, pool_stride will be set to</span>
<span class="sd">            pool_shape.</span>
<span class="sd">        :type pool_stride: int or tuple(int) or None</span>
<span class="sd">        :param str positive_receptor_type:</span>
<span class="sd">            The receptor type to add the positive weights to.  By default this</span>
<span class="sd">            is &quot;excitatory&quot;.</span>
<span class="sd">        :param str negative_receptor_type:</span>
<span class="sd">            The receptor type to add the negative weights to.  By default this</span>
<span class="sd">            is &quot;inhibitory&quot;.</span>
<span class="sd">        :param bool safe: (ignored)</span>
<span class="sd">        :param bool verbose: (ignored)</span>
<span class="sd">        :param callable callback: (ignored)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PoolDenseConnector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">safe</span><span class="o">=</span><span class="n">safe</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__pool_shape</span> <span class="o">=</span> <span class="n">pool_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__pool_stride</span> <span class="o">=</span> <span class="n">pool_stride</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pool_stride</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__pool_stride</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pool_shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__positive_receptor_type</span> <span class="o">=</span> <span class="n">positive_receptor_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__negative_receptor_type</span> <span class="o">=</span> <span class="n">negative_receptor_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">positive_receptor_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__positive_receptor_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">negative_receptor_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__negative_receptor_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: ~numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span>

    <span class="k">def</span> <span class="nf">__decode_weights</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">pre_shape</span><span class="p">,</span> <span class="n">post_shape</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">n_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_n_sub_weights</span><span class="p">(</span>
                <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">pre_in_post_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_pre_in_post_shape</span><span class="p">(</span><span class="n">pre_shape</span><span class="p">))</span>
            <span class="n">all_weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">pre_in_post_shape</span> <span class="o">+</span> <span class="n">post_shape</span><span class="p">)</span>
            <span class="n">pre_in_post_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pre_as_post</span><span class="p">(</span><span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="n">pre_in_post_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pre_as_post</span><span class="p">(</span><span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
            <span class="n">pip_slices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="nb">slice</span><span class="p">(</span><span class="n">pip_start</span><span class="p">,</span> <span class="n">pip_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">pip_start</span><span class="p">,</span> <span class="n">pip_end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">pre_in_post_start</span><span class="p">,</span> <span class="n">pre_in_post_end</span><span class="p">))</span>
            <span class="n">post_slices</span> <span class="o">=</span> <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">slices</span>
            <span class="k">return</span> <span class="n">all_weights</span><span class="p">[</span><span class="n">pip_slices</span> <span class="o">+</span> <span class="n">post_slices</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">,</span> <span class="n">RandomDistribution</span><span class="p">):</span>
            <span class="n">n_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_n_sub_weights</span><span class="p">(</span>
                <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="n">n_weights</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SynapticConfigurationException</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown weights (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__to_nd_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">,</span> <span class="n">param_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">shape</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_dims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_dims</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">SynapticConfigurationException</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2"> must be an int or a tuple(int) with </span><span class="si">{</span><span class="n">n_dims</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="s2">&quot; dimensions&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="PoolDenseConnector.get_post_pool_shape"><a class="viewcode-back" href="../../../../../../spynnaker.pyNN.models.neural_projections.connectors.html#spynnaker.pyNN.PoolDenseConnector.get_post_pool_shape">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_post_pool_shape</span><span class="p">(</span>
            <span class="n">pre_shape</span><span class="p">,</span> <span class="n">pool_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pool_stride</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">pool_shape</span> <span class="o">=</span> <span class="n">PoolDenseConnector</span><span class="o">.</span><span class="n">__to_nd_shape</span><span class="p">(</span>
            <span class="n">pool_shape</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre_shape</span><span class="p">),</span> <span class="s2">&quot;pool_shape&quot;</span><span class="p">)</span>
        <span class="n">pool_stride</span> <span class="o">=</span> <span class="n">PoolDenseConnector</span><span class="o">.</span><span class="n">__to_nd_shape</span><span class="p">(</span>
            <span class="n">pool_stride</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre_shape</span><span class="p">),</span> <span class="s2">&quot;pool_stride&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pool_stride</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pool_stride</span> <span class="o">=</span> <span class="n">pool_shape</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pre_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pool_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">post_pool_shape</span> <span class="o">=</span> <span class="n">shape</span> <span class="o">-</span> <span class="p">(</span><span class="n">pool_shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">post_pool_shape</span> <span class="o">//</span> <span class="n">pool_stride</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">shape</span></div>

    <span class="k">def</span> <span class="nf">__get_pre_in_post_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre_shape</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_post_pool_shape</span><span class="p">(</span>
            <span class="n">pre_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pool_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pool_stride</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_n_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre_shape</span><span class="p">,</span> <span class="n">post_shape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the expected number of weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_pre_in_post_shape</span><span class="p">(</span><span class="n">pre_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">post_shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_n_sub_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">n_post_atoms</span><span class="p">):</span>
        <span class="n">pre_in_post_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pre_as_post</span><span class="p">(</span><span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="n">pre_in_post_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pre_as_post</span><span class="p">(</span><span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">((</span><span class="n">pre_in_post_end</span> <span class="o">-</span> <span class="n">pre_in_post_start</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
                <span class="n">n_post_atoms</span><span class="p">)</span>

<div class="viewcode-block" id="PoolDenseConnector.validate_connection"><a class="viewcode-back" href="../../../../../../spynnaker.pyNN.models.neural_projections.connectors.html#spynnaker.pyNN.PoolDenseConnector.validate_connection">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">AbstractConnector</span><span class="o">.</span><span class="n">validate_connection</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">validate_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">application_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">application_edge</span><span class="o">.</span><span class="n">pre_vertex</span>
        <span class="n">post</span> <span class="o">=</span> <span class="n">application_edge</span><span class="o">.</span><span class="n">post_vertex</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre</span><span class="o">.</span><span class="n">atoms_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span>
                <span class="s2">&quot;The PoolDenseConnector only works where the pre-Population&quot;</span>
                <span class="s2">&quot; of a Projection is 2D.  Please ensure that the&quot;</span>
                <span class="s2">&quot; Population uses a Grid2D structure.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">expected_n_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_n_weights</span><span class="p">(</span>
                <span class="n">pre</span><span class="o">.</span><span class="n">atoms_shape</span><span class="p">,</span> <span class="n">post</span><span class="o">.</span><span class="n">atoms_shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">expected_n_weights</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;With a source population with shape </span><span class="si">{</span><span class="n">pre</span><span class="o">.</span><span class="n">atoms_shape</span><span class="si">}</span><span class="s2">,&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; and a target population with shape </span><span class="si">{</span><span class="n">post</span><span class="o">.</span><span class="n">atoms_shape</span><span class="si">}</span><span class="s2">,&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; this connector requires </span><span class="si">{</span><span class="n">expected_n_weights</span><span class="si">}</span><span class="s2"> weights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">post</span><span class="o">.</span><span class="n">get_synapse_id_by_target</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__positive_receptor_type</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span>
                <span class="s2">&quot;The post population doesn&#39;t have a synaptic receptor type of&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__positive_receptor_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">post</span><span class="o">.</span><span class="n">get_synapse_id_by_target</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__negative_receptor_type</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span>
                <span class="s2">&quot;The post population doesn&#39;t have a synaptic receptor type of&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__negative_receptor_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="PoolDenseConnector.get_delay_minimum"><a class="viewcode-back" href="../../../../../../spynnaker.pyNN.models.neural_projections.connectors.html#spynnaker.pyNN.PoolDenseConnector.get_delay_minimum">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">AbstractConnector</span><span class="o">.</span><span class="n">get_delay_minimum</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_delay_minimum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">delays</span></div>

<div class="viewcode-block" id="PoolDenseConnector.get_delay_maximum"><a class="viewcode-back" href="../../../../../../spynnaker.pyNN.models.neural_projections.connectors.html#spynnaker.pyNN.PoolDenseConnector.get_delay_maximum">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">AbstractConnector</span><span class="o">.</span><span class="n">get_delay_maximum</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_delay_maximum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">delays</span></div>

<div class="viewcode-block" id="PoolDenseConnector.get_n_connections_from_pre_vertex_maximum"><a class="viewcode-back" href="../../../../../../spynnaker.pyNN.models.neural_projections.connectors.html#spynnaker.pyNN.PoolDenseConnector.get_n_connections_from_pre_vertex_maximum">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">AbstractConnector</span><span class="o">.</span><span class="n">get_n_connections_from_pre_vertex_maximum</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_n_connections_from_pre_vertex_maximum</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">n_post_atoms</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">min_delay</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">max_delay</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">min_delay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_delay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">delay</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">delays</span>
            <span class="k">if</span> <span class="n">min_delay</span> <span class="o">&gt;</span> <span class="n">delay</span> <span class="ow">or</span> <span class="n">max_delay</span> <span class="o">&lt;</span> <span class="n">delay</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="c1"># Every pre connects to every post</span>
        <span class="k">return</span> <span class="n">n_post_atoms</span></div>

<div class="viewcode-block" id="PoolDenseConnector.get_n_connections_to_post_vertex_maximum"><a class="viewcode-back" href="../../../../../../spynnaker.pyNN.models.neural_projections.connectors.html#spynnaker.pyNN.PoolDenseConnector.get_n_connections_to_post_vertex_maximum">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">AbstractConnector</span><span class="o">.</span><span class="n">get_n_connections_to_post_vertex_maximum</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_n_connections_to_post_vertex_maximum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
        <span class="c1"># Every post connects to every pre</span>
        <span class="k">return</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">n_pre_neurons</span></div>

<div class="viewcode-block" id="PoolDenseConnector.get_weight_maximum"><a class="viewcode-back" href="../../../../../../spynnaker.pyNN.models.neural_projections.connectors.html#spynnaker.pyNN.PoolDenseConnector.get_weight_maximum">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">AbstractConnector</span><span class="o">.</span><span class="n">get_weight_maximum</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_weight_maximum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">))</span>
        <span class="n">n_conns</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">n_pre_neurons</span> <span class="o">*</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">n_post_neurons</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">PoolDenseConnector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_get_weight_maximum</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span><span class="p">,</span> <span class="n">n_conns</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__pre_as_post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre_coords</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write pre coordinates as post coordinates.</span>

<span class="sd">        :param ~collections.abc.Iterable pre_coords:</span>
<span class="sd">            An iterable of (x, y) coordinates</span>
<span class="sd">        :rtype: ~numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pre_coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pool_stride</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">//=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pool_stride</span>
        <span class="k">return</span> <span class="n">coords</span>

<div class="viewcode-block" id="PoolDenseConnector.local_only_n_bytes"><a class="viewcode-back" href="../../../../../../spynnaker.pyNN.models.neural_projections.connectors.html#spynnaker.pyNN.PoolDenseConnector.local_only_n_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">local_only_n_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incoming_slices</span><span class="p">,</span> <span class="n">n_post_atoms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param iterable(~pacman.model.graphs.common.Slice) incoming_slices:</span>
<span class="sd">        :param int n_post_atoms:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_weights</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_n_sub_weights</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n_post_atoms</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">incoming_slices</span><span class="p">]</span>
        <span class="n">n_weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n_weights</span><span class="p">]</span>
        <span class="n">n_dims</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">incoming_slices</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">((</span><span class="nb">sum</span><span class="p">(</span><span class="n">n_dims</span><span class="p">)</span> <span class="o">*</span> <span class="n">_DIMENSION_SIZE</span><span class="p">)</span> <span class="o">+</span>
                <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">n_weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">BYTES_PER_SHORT</span><span class="p">)</span> <span class="o">+</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">incoming_slices</span><span class="p">)</span> <span class="o">*</span> <span class="n">_CONN_SIZE</span><span class="p">))</span></div>

<div class="viewcode-block" id="PoolDenseConnector.write_local_only_data"><a class="viewcode-back" href="../../../../../../spynnaker.pyNN.models.neural_projections.connectors.html#spynnaker.pyNN.PoolDenseConnector.write_local_only_data">[docs]</a>    <span class="k">def</span> <span class="nf">write_local_only_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">n_colour_bits</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~data_specification.DataSpecificationGenerator spec:</span>
<span class="sd">        :param ~pacman.model.graphs.application.ApplicationEdge app_edge:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice pre_vertex_slice:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice post_vertex_slice:</span>
<span class="sd">        :param int key:</span>
<span class="sd">        :param int mask:</span>
<span class="sd">        :param int n_colour_bits:</span>
<span class="sd">        :param weight_scales:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Write source key info</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">DataType</span><span class="o">.</span><span class="n">UINT32</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">DataType</span><span class="o">.</span><span class="n">UINT32</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">n_colour_bits</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">DataType</span><span class="o">.</span><span class="n">UINT32</span><span class="p">)</span>

        <span class="c1"># Write numbers of things</span>
        <span class="n">n_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">n_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_n_sub_weights</span><span class="p">(</span>
            <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">n_dims</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">DataType</span><span class="o">.</span><span class="n">UINT32</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">n_weights</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">DataType</span><span class="o">.</span><span class="n">UINT32</span><span class="p">)</span>

        <span class="c1"># Write synapse information</span>
        <span class="n">pos_synapse_type</span> <span class="o">=</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">post_vertex</span><span class="o">.</span><span class="n">get_synapse_id_by_target</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__positive_receptor_type</span><span class="p">)</span>
        <span class="n">neg_synapse_type</span> <span class="o">=</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">post_vertex</span><span class="o">.</span><span class="n">get_synapse_id_by_target</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__negative_receptor_type</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">pos_synapse_type</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">DataType</span><span class="o">.</span><span class="n">UINT16</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">neg_synapse_type</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">DataType</span><span class="o">.</span><span class="n">UINT16</span><span class="p">)</span>

        <span class="c1"># Write delay</span>
        <span class="n">delay_step</span> <span class="o">=</span> <span class="p">(</span><span class="n">app_edge</span><span class="o">.</span><span class="n">post_vertex</span><span class="o">.</span><span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">delay</span> <span class="o">*</span>
                      <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_simulation_time_step_per_ms</span><span class="p">())</span>
        <span class="n">local_delay</span> <span class="o">=</span> <span class="p">(</span><span class="n">delay_step</span> <span class="o">%</span>
                       <span class="n">app_edge</span><span class="o">.</span><span class="n">post_vertex</span><span class="o">.</span><span class="n">splitter</span><span class="o">.</span><span class="n">max_support_delay</span><span class="p">())</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">local_delay</span><span class="p">)</span>

        <span class="c1"># Generate the dimension information</span>
        <span class="n">dim_info</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_dims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_DIM_DTYPE</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pool_stride</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stride</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__to_nd_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__pool_stride</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">dim_info</span><span class="p">[</span><span class="s2">&quot;recip_pool_stride&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__recip</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">stride</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dim_info</span><span class="p">[</span><span class="s2">&quot;recip_pool_stride&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__recip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">,</span> <span class="n">HasShapeKeyFields</span><span class="p">):</span>
            <span class="n">pre_start_size_mask_shift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">get_shape_key_fields</span><span class="p">(</span><span class="n">pre_vertex_slice</span><span class="p">))</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">pre_start_size_mask_shift</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">pre_start_size_mask_shift</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">dim_info</span><span class="p">[</span><span class="s2">&quot;pre_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
            <span class="n">dim_info</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pre_start_size_mask_shift</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">dim_info</span><span class="p">[</span><span class="s2">&quot;shift&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pre_start_size_mask_shift</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">n_bits</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">size</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
            <span class="n">shifts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">n_bits</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
            <span class="n">masks</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shifts</span><span class="p">)</span>
            <span class="n">dim_info</span><span class="p">[</span><span class="s2">&quot;pre_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
            <span class="n">dim_info</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">masks</span>
            <span class="n">dim_info</span><span class="p">[</span><span class="s2">&quot;shift&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shifts</span>

        <span class="n">dim_info</span><span class="p">[</span><span class="s2">&quot;pre_in_post_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pre_as_post</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">dim_info</span><span class="p">[</span><span class="s2">&quot;pre_in_post_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pre_as_post</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">dim_info</span><span class="p">[</span><span class="s2">&quot;pre_in_post_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">dim_info</span><span class="p">[</span><span class="s2">&quot;pre_in_post_end&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">dim_info</span><span class="p">[</span><span class="s2">&quot;pre_in_post_start&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">dim_info</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">))</span>

        <span class="c1"># Work out which weights are for this connection</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__decode_weights</span><span class="p">(</span>
            <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">atoms_shape</span><span class="p">,</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">post_vertex</span><span class="o">.</span><span class="n">atoms_shape</span><span class="p">,</span>
            <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">)</span>

        <span class="c1"># Divide weights by pooling area if needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pool_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__to_nd_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__pool_shape</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">area</span>

        <span class="c1"># Encode weights with weight scaling</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">weights</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">neg_weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">pos_weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">neg_weights</span><span class="p">]</span> <span class="o">*=</span> <span class="n">weight_scales</span><span class="p">[</span><span class="n">neg_synapse_type</span><span class="p">]</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">pos_weights</span><span class="p">]</span> <span class="o">*=</span> <span class="n">weight_scales</span><span class="p">[</span><span class="n">pos_synapse_type</span><span class="p">]</span>
        <span class="n">final_weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">final_weights</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__recip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the reciprocal of a number as an signed 1-bit integer,</span>
<span class="sd">        14-bit fractional fixed point number, encoded in an integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">)))</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../../index.html">sPyNNaker 6.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../../pyNN.html" >spynnaker.pyNN</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spynnaker.pyNN.models.neural_projections.connectors.pool_dense_connector</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-2023.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.1.3.
    </div>
  </body>
</html>