
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>spynnaker.pyNN.models.common.neuron_recorder &#8212; sPyNNaker  documentation</title>
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/sphinxdoc.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../_static/jquery.js"></script>
    <script src="../../../../../_static/underscore.js"></script>
    <script src="../../../../../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">sPyNNaker  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spynnaker.pyNN.models.common.neuron_recorder</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for spynnaker.pyNN.models.common.neuron_recorder</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2017-2019 The University of Manchester</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">raise_from</span><span class="p">,</span> <span class="n">iteritems</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">range</span><span class="p">,</span> <span class="n">xrange</span>
<span class="kn">from</span> <span class="nn">spinn_utilities.log</span> <span class="kn">import</span> <span class="n">FormatAdapter</span>
<span class="kn">from</span> <span class="nn">spinn_utilities.progress_bar</span> <span class="kn">import</span> <span class="n">ProgressBar</span>
<span class="kn">from</span> <span class="nn">pacman.model.resources.variable_sdram</span> <span class="kn">import</span> <span class="n">VariableSDRAM</span>
<span class="kn">from</span> <span class="nn">data_specification.enums</span> <span class="kn">import</span> <span class="n">DataType</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.exceptions</span> <span class="kn">import</span> <span class="n">ConfigurationException</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities</span> <span class="kn">import</span> <span class="n">globals_variables</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BYTES_PER_WORD</span><span class="p">,</span> <span class="n">MICRO_TO_MILLISECOND_CONVERSION</span><span class="p">,</span> <span class="n">BITS_PER_WORD</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.interface.buffer_management.recording_utilities</span> \
    <span class="kn">import</span> <span class="p">(</span>
        <span class="n">get_recording_header_array</span><span class="p">,</span> <span class="n">get_recording_header_size</span><span class="p">,</span>
        <span class="n">get_recording_data_constant_size</span><span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">FormatAdapter</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">_ReadOnlyDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__readonly__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pylint: disable=unused-argument</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot modify ReadOnlyDict&quot;</span><span class="p">)</span>

    <span class="fm">__setitem__</span> <span class="o">=</span> <span class="n">__readonly__</span>
    <span class="fm">__delitem__</span> <span class="o">=</span> <span class="n">__readonly__</span>
    <span class="n">pop</span> <span class="o">=</span> <span class="n">__readonly__</span>
    <span class="n">popitem</span> <span class="o">=</span> <span class="n">__readonly__</span>
    <span class="n">clear</span> <span class="o">=</span> <span class="n">__readonly__</span>
    <span class="n">update</span> <span class="o">=</span> <span class="n">__readonly__</span>
    <span class="n">setdefault</span> <span class="o">=</span> <span class="n">__readonly__</span>
    <span class="k">del</span> <span class="n">__readonly__</span>


<span class="k">def</span> <span class="nf">get_sampling_interval</span><span class="p">(</span><span class="n">sampling_rate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return the current sampling interval given a sampling rate</span>

<span class="sd">    :param float sampling_rate: The sampling rate in time steps</span>
<span class="sd">    :return: Sampling interval in microseconds</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="n">globals_variables</span><span class="o">.</span><span class="n">get_simulator</span><span class="p">()</span><span class="o">.</span><span class="n">machine_time_step</span> <span class="o">/</span>
            <span class="n">MICRO_TO_MILLISECOND_CONVERSION</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sampling_rate</span> <span class="o">*</span> <span class="n">step</span>


<div class="viewcode-block" id="NeuronRecorder"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder">[docs]</a><span class="k">class</span> <span class="nc">NeuronRecorder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;__indexes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__n_neurons&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__sampling_rates&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__data_types&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__bitfield_variables&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__per_timestep_variables&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__per_timestep_datatypes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__per_timestep_recording&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__region_ids&quot;</span><span class="p">]</span>

    <span class="n">_N_BYTES_FOR_TIMESTAMP</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span>
    <span class="n">_N_BYTES_PER_RATE</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span>
    <span class="n">_N_BYTES_PER_ENUM</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span>

    <span class="c1">#: size of a index in terms of position into recording array</span>
    <span class="n">_N_BYTES_PER_INDEX</span> <span class="o">=</span> <span class="n">DataType</span><span class="o">.</span><span class="n">UINT8</span><span class="o">.</span><span class="n">size</span>  <span class="c1"># currently uint8</span>

    <span class="c1">#: size of the counter for spike recording</span>
    <span class="n">_N_BYTES_PER_COUNT</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span>

    <span class="c1">#: size of the increment for spike recording</span>
    <span class="n">_N_BYTES_PER_INCREMENT</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span>

    <span class="n">_N_BYTES_PER_SIZE</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span>
    <span class="c1"># sampling temporal value size (how many ticks between recordings)</span>
    <span class="n">_N_CPU_CYCLES_PER_NEURON</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">_N_BYTES_PER_POINTER</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span>
    <span class="n">_SARK_BLOCK_SIZE</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>  <span class="c1"># Seen in sark.c</span>

    <span class="c1">#: size of the counter for outstanding recording</span>
    <span class="n">_N_BYTES_PER_OUTSTANDING_RECORDING</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span>

    <span class="c1">#: number of items types (currently non-bitfield and bitfield)</span>
    <span class="n">_N_ITEM_TYPES</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1">#: flag for spikes</span>
    <span class="n">SPIKES</span> <span class="o">=</span> <span class="s2">&quot;spikes&quot;</span>

    <span class="c1">#: packets-per-timestep</span>
    <span class="n">PACKETS</span> <span class="o">=</span> <span class="s2">&quot;packets-per-timestep&quot;</span>

    <span class="c1">#: packets-per-timestep data type</span>
    <span class="n">PACKETS_TYPE</span> <span class="o">=</span> <span class="n">DataType</span><span class="o">.</span><span class="n">UINT32</span>

    <span class="n">_MAX_RATE</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">32</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># To allow a unit32_t to be used to store the rate</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">allowed_variables</span><span class="p">,</span> <span class="n">data_types</span><span class="p">,</span> <span class="n">bitfield_variables</span><span class="p">,</span>
            <span class="n">n_neurons</span><span class="p">,</span> <span class="n">per_timestep_variables</span><span class="p">,</span> <span class="n">per_timestep_datatypes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param list(str) allowed_variables:</span>
<span class="sd">        :param list(str) data_types:</span>
<span class="sd">        :param list(str) bitfield_variables:</span>
<span class="sd">        :param int n_neurons:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__data_types</span> <span class="o">=</span> <span class="n">data_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__n_neurons</span> <span class="o">=</span> <span class="n">n_neurons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__bitfield_variables</span> <span class="o">=</span> <span class="n">bitfield_variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span> <span class="o">=</span> <span class="n">per_timestep_variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_datatypes</span> <span class="o">=</span> <span class="n">per_timestep_datatypes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_recording</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__region_ids</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">region_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="n">allowed_variables</span><span class="p">,</span> <span class="n">bitfield_variables</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__region_ids</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">region_id</span>
        <span class="k">for</span> <span class="n">ts_region_id</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">per_timestep_variables</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">region_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__region_ids</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts_region_id</span>

    <span class="k">def</span> <span class="nf">_count_recording_per_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str variable:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;=</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span>
                   <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_neurons_recording</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str variable:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :rtype: iterable(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">range</span><span class="p">(</span><span class="n">vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>

<div class="viewcode-block" id="NeuronRecorder.get_neuron_sampling_interval"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.get_neuron_sampling_interval">[docs]</a>    <span class="k">def</span> <span class="nf">get_neuron_sampling_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the current sampling interval for this variable</span>

<span class="sd">        :param str variable: PyNN name of the variable</span>
<span class="sd">        :return: Sampling interval in microseconds</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">get_sampling_interval</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">get_sampling_interval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_convert_placement_matrix_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">row_data</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">data_row_length</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">,</span> <span class="n">data_type</span><span class="p">):</span>

        <span class="n">surplus_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_FOR_TIMESTAMP</span>
        <span class="n">var_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_data</span><span class="p">[:,</span> <span class="n">surplus_bytes</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">n_rows</span> <span class="o">*</span> <span class="n">data_row_length</span><span class="p">))</span>
        <span class="n">placement_data</span> <span class="o">=</span> <span class="n">data_type</span><span class="o">.</span><span class="n">decode_array</span><span class="p">(</span><span class="n">var_data</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">placement_data</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_process_missing_data</span><span class="p">(</span>
            <span class="n">missing_str</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">expected_rows</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">placement_data</span><span class="p">):</span>
        <span class="n">missing_str</span> <span class="o">+=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">); &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="c1"># Start the fragment for this slice empty</span>
        <span class="n">fragment</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">expected_rows</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">expected_rows</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">sampling_rate</span>
            <span class="c1"># Check if there is data for this time step</span>
            <span class="n">local_indexes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">times</span> <span class="o">==</span> <span class="n">time</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fragment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">placement_data</span><span class="p">[</span><span class="n">local_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fragment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">placement_data</span><span class="p">[</span><span class="n">local_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Population </span><span class="si">{}</span><span class="s2"> has multiple recorded data for time </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">label</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Set row to nan</span>
                <span class="n">fragment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fragment</span>

    <span class="k">def</span> <span class="nf">_get_placement_matrix_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">buffer_manager</span><span class="p">,</span> <span class="n">expected_rows</span><span class="p">,</span>
            <span class="n">missing_str</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">n_per_timestep</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; processes a placement for matrix data</span>

<span class="sd">        :param ~pacman.model.placements.Placements placements:</span>
<span class="sd">            the placements object</span>
<span class="sd">        :param ~pacman.model.graphs.machine.MachineVertex vertex:</span>
<span class="sd">            the vertex to read from</span>
<span class="sd">        :param int region: the recording region id</span>
<span class="sd">        :param ~.BufferManager buffer_manager: the buffer manager</span>
<span class="sd">        :param int expected_rows:</span>
<span class="sd">            how many rows the tools think should be recorded</span>
<span class="sd">        :param str missing_str: string for reporting missing stuff</span>
<span class="sd">        :param int sampling_rate: the rate of sampling</span>
<span class="sd">        :param str label: the vertex label.</span>
<span class="sd">        :return: placement data</span>
<span class="sd">        :rtype: ~numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">placement</span> <span class="o">=</span> <span class="n">placements</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_per_timestep</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># for buffering output info is taken form the buffer manager</span>
        <span class="n">record_raw</span><span class="p">,</span> <span class="n">missing_data</span> <span class="o">=</span> <span class="n">buffer_manager</span><span class="o">.</span><span class="n">get_data_by_placement</span><span class="p">(</span>
            <span class="n">placement</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>
        <span class="n">record_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">record_raw</span><span class="p">)</span>

        <span class="c1"># If there is no data, return empty for all timesteps</span>
        <span class="k">if</span> <span class="n">record_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">expected_rows</span><span class="p">,</span> <span class="n">n_per_timestep</span><span class="p">),</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>

        <span class="c1"># There is one column for time and one for each neuron recording</span>
        <span class="n">data_row_length</span> <span class="o">=</span> <span class="n">n_per_timestep</span> <span class="o">*</span> <span class="n">data_type</span><span class="o">.</span><span class="n">size</span>
        <span class="n">full_row_length</span> <span class="o">=</span> <span class="n">data_row_length</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_FOR_TIMESTAMP</span>
        <span class="n">n_rows</span> <span class="o">=</span> <span class="n">record_length</span> <span class="o">//</span> <span class="n">full_row_length</span>
        <span class="n">row_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">record_raw</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">n_rows</span><span class="p">,</span> <span class="n">full_row_length</span><span class="p">)</span>
        <span class="n">placement_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_placement_matrix_data</span><span class="p">(</span>
            <span class="n">row_data</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">data_row_length</span><span class="p">,</span> <span class="n">n_per_timestep</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span>

        <span class="c1"># If everything is there, return it</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">missing_data</span> <span class="ow">and</span> <span class="n">n_rows</span> <span class="o">==</span> <span class="n">expected_rows</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">placement_data</span>

        <span class="c1"># Got data but its missing bits, so get times</span>
        <span class="n">time_bytes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">row_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_FOR_TIMESTAMP</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">n_rows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_FOR_TIMESTAMP</span><span class="p">))</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">time_bytes</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;&lt;i4&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_rows</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># process data from core for missing data</span>
        <span class="n">placement_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_missing_data</span><span class="p">(</span>
            <span class="n">missing_str</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">expected_rows</span><span class="p">,</span> <span class="n">n_per_timestep</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">placement_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">placement_data</span>

<div class="viewcode-block" id="NeuronRecorder.expected_rows_for_a_run_time"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.expected_rows_for_a_run_time">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">expected_rows_for_a_run_time</span><span class="p">(</span><span class="n">n_machine_time_steps</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; determines how many rows to see based off how long its ran for</span>

<span class="sd">        :param int n_machine_time_steps: map of vertex to time steps</span>
<span class="sd">        :param float sampling_rate: the sampling rate for a given variable</span>
<span class="sd">        :return: how many rows there should be.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_machine_time_steps</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__read_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">buffer_manager</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">n_machine_time_steps</span><span class="p">):</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">application_vertex</span><span class="o">.</span><span class="n">splitter</span><span class="o">.</span><span class="n">machine_vertices_for_recording</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">))</span>
        <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__region_ids</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
        <span class="n">missing_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">pop_level_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">sampling_interval</span> <span class="o">=</span> <span class="n">get_sampling_interval</span><span class="p">(</span><span class="n">sampling_rate</span><span class="p">)</span>

        <span class="n">progress</span> <span class="o">=</span> <span class="n">ProgressBar</span><span class="p">(</span>
            <span class="n">vertices</span><span class="p">,</span> <span class="s2">&quot;Getting </span><span class="si">{}</span><span class="s2"> for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">progress</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">vertices</span><span class="p">)):</span>
            <span class="n">expected_rows</span> <span class="o">=</span> <span class="n">application_vertex</span><span class="o">.</span><span class="n">get_expected_n_rows</span><span class="p">(</span>
                <span class="n">n_machine_time_steps</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>

            <span class="n">n_items_per_timestep</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">:</span>
                <span class="n">neurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neurons_recording</span><span class="p">(</span>
                    <span class="n">variable</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">vertex_slice</span><span class="p">)</span>
                <span class="n">n_items_per_timestep</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span>
                <span class="n">indexes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">placement_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_placement_matrix_data</span><span class="p">(</span>
                <span class="n">placements</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">buffer_manager</span><span class="p">,</span> <span class="n">expected_rows</span><span class="p">,</span>
                <span class="n">missing_str</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span>
                <span class="n">n_items_per_timestep</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">placement_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># append to the population data</span>
                <span class="k">if</span> <span class="n">pop_level_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">pop_level_data</span> <span class="o">=</span> <span class="n">placement_data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Add the slice fragment on axis 1</span>
                    <span class="c1"># which is IDs/channel_index</span>
                    <span class="n">pop_level_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">pop_level_data</span><span class="p">,</span> <span class="n">placement_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># warn user of missing data</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Population </span><span class="si">{}</span><span class="s2"> is missing recorded data in region </span><span class="si">{}</span><span class="s2"> from the&quot;</span>
                <span class="s2">&quot; following cores: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">missing_str</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pop_level_data</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">sampling_interval</span>

<div class="viewcode-block" id="NeuronRecorder.get_matrix_data"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.get_matrix_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">buffer_manager</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span>
            <span class="n">application_vertex</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">n_machine_time_steps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read a data mapped to time and neuron IDs from the SpiNNaker\</span>
<span class="sd">            machine and converts to required data types with scaling if needed.</span>

<span class="sd">        :param str label: vertex label</span>
<span class="sd">        :param buffer_manager: the manager for buffered data</span>
<span class="sd">        :type buffer_manager:</span>
<span class="sd">            ~spinn_front_end_common.interface.buffer_management.BufferManager</span>
<span class="sd">        :param ~pacman.model.placements.Placements placements:</span>
<span class="sd">            the placements object</span>
<span class="sd">        :param application_vertex:</span>
<span class="sd">        :type application_vertex:</span>
<span class="sd">            ~pacman.model.graphs.application.ApplicationVertex</span>
<span class="sd">        :param str variable: PyNN name for the variable (`V`, `gsy_inh`, etc.)</span>
<span class="sd">        :param int n_machine_time_steps:</span>
<span class="sd">        :return: (data, recording_indices, sampling_interval)</span>
<span class="sd">        :rtype: tuple(~numpy.ndarray, list(int), float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bitfield_variables</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Variable </span><span class="si">{}</span><span class="s2"> is not supported, use get_spikes&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">:</span>
            <span class="n">sampling_rate</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_datatypes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__data_types</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__read_data</span><span class="p">(</span>
            <span class="n">label</span><span class="p">,</span> <span class="n">buffer_manager</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">n_machine_time_steps</span><span class="p">)</span></div>

<div class="viewcode-block" id="NeuronRecorder.get_spikes"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.get_spikes">[docs]</a>    <span class="k">def</span> <span class="nf">get_spikes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">buffer_manager</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span>
            <span class="n">application_vertex</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read spikes mapped to time and neuron IDs from the SpiNNaker\</span>
<span class="sd">            machine.</span>

<span class="sd">        :param str label: vertex label</span>
<span class="sd">        :param buffer_manager: the manager for buffered data</span>
<span class="sd">        :type buffer_manager:</span>
<span class="sd">            ~spinn_front_end_common.interface.buffer_management.BufferManager</span>
<span class="sd">        :param ~pacman.model.placements.Placements placements:</span>
<span class="sd">            the placements object</span>
<span class="sd">        :param application_vertex:</span>
<span class="sd">        :type application_vertex:</span>
<span class="sd">            ~pacman.model.graphs.application.ApplicationVertex</span>
<span class="sd">        :param str variable:</span>
<span class="sd">        :param int machine_time_step: microseconds</span>
<span class="sd">        :return:</span>
<span class="sd">        :rtype: ~numpy.ndarray(tuple(int,int))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bitfield_variables</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Variable </span><span class="si">{}</span><span class="s2"> is not supported, use get_matrix_data&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">spike_times</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">spike_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="n">vertices</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">application_vertex</span><span class="o">.</span><span class="n">splitter</span><span class="o">.</span><span class="n">machine_vertices_for_recording</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">))</span>
        <span class="n">missing_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="n">ProgressBar</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="s2">&quot;Getting spikes for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">progress</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
            <span class="n">placement</span> <span class="o">=</span> <span class="n">placements</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
            <span class="n">vertex_slice</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">vertex_slice</span>

            <span class="n">ms_per_tick</span> <span class="o">=</span> <span class="n">machine_time_step</span> <span class="o">/</span> <span class="n">MICRO_TO_MILLISECOND_CONVERSION</span>
            <span class="n">neurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neurons_recording</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">)</span>
            <span class="n">neurons_recording</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">neurons_recording</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Read the spikes</span>
            <span class="n">n_words</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">neurons_recording</span> <span class="o">/</span> <span class="n">BITS_PER_WORD</span><span class="p">))</span>
            <span class="n">n_bytes</span> <span class="o">=</span> <span class="n">n_words</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
            <span class="n">n_words_with_timestamp</span> <span class="o">=</span> <span class="n">n_words</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># for buffering output info is taken form the buffer manager</span>
            <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__region_ids</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
            <span class="n">record_raw</span><span class="p">,</span> <span class="n">data_missing</span> <span class="o">=</span> <span class="n">buffer_manager</span><span class="o">.</span><span class="n">get_data_by_placement</span><span class="p">(</span>
                    <span class="n">placement</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data_missing</span><span class="p">:</span>
                <span class="n">missing_str</span> <span class="o">+=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">); &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">record_raw</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">raw_data</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">record_raw</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;&lt;i4&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_words_with_timestamp</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">raw_data</span> <span class="o">=</span> <span class="n">record_raw</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">record_time</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">ms_per_tick</span><span class="p">)</span>
                <span class="n">spikes</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">byteswap</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span>
                <span class="n">bits</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">(</span><span class="n">spikes</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">)))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_bytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span>
                <span class="n">time_indices</span><span class="p">,</span> <span class="n">local_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bits</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">local_indices</span> <span class="o">+</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span>
                    <span class="n">times</span> <span class="o">=</span> <span class="n">record_time</span><span class="p">[</span><span class="n">time_indices</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">spike_ids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                    <span class="n">spike_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">time_indice</span><span class="p">,</span> <span class="n">local</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">time_indices</span><span class="p">,</span> <span class="n">local_indices</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">local</span> <span class="o">&lt;</span> <span class="n">neurons_recording</span><span class="p">:</span>
                            <span class="n">spike_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neurons</span><span class="p">[</span><span class="n">local</span><span class="p">])</span>
                            <span class="n">spike_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">record_time</span><span class="p">[</span><span class="n">time_indice</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Population </span><span class="si">{}</span><span class="s2"> is missing spike data in region </span><span class="si">{}</span><span class="s2"> from the&quot;</span>
                <span class="s2">&quot; following cores: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">missing_str</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">spike_ids</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">spike_ids</span><span class="p">))]</span></div>

<div class="viewcode-block" id="NeuronRecorder.get_recordable_variables"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.get_recordable_variables">[docs]</a>    <span class="k">def</span> <span class="nf">get_recordable_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: iterable(str)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">variables</span></div>

<div class="viewcode-block" id="NeuronRecorder.is_recording"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.is_recording">[docs]</a>    <span class="k">def</span> <span class="nf">is_recording</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str variable:</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_recording</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">variable</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Variable </span><span class="si">{}</span><span class="s2"> is not supported. Supported variables are&quot;</span>
                       <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_recordable_variables</span><span class="p">()))</span>
                <span class="n">raise_from</span><span class="p">(</span><span class="n">ConfigurationException</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">recording_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: list(str)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">rate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_recording</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">recorded_region_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: list(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">rate</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__region_ids</span><span class="p">[</span><span class="n">variable</span><span class="p">])</span>
        <span class="c1"># Per timestep regions come after normal regions</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_recording</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__region_ids</span><span class="p">[</span><span class="n">variable</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">_is_recording</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str variable:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Per timestep variables are not recorded by slice, so True if present</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_recording</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="NeuronRecorder.recorded_ids_by_slice"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.recorded_ids_by_slice">[docs]</a>    <span class="k">def</span> <span class="nf">recorded_ids_by_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :rtype: list(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__region_ids</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_recording</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">)]</span>
        <span class="c1"># per-timestep variables are always defined, but the region is declared</span>
        <span class="c1"># after the other variables</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__region_ids</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_recording</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">variables</span></div>

    <span class="k">def</span> <span class="nf">_compute_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert a sampling interval into a rate. \</span>
<span class="sd">            Remember, machine time step is in nanoseconds</span>

<span class="sd">        :param int sampling_interval: interval between samples in microseconds</span>
<span class="sd">        :return: rate</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sampling_interval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="n">step</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">globals_variables</span><span class="o">.</span><span class="n">get_simulator</span><span class="p">()</span><span class="o">.</span><span class="n">machine_time_step</span> <span class="o">/</span>
            <span class="n">MICRO_TO_MILLISECOND_CONVERSION</span><span class="p">)</span>
        <span class="n">rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sampling_interval</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sampling_interval</span> <span class="o">!=</span> <span class="n">rate</span> <span class="o">*</span> <span class="n">step</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;sampling_interval </span><span class="si">{}</span><span class="s2"> is not an an integer multiple of the &quot;</span>\
                  <span class="s2">&quot;simulation timestep </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_interval</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAX_RATE</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;sampling_interval </span><span class="si">{}</span><span class="s2"> higher than max allowed which is </span><span class="si">{}</span><span class="s2">&quot;</span> \
                  <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampling_interval</span><span class="p">,</span> <span class="n">step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAX_RATE</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rate</span>

<div class="viewcode-block" id="NeuronRecorder.check_indexes"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.check_indexes">[docs]</a>    <span class="k">def</span> <span class="nf">check_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param list(int) indexes:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span><span class="s2">&quot;Empty indexes list&quot;</span><span class="p">)</span>

        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">warning</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span>
                    <span class="s2">&quot;Negative indexes are not supported&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_neurons</span><span class="p">:</span>
                <span class="n">warning</span> <span class="o">=</span> <span class="s2">&quot;Ignoring indexes greater than population size.&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">warning</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">warning</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span>
                <span class="s2">&quot;All indexes larger than population size&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__check_per_timestep_params</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="p">,</span> <span class="n">indexes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check if certain parameters have been provided for a per-timestep</span>
<span class="sd">            variable and if so, raise an Exception</span>

<span class="sd">        :param str variable:</span>
<span class="sd">        :param int sampling_interval:</span>
<span class="sd">        :param iterable(int) indexes:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sampling_interval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Variable </span><span class="si">{}</span><span class="s2"> does not support a sampling interval&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">variable</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Variable </span><span class="si">{}</span><span class="s2"> can only be recorded on the whole population&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">variable</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_turn_off_recording</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="p">,</span> <span class="n">remove_indexes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str variable:</span>
<span class="sd">        :param int sampling_interval:</span>
<span class="sd">        :param iterable(int) remove_indexes:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If a per-timestep variable, remove it and return</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_recording</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_recording</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Already off so ignore other parameters</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">remove_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># turning all off so ignoring sampling interval</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="c1"># No good reason to specify_interval when turning off</span>
        <span class="k">if</span> <span class="n">sampling_interval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_rate</span><span class="p">(</span><span class="n">sampling_interval</span><span class="p">)</span>
            <span class="c1"># But if they do make sure it is the same as before</span>
            <span class="k">if</span> <span class="n">rate</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span>
                    <span class="s2">&quot;Illegal sampling_interval parameter while turning &quot;</span>
                    <span class="s2">&quot;off recording&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># start with all indexes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_neurons</span><span class="p">)</span>

        <span class="c1"># remove the indexes not recording</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_indexes</span><span class="p">]</span>

        <span class="c1"># Check is at least one index still recording</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_check_complete_overwrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">indexes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str variable:</span>
<span class="sd">        :param iterable(int) indexes:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># overwriting all OK!</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_neurons</span><span class="p">))</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indexes</span><span class="p">)):</span>
                <span class="c1"># overwriting all previous so OK!</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indexes</span><span class="p">)):</span>
                <span class="c1"># overwriting all previous so OK!</span>
                <span class="k">return</span>
        <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span>
            <span class="s2">&quot;Current implementation does not support multiple &quot;</span>
            <span class="s2">&quot;sampling_intervals for </span><span class="si">{}</span><span class="s2"> on one population.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_turn_on_recording</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="p">,</span> <span class="n">indexes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str variable:</span>
<span class="sd">        :param int sampling_interval:</span>
<span class="sd">        :param iterable(int) indexes:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If a per-timestep variable, update</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__check_per_timestep_params</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_recording</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_rate</span><span class="p">(</span><span class="n">sampling_interval</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Previously not recording so OK</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">rate</span>
        <span class="k">elif</span> <span class="n">rate</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_complete_overwrite</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>
        <span class="c1"># else rate not changed so no action</span>

        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># previous recording indexes does not matter as now all (None)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># make sure indexes is not a generator like range</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_indexes</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># merge the two indexes</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">+</span> <span class="n">indexes</span>
            <span class="c1"># Avoid duplicates and keep in numerical order</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indexes</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

<div class="viewcode-block" id="NeuronRecorder.set_recording"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.set_recording">[docs]</a>    <span class="k">def</span> <span class="nf">set_recording</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">new_state</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str variable: PyNN variable name</span>
<span class="sd">        :param bool new_state:</span>
<span class="sd">        :param int sampling_interval:</span>
<span class="sd">        :param iterable(int) indexes:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_recording</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">new_state</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">:</span>
                <span class="c1"># Skip the unsupported items for a per-timestep variable</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_recording</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">new_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span> <span class="ow">or</span>
                <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">new_state</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_turn_on_recording</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_turn_off_recording</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span><span class="s2">&quot;Variable </span><span class="si">{}</span><span class="s2"> is not supported&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_get_buffered_sdram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">n_machine_time_steps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~pacman.model.graphs.commmon.Slice vertex_slice:</span>
<span class="sd">        :param int n_machine_time_steps:</span>
<span class="sd">        :rtype: list(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">):</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_buffered_sdram</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">n_machine_time_steps</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">values</span>

<div class="viewcode-block" id="NeuronRecorder.write_neuron_recording_region"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.write_neuron_recording_region">[docs]</a>    <span class="k">def</span> <span class="nf">write_neuron_recording_region</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">neuron_recording_region</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span>
            <span class="n">data_n_time_steps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; recording data specification</span>

<span class="sd">        :param ~data_specification.DataSpecificationGenerator spec: dsg spec</span>
<span class="sd">        :param int neuron_recording_region: the recording region</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">            the vertex slice</span>
<span class="sd">        :param int data_n_time_steps: how many time steps to run this time</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="n">neuron_recording_region</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">get_recording_header_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_buffered_sdram</span><span class="p">(</span><span class="n">vertex_slice</span><span class="p">,</span> <span class="n">data_n_time_steps</span><span class="p">)))</span>

        <span class="c1"># Write the number of variables and bitfields (ignore per-timestep)</span>
        <span class="n">n_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bitfield_variables</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">n_vars</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bitfield_variables</span><span class="p">))</span>

        <span class="c1"># Write the recording data</span>
        <span class="n">recording_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">(</span><span class="n">vertex_slice</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">recording_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="NeuronRecorder.get_buffered_sdram_per_record"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.get_buffered_sdram_per_record">[docs]</a>    <span class="k">def</span> <span class="nf">get_buffered_sdram_per_record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the SDRAM used per record</span>

<span class="sd">        :param str variable: PyNN variable name</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :return:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_recording</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_datatypes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_FOR_TIMESTAMP</span> <span class="o">+</span> <span class="n">size</span>
        <span class="n">n_neurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_recording_per_slice</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_neurons</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bitfield_variables</span><span class="p">:</span>
            <span class="c1"># Overflow can be ignored as it is not save if in an extra word</span>
            <span class="n">out_spike_words</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_neurons</span> <span class="o">/</span> <span class="n">BITS_PER_WORD</span><span class="p">))</span>
            <span class="n">out_spike_bytes</span> <span class="o">=</span> <span class="n">out_spike_words</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_FOR_TIMESTAMP</span> <span class="o">+</span> <span class="n">out_spike_bytes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__data_types</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_FOR_TIMESTAMP</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_neurons</span> <span class="o">*</span> <span class="n">size</span><span class="p">)</span></div>

<div class="viewcode-block" id="NeuronRecorder.get_buffered_sdram_per_timestep"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.get_buffered_sdram_per_timestep">[docs]</a>    <span class="k">def</span> <span class="nf">get_buffered_sdram_per_timestep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the SDRAM used per timestep.</span>

<span class="sd">        In the case where sampling is used it returns the average\</span>
<span class="sd">        for recording and none recording based on the recording rate</span>

<span class="sd">        :param str variable: PyNN variable name</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :return:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_recording</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="n">data_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_buffered_sdram_per_record</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rate</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data_size</span> <span class="o">//</span> <span class="n">rate</span></div>

<div class="viewcode-block" id="NeuronRecorder.get_sampling_overflow_sdram"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.get_sampling_overflow_sdram">[docs]</a>    <span class="k">def</span> <span class="nf">get_sampling_overflow_sdram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the extra SDRAM that should be reserved if using per_timestep</span>

<span class="sd">        This is the extra that must be reserved if per_timestep is an average\</span>
<span class="sd">        rather than fixed for every timestep.</span>

<span class="sd">        When sampling the average * time_steps may not be quite enough.\</span>
<span class="sd">        This returns the extra space in the worst case\</span>
<span class="sd">        where time_steps is a multiple of sampling rate + 1,\</span>
<span class="sd">        and recording is done in the first and last time_step</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :return: Highest possible overflow needed</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># No need to consider per-timestep variables here as they won&#39;t</span>
        <span class="c1"># overflow</span>
        <span class="n">overflow</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">rate</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">):</span>
            <span class="c1"># If rate is 0 no recording so no overflow</span>
            <span class="c1"># If rate is 1 there is no overflow as average is exact</span>
            <span class="k">if</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">data_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_buffered_sdram_per_record</span><span class="p">(</span>
                    <span class="n">variable</span><span class="p">,</span>  <span class="n">vertex_slice</span><span class="p">)</span>
                <span class="n">overflow</span> <span class="o">+=</span> <span class="n">data_size</span> <span class="o">//</span> <span class="n">rate</span> <span class="o">*</span> <span class="p">(</span><span class="n">rate</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">overflow</span></div>

<div class="viewcode-block" id="NeuronRecorder.get_buffered_sdram"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.get_buffered_sdram">[docs]</a>    <span class="k">def</span> <span class="nf">get_buffered_sdram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">n_machine_time_steps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the SDRAM used for this may time steps</span>

<span class="sd">        If required the total is rounded up so the space will always fit</span>

<span class="sd">        :param str variable: The PyNN variable name to get buffered sdram of</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :param int n_machine_time_steps:</span>
<span class="sd">            how many machine time steps to run for</span>
<span class="sd">        :return: data size</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Per timestep variables can&#39;t be done at a specific rate</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_variables</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_buffered_sdram_per_record</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">item</span> <span class="o">*</span> <span class="n">n_machine_time_steps</span>

        <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">data_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_buffered_sdram_per_record</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">)</span>
        <span class="n">records</span> <span class="o">=</span> <span class="n">n_machine_time_steps</span> <span class="o">//</span> <span class="n">rate</span>
        <span class="k">if</span> <span class="n">n_machine_time_steps</span> <span class="o">%</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">records</span> <span class="o">=</span> <span class="n">records</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">data_size</span> <span class="o">*</span> <span class="n">records</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__n_bytes_to_n_words</span><span class="p">(</span><span class="n">n_bytes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int n_bytes:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">n_bytes</span> <span class="o">+</span> <span class="p">(</span><span class="n">BYTES_PER_WORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="n">BYTES_PER_WORD</span>

<div class="viewcode-block" id="NeuronRecorder.get_sdram_usage_in_bytes"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.get_sdram_usage_in_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">get_sdram_usage_in_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This calculates the size of the metadata only; thus no reference to</span>
        <span class="c1"># per-timestep variables which have no metadata</span>
        <span class="n">n_words_for_n_neurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_bytes_to_n_words</span><span class="p">(</span><span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
        <span class="n">n_bytes_for_n_neurons</span> <span class="o">=</span> <span class="n">n_words_for_n_neurons</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
        <span class="n">var_bytes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_PER_RATE</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_PER_SIZE</span> <span class="o">+</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_PER_ENUM</span> <span class="o">+</span> <span class="n">n_bytes_for_n_neurons</span><span class="p">)</span> <span class="o">*</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bitfield_variables</span><span class="p">)))</span>
        <span class="n">bitfield_bytes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_PER_RATE</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_PER_SIZE</span> <span class="o">+</span>
             <span class="n">n_bytes_for_n_neurons</span><span class="p">)</span> <span class="o">*</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bitfield_variables</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_N_ITEM_TYPES</span> <span class="o">*</span> <span class="n">DataType</span><span class="o">.</span><span class="n">UINT32</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="n">var_bytes</span> <span class="o">+</span>
                <span class="n">bitfield_bytes</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_fixed_sdram_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fixed_sdram</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Recording rate for each neuron</span>
        <span class="n">fixed_sdram</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_PER_RATE</span>
        <span class="c1"># Number of recording neurons</span>
        <span class="n">fixed_sdram</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_PER_INDEX</span>
        <span class="c1"># index_parameters one per neuron</span>
        <span class="c1"># even if not recording as also act as a gate</span>
        <span class="n">fixed_sdram</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_PER_INDEX</span> <span class="o">*</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span>
        <span class="k">return</span> <span class="n">fixed_sdram</span>

<div class="viewcode-block" id="NeuronRecorder.get_static_sdram_usage"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.get_static_sdram_usage">[docs]</a>    <span class="k">def</span> <span class="nf">get_static_sdram_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_record</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">)</span>
        <span class="n">sdram</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">get_recording_header_size</span><span class="p">(</span><span class="n">n_record</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">get_recording_data_constant_size</span><span class="p">(</span><span class="n">n_record</span><span class="p">)</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_sdram_usage_in_bytes</span><span class="p">(</span><span class="n">vertex_slice</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">sdram</span><span class="p">)</span></div>

<div class="viewcode-block" id="NeuronRecorder.get_variable_sdram_usage"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.get_variable_sdram_usage">[docs]</a>    <span class="k">def</span> <span class="nf">get_variable_sdram_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :rtype: ~pacman.model.resources.VariableSDRAM</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fixed_sdram</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">per_timestep_sdram</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">:</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
            <span class="n">fixed_sdram</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fixed_sdram_usage</span><span class="p">(</span><span class="n">vertex_slice</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fixed_sdram</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SARK_BLOCK_SIZE</span>
                <span class="n">per_record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_buffered_sdram_per_record</span><span class="p">(</span>
                    <span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rate</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Add size for one record as recording every timestep</span>
                    <span class="n">per_timestep_sdram</span> <span class="o">+=</span> <span class="n">per_record</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Get the average cost per timestep</span>
                    <span class="n">average_per_timestep</span> <span class="o">=</span> <span class="n">per_record</span> <span class="o">/</span> <span class="n">rate</span>
                    <span class="n">per_timestep_sdram</span> <span class="o">+=</span> <span class="n">average_per_timestep</span>
                    <span class="c1"># Add the rest once to fixed for worst case</span>
                    <span class="n">fixed_sdram</span> <span class="o">+=</span> <span class="p">(</span><span class="n">per_record</span> <span class="o">-</span> <span class="n">average_per_timestep</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__per_timestep_recording</span><span class="p">:</span>
            <span class="n">per_timestep_sdram</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_buffered_sdram_per_record</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">VariableSDRAM</span><span class="p">(</span><span class="n">fixed_sdram</span><span class="p">,</span> <span class="n">per_timestep_sdram</span><span class="p">)</span></div>

<div class="viewcode-block" id="NeuronRecorder.get_dtcm_usage_in_bytes"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.get_dtcm_usage_in_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">get_dtcm_usage_in_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: Per-timestep variables uses no DTCM</span>
        <span class="c1"># *_rate + n_neurons_recording_* + *_indexes</span>
        <span class="n">usage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sdram_usage_in_bytes</span><span class="p">(</span><span class="n">vertex_slice</span><span class="p">)</span>

        <span class="c1"># *_count + *_increment</span>
        <span class="n">usage</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_PER_POINTER</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_PER_COUNT</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_PER_INCREMENT</span><span class="p">))</span>

        <span class="c1"># out_spikes, *_values</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bitfield_variables</span><span class="p">:</span>
                <span class="n">out_spike_words</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">/</span> <span class="n">BITS_PER_WORD</span><span class="p">))</span>
                <span class="n">out_spike_bytes</span> <span class="o">=</span> <span class="n">out_spike_words</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
                <span class="n">usage</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_FOR_TIMESTAMP</span> <span class="o">+</span> <span class="n">out_spike_bytes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__data_types</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                <span class="n">usage</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_FOR_TIMESTAMP</span> <span class="o">+</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">*</span> <span class="n">size</span><span class="p">)</span>

        <span class="c1"># *_size</span>
        <span class="n">usage</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_PER_SIZE</span>

        <span class="c1"># n_recordings_outstanding</span>
        <span class="n">usage</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_BYTES_PER_OUTSTANDING_RECORDING</span>
        <span class="k">return</span> <span class="n">usage</span></div>

<div class="viewcode-block" id="NeuronRecorder.get_n_cpu_cycles"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.common.html#spynnaker.pyNN.models.common.NeuronRecorder.get_n_cpu_cycles">[docs]</a>    <span class="k">def</span> <span class="nf">get_n_cpu_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int n_neurons:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">n_neurons</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_CPU_CYCLES_PER_NEURON</span> <span class="o">*</span> \
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recording_variables</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__add_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">n_recording</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param list(~numpy.ndarray) data:</span>
<span class="sd">        :param str variable:</span>
<span class="sd">        :param int rate:</span>
<span class="sd">        :param int n_recording:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_words_for_n_neurons</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
            <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">/</span> <span class="n">BYTES_PER_WORD</span><span class="p">))</span>
        <span class="n">n_bytes_for_n_neurons</span> <span class="o">=</span> <span class="n">n_words_for_n_neurons</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
        <span class="k">if</span> <span class="n">rate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_words_for_n_neurons</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint32&quot;</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="n">n_bytes_for_n_neurons</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;uint32&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
            <span class="n">local_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">local_indexes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">n_bytes_for_n_neurons</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">+</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                    <span class="n">local_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">local_index</span><span class="p">)</span>
                    <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># write to one beyond recording range</span>
                    <span class="n">local_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_recording</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">local_indexes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;uint32&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :rtype: ~numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># There is no data here for per-timestep variables by design</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">:</span>
            <span class="c1"># Do bitfields afterwards</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bitfield_variables</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
            <span class="n">n_recording</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_recording_per_slice</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">)</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__data_types</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">rate</span><span class="p">,</span> <span class="n">n_recording</span><span class="p">,</span> <span class="n">dtype</span><span class="o">.</span><span class="n">size</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint32&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__add_indices</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">n_recording</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bitfield_variables</span><span class="p">:</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sampling_rates</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
            <span class="n">n_recording</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_recording_per_slice</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rate</span><span class="p">,</span> <span class="n">n_recording</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint32&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__add_indices</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">n_recording</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># for testing only</span>
        <span class="k">return</span> <span class="n">_ReadOnlyDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__indexes</span><span class="p">)</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">sPyNNaker  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spynnaker.pyNN.models.common.neuron_recorder</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-2017.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>
  </body>
</html>