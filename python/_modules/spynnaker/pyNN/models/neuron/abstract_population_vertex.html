
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>spynnaker.pyNN.models.neuron.abstract_population_vertex &#8212; sPyNNaker 6.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/sphinxdoc.css" />
    <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../_static/doctools.js"></script>
    <script src="../../../../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">sPyNNaker 6.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../pyNN.html" accesskey="U">spynnaker.pyNN</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spynnaker.pyNN.models.neuron.abstract_population_vertex</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for spynnaker.pyNN.models.neuron.abstract_population_vertex</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2017-2019 The University of Manchester</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">special</span>  <span class="c1"># @UnresolvedImport</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">pyNN.space</span> <span class="kn">import</span> <span class="n">Grid2D</span><span class="p">,</span> <span class="n">Grid3D</span>

<span class="kn">from</span> <span class="nn">spinn_utilities.log</span> <span class="kn">import</span> <span class="n">FormatAdapter</span>
<span class="kn">from</span> <span class="nn">spinn_utilities.overrides</span> <span class="kn">import</span> <span class="n">overrides</span>
<span class="kn">from</span> <span class="nn">spinn_utilities.progress_bar</span> <span class="kn">import</span> <span class="n">ProgressBar</span>
<span class="kn">from</span> <span class="nn">spinn_utilities.ranged</span> <span class="kn">import</span> <span class="n">RangeDictionary</span>
<span class="kn">from</span> <span class="nn">data_specification.enums.data_type</span> <span class="kn">import</span> <span class="n">DataType</span>
<span class="kn">from</span> <span class="nn">spinn_utilities.config_holder</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_config_int</span><span class="p">,</span> <span class="n">get_config_float</span><span class="p">,</span> <span class="n">get_config_bool</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pacman.model.resources</span> <span class="kn">import</span> <span class="n">MultiRegionSDRAM</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.abstract_models</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AbstractCanReset</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BYTES_PER_WORD</span><span class="p">,</span> <span class="n">SYSTEM_BYTES_REQUIREMENT</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.interface.profiling.profile_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_profile_region_size</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.interface.buffer_management</span>\
    <span class="o">.</span><span class="n">recording_utilities</span> <span class="kn">import</span> <span class="p">(</span>
       <span class="n">get_recording_header_size</span><span class="p">,</span> <span class="n">get_recording_data_constant_size</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.interface.provenance</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ProvidesProvenanceDataFromMachineImpl</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.data</span> <span class="kn">import</span> <span class="n">SpynnakerDataView</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.common</span> <span class="kn">import</span> <span class="n">NeuronRecorder</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.abstract_models</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AbstractAcceptsIncomingSynapses</span><span class="p">,</span> <span class="n">AbstractMaxSpikes</span><span class="p">,</span> <span class="n">HasSynapses</span><span class="p">,</span>
    <span class="n">SupportsStructure</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">POSSION_SIGMA_SUMMATION_LIMIT</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.running_stats</span> <span class="kn">import</span> <span class="n">RunningStats</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neuron.synapse_dynamics</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AbstractSDRAMSynapseDynamics</span><span class="p">,</span> <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">,</span>
    <span class="n">AbstractSupportsSignedWeights</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neuron.local_only</span> <span class="kn">import</span> <span class="n">AbstractLocalOnly</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neuron.synapse_dynamics</span> <span class="kn">import</span> <span class="n">SynapseDynamicsStatic</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.utility_calls</span> <span class="kn">import</span> <span class="n">create_mars_kiss_seeds</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.bit_field_utilities</span> <span class="kn">import</span> <span class="n">get_sdram_for_keys</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.struct</span> <span class="kn">import</span> <span class="n">StructRepeat</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ParameterHolder</span><span class="p">,</span> <span class="n">PopulationApplicationVertex</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.common.param_generator_data</span> <span class="kn">import</span> <span class="n">MAX_PARAMS_BYTES</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.exceptions</span> <span class="kn">import</span> <span class="n">SpynnakerException</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.spike_source</span> <span class="kn">import</span> <span class="n">SpikeSourcePoissonVertex</span>

<span class="kn">from</span> <span class="nn">.population_machine_neurons</span> <span class="kn">import</span> <span class="n">PopulationMachineNeurons</span>
<span class="kn">from</span> <span class="nn">.synapse_io</span> <span class="kn">import</span> <span class="n">get_max_row_info</span>
<span class="kn">from</span> <span class="nn">.master_pop_table</span> <span class="kn">import</span> <span class="n">MasterPopTableAsBinarySearch</span>
<span class="kn">from</span> <span class="nn">.generator_data</span> <span class="kn">import</span> <span class="n">GeneratorData</span>
<span class="kn">from</span> <span class="nn">.synaptic_matrices</span> <span class="kn">import</span> <span class="n">SYNAPSES_BASE_GENERATOR_SDRAM_USAGE_IN_BYTES</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">FormatAdapter</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">))</span>

<span class="c1"># TODO: Make sure these values are correct (particularly CPU cycles)</span>
<span class="n">_NEURON_BASE_DTCM_USAGE_IN_BYTES</span> <span class="o">=</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
<span class="n">_NEURON_BASE_N_CPU_CYCLES_PER_NEURON</span> <span class="o">=</span> <span class="mi">22</span>
<span class="n">_NEURON_BASE_N_CPU_CYCLES</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">_NEURON_GENERATOR_BASE_SDRAM</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
<span class="n">_NEURON_GENERATOR_PER_STRUCT</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
<span class="n">_NEURON_GENERATOR_PER_PARAM</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
<span class="n">_NEURON_GENERATOR_PER_ITEM</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">)</span> <span class="o">+</span> <span class="n">MAX_PARAMS_BYTES</span>

<span class="c1"># 1 for number of neurons</span>
<span class="c1"># 1 for number of synapse types</span>
<span class="c1"># 1 for number of neuron bits</span>
<span class="c1"># 1 for number of synapse type bits</span>
<span class="c1"># 1 for number of delay bits</span>
<span class="c1"># 1 for drop late packets,</span>
<span class="c1"># 1 for incoming spike buffer size</span>
<span class="n">_SYNAPSES_BASE_SDRAM_USAGE_IN_BYTES</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>

<span class="n">_EXTRA_RECORDABLE_UNITS</span> <span class="o">=</span> <span class="p">{</span><span class="n">NeuronRecorder</span><span class="o">.</span><span class="n">SPIKES</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                           <span class="n">NeuronRecorder</span><span class="o">.</span><span class="n">PACKETS</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                           <span class="n">NeuronRecorder</span><span class="o">.</span><span class="n">REWIRING</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">_prod</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Finds the product of the iterable</span>

<span class="sd">    :param iterable iterable: Things to multiply together</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AbstractPopulationVertex</span><span class="p">(</span>
        <span class="n">PopulationApplicationVertex</span><span class="p">,</span> <span class="n">AbstractAcceptsIncomingSynapses</span><span class="p">,</span>
        <span class="n">AbstractCanReset</span><span class="p">,</span> <span class="n">SupportsStructure</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Underlying vertex model for Neural Populations.\</span>
<span class="sd">        Not actually abstract.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;__incoming_spike_buffer_size&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__n_atoms&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__n_profile_samples&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__neuron_impl&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__neuron_recorder&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__synapse_recorder&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__parameters&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__pynn_model&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__state_variables&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__initial_state_variables&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__updated_state_variables&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__ring_buffer_sigma&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__spikes_per_second&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__drop_late_spikes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__incoming_projections&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__incoming_poisson_projections&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__synapse_dynamics&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__max_row_info&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__self_projection&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__current_sources&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__current_source_id_list&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__structure&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__rng&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__pop_seed&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__core_seeds&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__connection_cache&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__read_initial_values&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__have_read_initial_values&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__last_parameter_read_time&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__n_colour_bits&quot;</span><span class="p">]</span>

    <span class="c1">#: recording region IDs</span>
    <span class="n">_SPIKE_RECORDING_REGION</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">#: the size of the runtime SDP port data region</span>
    <span class="n">_RUNTIME_SDP_PORT_SIZE</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span>

    <span class="c1">#: The Buffer traffic type</span>
    <span class="n">_TRAFFIC_IDENTIFIER</span> <span class="o">=</span> <span class="s2">&quot;BufferTraffic&quot;</span>

    <span class="n">_C_MAIN_BASE_N_CPU_CYCLES</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">_NEURON_BASE_N_CPU_CYCLES_PER_NEURON</span> <span class="o">=</span> <span class="mi">22</span>
    <span class="n">_NEURON_BASE_N_CPU_CYCLES</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">_SYNAPSE_BASE_N_CPU_CYCLES_PER_NEURON</span> <span class="o">=</span> <span class="mi">22</span>
    <span class="n">_SYNAPSE_BASE_N_CPU_CYCLES</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="c1"># Elements before the start of global parameters</span>
    <span class="c1"># 1. has key, 2. key, 3. n atoms, 4. n_atoms_peak 5. n_colour_bits</span>
    <span class="n">CORE_PARAMS_BASE_SIZE</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">max_atoms_per_core</span><span class="p">,</span>
            <span class="n">spikes_per_second</span><span class="p">,</span> <span class="n">ring_buffer_sigma</span><span class="p">,</span> <span class="n">incoming_spike_buffer_size</span><span class="p">,</span>
            <span class="n">neuron_impl</span><span class="p">,</span> <span class="n">pynn_model</span><span class="p">,</span> <span class="n">drop_late_spikes</span><span class="p">,</span> <span class="n">splitter</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span>
            <span class="n">n_colour_bits</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int n_neurons: The number of neurons in the population</span>
<span class="sd">        :param str label: The label on the population</span>
<span class="sd">        :param int max_atoms_per_core:</span>
<span class="sd">            The maximum number of atoms (neurons) per SpiNNaker core.</span>
<span class="sd">        :param spikes_per_second: Expected spike rate</span>
<span class="sd">        :type spikes_per_second: float or None</span>
<span class="sd">        :param ring_buffer_sigma:</span>
<span class="sd">            How many SD above the mean to go for upper bound of ring buffer</span>
<span class="sd">            size; a good starting choice is 5.0. Given length of simulation</span>
<span class="sd">            we can set this for approximate number of saturation events.</span>
<span class="sd">        :type ring_buffer_sigma: float or None</span>
<span class="sd">        :param incoming_spike_buffer_size:</span>
<span class="sd">        :type incoming_spike_buffer_size: int or None</span>
<span class="sd">        :param bool drop_late_spikes: control flag for dropping late packets.</span>
<span class="sd">        :param AbstractNeuronImpl neuron_impl:</span>
<span class="sd">            The (Python side of the) implementation of the neurons themselves.</span>
<span class="sd">        :param AbstractPyNNNeuronModel pynn_model:</span>
<span class="sd">            The PyNN neuron model that this vertex is working on behalf of.</span>
<span class="sd">        :param splitter: splitter object</span>
<span class="sd">        :type splitter: None or</span>
<span class="sd">            ~pacman.model.partitioner_splitters.abstract_splitters.AbstractSplitterCommon</span>
<span class="sd">        :param seed:</span>
<span class="sd">            The Population seed, used to ensure the same random generation</span>
<span class="sd">            on each run.</span>
<span class="sd">        :param int n_colour_bits: The number of colour bits to use</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># pylint: disable=too-many-arguments</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">max_atoms_per_core</span><span class="p">,</span> <span class="n">splitter</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__n_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_n_atoms</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">,</span> <span class="s2">&quot;n_neurons&quot;</span><span class="p">)</span>

        <span class="c1"># buffer data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_spike_buffer_size</span> <span class="o">=</span> <span class="n">incoming_spike_buffer_size</span>

        <span class="k">if</span> <span class="n">incoming_spike_buffer_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_spike_buffer_size</span> <span class="o">=</span> <span class="n">get_config_int</span><span class="p">(</span>
                <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;incoming_spike_buffer_size&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="o">=</span> <span class="n">ring_buffer_sigma</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="o">=</span> <span class="n">get_config_float</span><span class="p">(</span>
                <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;ring_buffer_sigma&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">=</span> <span class="n">spikes_per_second</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">=</span> <span class="n">get_config_float</span><span class="p">(</span>
                <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;spikes_per_second&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span> <span class="o">=</span> <span class="n">drop_late_spikes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span> <span class="o">=</span> <span class="n">get_config_bool</span><span class="p">(</span>
                <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;drop_late_spikes&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span> <span class="o">=</span> <span class="n">neuron_impl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__pynn_model</span> <span class="o">=</span> <span class="n">pynn_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__parameters</span> <span class="o">=</span> <span class="n">RangeDictionary</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">add_parameters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__parameters</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__initial_state_variables</span> <span class="o">=</span> <span class="n">RangeDictionary</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">add_state_variables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__initial_state_variables</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__state_variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initial_state_variables</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__n_colour_bits</span> <span class="o">=</span> <span class="n">n_colour_bits</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_colour_bits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__n_colour_bits</span> <span class="o">=</span> <span class="n">get_config_int</span><span class="p">(</span>
                <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;n_colour_bits&quot;</span><span class="p">)</span>

        <span class="c1"># Set up for recording</span>
        <span class="n">neuron_recordable_variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">get_recordable_variables</span><span class="p">())</span>
        <span class="n">record_data_types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">get_recordable_data_types</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span> <span class="o">=</span> <span class="n">NeuronRecorder</span><span class="p">(</span>
            <span class="n">neuron_recordable_variables</span><span class="p">,</span> <span class="n">record_data_types</span><span class="p">,</span>
            <span class="p">[</span><span class="n">NeuronRecorder</span><span class="o">.</span><span class="n">SPIKES</span><span class="p">],</span> <span class="n">n_neurons</span><span class="p">,</span> <span class="p">[],</span> <span class="p">{},</span> <span class="p">[],</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span> <span class="o">=</span> <span class="n">NeuronRecorder</span><span class="p">(</span>
            <span class="p">[],</span> <span class="p">{},</span> <span class="p">[],</span>
            <span class="n">n_neurons</span><span class="p">,</span> <span class="p">[</span><span class="n">NeuronRecorder</span><span class="o">.</span><span class="n">PACKETS</span><span class="p">],</span>
            <span class="p">{</span><span class="n">NeuronRecorder</span><span class="o">.</span><span class="n">PACKETS</span><span class="p">:</span> <span class="n">NeuronRecorder</span><span class="o">.</span><span class="n">PACKETS_TYPE</span><span class="p">},</span>
            <span class="p">[</span><span class="n">NeuronRecorder</span><span class="o">.</span><span class="n">REWIRING</span><span class="p">],</span>
            <span class="p">{</span><span class="n">NeuronRecorder</span><span class="o">.</span><span class="n">REWIRING</span><span class="p">:</span> <span class="n">NeuronRecorder</span><span class="o">.</span><span class="n">REWIRING_TYPE</span><span class="p">})</span>

        <span class="c1"># Current sources for this vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__current_sources</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__current_source_id_list</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Set up for profiling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__n_profile_samples</span> <span class="o">=</span> <span class="n">get_config_int</span><span class="p">(</span>
            <span class="s2">&quot;Reports&quot;</span><span class="p">,</span> <span class="s2">&quot;n_profile_samples&quot;</span><span class="p">)</span>

        <span class="c1"># Set up for incoming</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_projections</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_poisson_projections</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_row_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__self_projection</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Keep track of the synapse dynamics for the vertex overall</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="o">=</span> <span class="n">SynapseDynamicsStatic</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__structure</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># An RNG for use in synaptic generation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__rng</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__pop_seed</span> <span class="o">=</span> <span class="n">create_mars_kiss_seeds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__rng</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__core_seeds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Store connections read from machine until asked to clear</span>
        <span class="c1"># Key is app_edge, synapse_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__connection_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__read_initial_values</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__have_read_initial_values</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__last_parameter_read_time</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="AbstractPopulationVertex.get_max_atoms_per_core"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_max_atoms_per_core">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_max_atoms_per_core</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_max_atoms_per_core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">max_atoms</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_max_atoms_per_core</span><span class="p">()</span>

        <span class="c1"># Dynamically adjust depending on the needs of the synapse dynamics</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span>
            <span class="n">max_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">absolute_max_atoms_per_core</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_max_atoms_per_dimension_per_core"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_max_atoms_per_dimension_per_core">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span>
        <span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_max_atoms_per_dimension_per_core</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_max_atoms_per_dimension_per_core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">max_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_max_atoms_per_core</span><span class="p">()</span>

        <span class="c1"># If single dimensional, we can use the max atoms calculation</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">max_atoms</span><span class="p">,</span> <span class="p">)</span>

        <span class="c1"># If not, the user has to be more specific if the total number of</span>
        <span class="c1"># atoms is not small enough to fit on one core</span>
        <span class="n">max_per_dim</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_max_atoms_per_dimension_per_core</span><span class="p">()</span>

        <span class="n">total_max_atoms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">max_per_dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">&lt;</span> <span class="n">total_max_atoms</span><span class="p">:</span>
            <span class="n">total_max_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span>
        <span class="k">if</span> <span class="n">total_max_atoms</span> <span class="o">&gt;</span> <span class="n">max_atoms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SpynnakerException</span><span class="p">(</span>
                <span class="s2">&quot;When using a multidimensional Population, a maximum number of&quot;</span>
                <span class="s2">&quot; neurons per core for each dimension must be provided such&quot;</span>
                <span class="s2">&quot; that the total number of neurons per core is less than or&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; equal to </span><span class="si">{</span><span class="n">max_atoms</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_per_dim</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms_shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SpynnakerException</span><span class="p">(</span>
                <span class="s2">&quot;When using a multidimensional Population, a maximum number of&quot;</span>
                <span class="s2">&quot; neurons per core must be provided for each dimension (in&quot;</span>
                <span class="s2">&quot; this case, please set a max neurons per core with&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms_shape</span><span class="p">)</span><span class="si">}</span><span class="s2"> dimensions)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">max_per_dim</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.set_max_atoms_per_dimension_per_core"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.set_max_atoms_per_dimension_per_core">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span>
               <span class="n">set_max_atoms_per_dimension_per_core</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_max_atoms_per_dimension_per_core</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>
        <span class="n">max_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">absolute_max_atoms_per_core</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">new_value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_atoms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SpynnakerException</span><span class="p">(</span>
                <span class="s2">&quot;In the current configuration, the maximum number of&quot;</span>
                <span class="s2">&quot; neurons for each dimension must be such that the total&quot;</span>
                <span class="s2">&quot; number of neurons per core is less than or equal to&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">max_atoms</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_max_atoms_per_dimension_per_core</span><span class="p">(</span><span class="n">new_value</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.set_structure"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.set_structure">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">SupportsStructure</span><span class="o">.</span><span class="n">set_structure</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__structure</span> <span class="o">=</span> <span class="n">structure</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">combined_core_capable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Determine if the vertex can manage to operate on a combined</span>
<span class="sd">            neuron-synapse core, or if a split synapse-core is more</span>
<span class="sd">            appropriate.</span>

<span class="sd">            Note that this is currently based only on the ITCM available, not</span>
<span class="sd">            on the incoming synapses, but could be combined with</span>
<span class="sd">            n_synapse_cores_required to determine if, and how-many, synapse</span>
<span class="sd">            cores are needed.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">is_combined_core_capable</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapse_cores_required</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the estimated number of synapse cores required, when using a</span>
<span class="sd">            split synapse-neuron core model.</span>

<span class="sd">            Note this is currently hard-coded but could be updated to work</span>
<span class="sd">            this out based on the number of incoming synapses</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The synapse dynamics used by the synapses e.g. plastic or static.</span>
<span class="sd">            Settable.</span>

<span class="sd">        :rtype: AbstractSynapseDynamics or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span>

    <span class="nd">@synapse_dynamics</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">synapse_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synapse_dynamics</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Set the synapse dynamics.  Note that after setting, the dynamics</span>
<span class="sd">            might not be the type set as it can be combined with the existing</span>
<span class="sd">            dynamics in exciting ways.</span>

<span class="sd">        :param AbstractSynapseDynamics synapse_dynamics:</span>
<span class="sd">            The synapse dynamics to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">synapse_dynamics</span><span class="p">)</span>

<div class="viewcode-block" id="AbstractPopulationVertex.add_incoming_projection"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.add_incoming_projection">[docs]</a>    <span class="k">def</span> <span class="nf">add_incoming_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projection</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Add a projection incoming to this vertex</span>

<span class="sd">        :param PyNNProjectionCommon projection:</span>
<span class="sd">            The new projection to add</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reset the ring buffer shifts as a projection has been added</span>
        <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">set_requires_mapping</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_row_info</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">pre_vertex</span> <span class="o">=</span> <span class="n">projection</span><span class="o">.</span><span class="n">_projection_edge</span><span class="o">.</span><span class="n">pre_vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_projections</span><span class="p">[</span><span class="n">pre_vertex</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">projection</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pre_vertex</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__self_projection</span> <span class="o">=</span> <span class="n">projection</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pre_vertex</span><span class="p">,</span> <span class="n">SpikeSourcePoissonVertex</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_poisson_projections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">projection</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">self_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get any projection from this vertex to itself</span>

<span class="sd">        :rtype: PyNNProjectionCommon or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__self_projection</span>

    <span class="nd">@property</span>
    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">n_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_atoms</span>

    <span class="nd">@property</span>
    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">atoms_shape</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">atoms_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__structure</span><span class="p">,</span> <span class="p">(</span><span class="n">Grid2D</span><span class="p">,</span> <span class="n">Grid3D</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__structure</span><span class="o">.</span><span class="n">calculate_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AbstractPopulationVertex</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">atoms_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The number of neurons in the vertex</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_atoms</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">incoming_spike_buffer_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The size of the incoming spike buffer to be used on the cores</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_spike_buffer_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The parameters of the neurons in the population</span>

<span class="sd">        :rtype: RangeDictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parameters</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The state variables of the neuron in the population</span>

<span class="sd">        :rtype: RangeDicationary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__state_variables</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initial_state_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The initial values of the state variables of the neurons</span>

<span class="sd">        :rtype: RangeDictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initial_state_variables</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neuron_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The neuron implementation</span>

<span class="sd">        :rtype: AbstractNeuronImpl</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_profile_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The maximum number of profile samples to report</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_profile_samples</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neuron_recorder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The recorder for neurons</span>

<span class="sd">        :rtype: NeuronRecorder</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_recorder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The recorder for synapses</span>

<span class="sd">        :rtype: SynapseRecorder</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">drop_late_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Whether spikes should be dropped if not processed in a timestep</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span>

<div class="viewcode-block" id="AbstractPopulationVertex.get_sdram_usage_for_core_neuron_params"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_sdram_usage_for_core_neuron_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_sdram_usage_for_core_neuron_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CORE_PARAMS_BASE_SIZE</span> <span class="o">+</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">get_n_synapse_types</span><span class="p">()</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">)</span> <span class="o">+</span>
            <span class="c1"># The keys per neuron</span>
            <span class="n">n_atoms</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_sdram_usage_for_neuron_params"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_sdram_usage_for_neuron_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_sdram_usage_for_neuron_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Calculate the SDRAM usage for just the neuron parameters region.</span>

<span class="sd">        :param int n_atoms: The number of atoms per core</span>
<span class="sd">        :return: The SDRAM required for the neuron region</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">get_size_in_whole_words</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">)</span>
                   <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">repeat_type</span> <span class="o">==</span> <span class="n">StructRepeat</span><span class="o">.</span><span class="n">PER_NEURON</span>
                   <span class="k">else</span> <span class="n">s</span><span class="o">.</span><span class="n">get_size_in_whole_words</span><span class="p">()</span>
                   <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">structs</span><span class="p">)</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_sdram_usage_for_neuron_generation"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_sdram_usage_for_neuron_generation">[docs]</a>    <span class="k">def</span> <span class="nf">get_sdram_usage_for_neuron_generation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Calculate the SDRAM usage for the neuron generation region.</span>

<span class="sd">        :param int n_atoms: The number of atoms per core</span>
<span class="sd">        :return: The SDRAM required for the neuron generator region</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_sdram_usage_for_neuron_struct_generation</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">)</span> <span class="o">+</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">get_generator_sdram_usage_in_bytes</span><span class="p">(</span>
                    <span class="n">n_atoms</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__get_sdram_usage_for_neuron_struct_generation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Calculate the SDRAM usage for the neuron struct generation region.</span>

<span class="sd">        :param int n_atoms: The number of atoms per core</span>
<span class="sd">        :return: The SDRAM required for the neuron generator region</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Uses nothing if not generatable</span>
        <span class="n">structs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">structs</span>
        <span class="k">for</span> <span class="n">struct</span> <span class="ow">in</span> <span class="n">structs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">struct</span><span class="o">.</span><span class="n">is_generatable</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># If structs are generatable, we can guess that parameters are,</span>
        <span class="c1"># and then assume each parameter is different for maximum SDRAM.</span>
        <span class="n">n_structs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">structs</span><span class="p">)</span>
        <span class="n">n_params</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">structs</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span>
            <span class="n">_NEURON_GENERATOR_BASE_SDRAM</span><span class="p">,</span>
            <span class="n">_NEURON_GENERATOR_PER_STRUCT</span> <span class="o">*</span> <span class="n">n_structs</span><span class="p">,</span>
            <span class="n">_NEURON_GENERATOR_PER_PARAM</span> <span class="o">*</span> <span class="n">n_params</span><span class="p">,</span>
            <span class="n">_NEURON_GENERATOR_PER_ITEM</span> <span class="o">*</span> <span class="n">n_params</span> <span class="o">*</span> <span class="n">n_atoms</span>
        <span class="p">])</span>

<div class="viewcode-block" id="AbstractPopulationVertex.get_sdram_usage_for_current_source_params"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_sdram_usage_for_current_source_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_sdram_usage_for_current_source_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Calculate the SDRAM usage for the current source parameters region.</span>

<span class="sd">        :param int n_atoms: The number of atoms to account for</span>
<span class="sd">        :return: The SDRAM required for the current source region</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If non at all, just output size of 0 declaration</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__current_sources</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BYTES_PER_WORD</span>

        <span class="c1"># This is a worst-case count, assuming all sources apply to all atoms</span>
        <span class="c1"># Start with the count of sources + count of sources per neuron</span>
        <span class="n">sdram_usage</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_atoms</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">)</span>

        <span class="c1"># There is a number of each different type of current source</span>
        <span class="n">sdram_usage</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>

        <span class="c1"># Add on size of neuron id list per source (remember assume all atoms)</span>
        <span class="n">sdram_usage</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__current_sources</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_atoms</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">)</span>

        <span class="c1"># Add on the size of the current source data + neuron id list per</span>
        <span class="c1"># source (remember, assume all neurons for worst case)</span>
        <span class="k">for</span> <span class="n">current_source</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__current_sources</span><span class="p">:</span>
            <span class="n">sdram_usage</span> <span class="o">+=</span> <span class="n">current_source</span><span class="o">.</span><span class="n">get_sdram_usage_in_bytes</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">sdram_usage</span></div>

    <span class="k">def</span> <span class="nf">__read_parameters_now</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If we already read the parameters at this time, don&#39;t do it again</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">SpynnakerDataView</span><span class="p">()</span><span class="o">.</span><span class="n">get_current_run_time_ms</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__last_parameter_read_time</span> <span class="o">==</span> <span class="n">current_time</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__last_parameter_read_time</span> <span class="o">=</span> <span class="n">current_time</span>
        <span class="k">for</span> <span class="n">m_vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">machine_vertices</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m_vertex</span><span class="p">,</span> <span class="n">PopulationMachineNeurons</span><span class="p">):</span>
                <span class="n">placement</span> <span class="o">=</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span><span class="n">m_vertex</span><span class="p">)</span>
                <span class="n">m_vertex</span><span class="o">.</span><span class="n">read_parameters_from_machine</span><span class="p">(</span><span class="n">placement</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__read_initial_parameters_now</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If we already read the initial parameters, don&#39;t do it again</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__have_read_initial_values</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">m_vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">machine_vertices</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m_vertex</span><span class="p">,</span> <span class="n">PopulationMachineNeurons</span><span class="p">):</span>
                <span class="n">placement</span> <span class="o">=</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span><span class="n">m_vertex</span><span class="p">)</span>
                <span class="n">m_vertex</span><span class="o">.</span><span class="n">read_initial_parameters_from_machine</span><span class="p">(</span><span class="n">placement</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__read_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>

<div class="viewcode-block" id="AbstractPopulationVertex.get_parameter_values"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_parameter_values">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_parameter_values</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_parameter_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_parameters</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="c1"># If we haven&#39;t yet run, or have just reset, note to read the values</span>
        <span class="c1"># when they are ready</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">is_ran_last</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__read_initial_values</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">has_transceiver</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__read_parameters_now</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ParameterHolder</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__read_parameter</span><span class="p">,</span> <span class="n">selector</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.set_parameter_values"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.set_parameter_values">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">set_parameter_values</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_parameter_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># If we have run, and not reset, we need to read the values back</span>
        <span class="c1"># so that we don&#39;t overwrite the state.  Note that a reset will</span>
        <span class="c1"># then make this a waste, but we can&#39;t see the future...</span>
        <span class="k">if</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">is_ran_last</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__read_parameters_now</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__tell_neuron_vertices_to_regenerate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">set_value_by_selector</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_parameters"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_parameters">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_parameters</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pynn_model</span><span class="o">.</span><span class="n">default_parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__read_initial_state_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initial_state_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>

<div class="viewcode-block" id="AbstractPopulationVertex.get_initial_state_values"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_initial_state_values">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_initial_state_values</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_initial_state_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_variables</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__state_variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="c1"># If we haven&#39;t yet run, or have just reset, note to read the values</span>
        <span class="c1"># when they are ready</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">is_ran_last</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__read_initial_values</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__read_initial_parameters_now</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ParameterHolder</span><span class="p">(</span>
            <span class="n">names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__read_initial_state_variable</span><span class="p">,</span> <span class="n">selector</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.set_initial_state_values"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.set_initial_state_values">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">set_initial_state_values</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_initial_state_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_variables</span><span class="p">([</span><span class="n">name</span><span class="p">],</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__state_variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">is_ran_last</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__state_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">set_value_by_selector</span><span class="p">(</span>
                <span class="n">selector</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__initial_state_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">set_value_by_selector</span><span class="p">(</span>
            <span class="n">selector</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__read_current_state_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__state_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>

<div class="viewcode-block" id="AbstractPopulationVertex.get_current_state_values"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_current_state_values">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_current_state_values</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_current_state_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_variables</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__state_variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="c1"># If we haven&#39;t yet run, or have just reset, note to read the values</span>
        <span class="c1"># when they are ready</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">is_ran_last</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__read_initial_values</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__read_parameters_now</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ParameterHolder</span><span class="p">(</span>
            <span class="n">names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__read_current_state_variable</span><span class="p">,</span> <span class="n">selector</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.set_current_state_values"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.set_current_state_values">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">set_current_state_values</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_current_state_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_variables</span><span class="p">([</span><span class="n">name</span><span class="p">],</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__state_variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="c1"># If we have run, and not reset, we need to read the values back</span>
        <span class="c1"># so that we don&#39;t overwrite all the state.  Note that a reset will</span>
        <span class="c1"># then make this a waste, but we can&#39;t see the future...</span>
        <span class="k">if</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">is_ran_last</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__read_parameters_now</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__tell_neuron_vertices_to_regenerate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__state_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">set_value_by_selector</span><span class="p">(</span>
            <span class="n">selector</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_state_variables"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_state_variables">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_state_variables</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_state_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pynn_model</span><span class="o">.</span><span class="n">default_initial_values</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_units"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_units">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_units</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_EXTRA_RECORDABLE_UNITS</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_EXTRA_RECORDABLE_UNITS</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">get_recordable_units</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parameters</span> <span class="ow">and</span>
                <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__state_variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No such parameter </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">get_units</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">conductance_based</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">conductance_based</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">is_conductance_based</span>

<div class="viewcode-block" id="AbstractPopulationVertex.get_recordable_variables"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_recordable_variables">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_recordable_variables</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_recordable_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">get_recordable_variables</span><span class="p">())</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">get_recordable_variables</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">variables</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.can_record"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.can_record">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">can_record</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">can_record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.set_recording"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.set_recording">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">set_recording</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_recording</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">set_recording</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">set_recording</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;It is not possible to record </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">set_requires_mapping</span><span class="p">()</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.set_not_recording"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.set_not_recording">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">set_not_recording</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_not_recording</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">set_recording</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">set_recording</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;It is not possible to record </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_recording_variables"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_recording_variables">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_recording_variables</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_recording_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">recording</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">recording</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">recording_variables</span><span class="p">)</span>
        <span class="n">recording</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">recording_variables</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">recording</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.is_recording_variable"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.is_recording_variable">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">is_recording_variable</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_recording_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">is_recording</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">is_recording</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_recorded_data"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_recorded_data">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_recorded_data</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_recorded_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">is_recording</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">get_recorded_data</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">is_recording</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">get_recorded_data</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is not a supported variable&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> has not been set to record&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_recording_sampling_interval"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_recording_sampling_interval">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_recording_sampling_interval</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_recording_sampling_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">get_sampling_interval</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">get_sampling_interval</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;It is not possible to record </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_recording_indices"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_recording_indices">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_recording_indices</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_recording_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">get_recorded_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">get_recorded_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;It is not possible to record </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_recording_type"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_recording_type">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">get_recording_type</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_recording_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">get_recorded_data_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">get_recorded_data_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;It is not possible to record </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.clear_recording_data"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.clear_recording_data">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">clear_recording_data</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">clear_recording_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">get_region</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">is_recordable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">get_region</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;It is not possible to record </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">buffer_manager</span> <span class="o">=</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_buffer_manager</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">machine_vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">machine_vertices</span><span class="p">:</span>
            <span class="n">placement</span> <span class="o">=</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span>
                <span class="n">machine_vertex</span><span class="p">)</span>
            <span class="n">buffer_manager</span><span class="o">.</span><span class="n">clear_recorded_data</span><span class="p">(</span>
                <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weight_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">get_global_weight_scale</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ring_buffer_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span>

    <span class="nd">@ring_buffer_sigma</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ring_buffer_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring_buffer_sigma</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="o">=</span> <span class="n">ring_buffer_sigma</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spikes_per_second</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span>

    <span class="nd">@spikes_per_second</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">spikes_per_second</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spikes_per_second</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">=</span> <span class="n">spikes_per_second</span>

<div class="viewcode-block" id="AbstractPopulationVertex.set_synapse_dynamics"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.set_synapse_dynamics">[docs]</a>    <span class="k">def</span> <span class="nf">set_synapse_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synapse_dynamics</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Set the synapse dynamics of this population</span>

<span class="sd">        :param AbstractSynapseDynamics synapse_dynamics:</span>
<span class="sd">            The synapse dynamics to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapse_dynamics</span> <span class="o">=</span> <span class="n">synapse_dynamics</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.clear_connection_cache"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.clear_connection_cache">[docs]</a>    <span class="k">def</span> <span class="nf">clear_connection_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Flush the cache of connection information; needed for a second run</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__connection_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.describe"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.describe">[docs]</a>    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get a human-readable description of the cell or synapse type.</span>

<span class="sd">        The output may be customised by specifying a different template</span>
<span class="sd">        together with an associated template engine</span>
<span class="sd">        (see :py:mod:`pyNN.descriptions`).</span>

<span class="sd">        If template is None, then a dictionary containing the template context</span>
<span class="sd">        will be returned.</span>

<span class="sd">        :rtype: dict(str, ...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_parameter_values</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__pynn_model</span><span class="o">.</span><span class="n">default_parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">model_name</span><span class="p">,</span>
            <span class="s2">&quot;default_parameters&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pynn_model</span><span class="o">.</span><span class="n">default_parameters</span><span class="p">,</span>
            <span class="s2">&quot;default_initial_values&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pynn_model</span><span class="o">.</span><span class="n">default_parameters</span><span class="p">,</span>
            <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="n">parameters</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">context</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_synapse_id_by_target"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_synapse_id_by_target">[docs]</a>    <span class="k">def</span> <span class="nf">get_synapse_id_by_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the id of synapse using its target name</span>

<span class="sd">        :param str target: The synapse to get the id of</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">get_synapse_id_by_target</span><span class="p">(</span><span class="n">target</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.inject"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.inject">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">inject</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">inject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_source</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__current_sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_source</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__current_source_id_list</span><span class="p">[</span><span class="n">current_source</span><span class="p">]</span> <span class="o">=</span> <span class="n">selector</span>
        <span class="c1"># set the associated vertex (for multi-run case)</span>
        <span class="n">current_source</span><span class="o">.</span><span class="n">set_app_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># set to reload for multi-run case</span>
        <span class="k">for</span> <span class="n">m_vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">machine_vertices</span><span class="p">:</span>
            <span class="n">m_vertex</span><span class="o">.</span><span class="n">set_reload_required</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Current sources need to be available to machine vertex</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__current_sources</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_source_id_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Current source ID list needs to be available to machine vertex</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__current_source_id_list</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> with </span><span class="si">{}</span><span class="s2"> atoms&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

<div class="viewcode-block" id="AbstractPopulationVertex.reset_to_first_timestep"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.reset_to_first_timestep">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">AbstractCanReset</span><span class="o">.</span><span class="n">reset_to_first_timestep</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reset_to_first_timestep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Reset state variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__state_variables</span><span class="o">.</span><span class="n">copy_into</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__initial_state_variables</span><span class="p">)</span>

        <span class="c1"># If synapses change during the run also regenerate these to get</span>
        <span class="c1"># back to the initial state</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">changes_during_run</span><span class="p">:</span>
            <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">set_requires_data_generation</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We only get neuron vertices to regenerate not redoing data</span>
            <span class="c1"># generation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__tell_neuron_vertices_to_regenerate</span><span class="p">()</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_ring_buffer_expected_upper_bound</span><span class="p">(</span>
            <span class="n">weight_mean</span><span class="p">,</span> <span class="n">weight_std_dev</span><span class="p">,</span> <span class="n">spikes_per_second</span><span class="p">,</span>
            <span class="n">n_synapses_in</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Provides expected upper bound on accumulated values in a ring\</span>
<span class="sd">            buffer element.</span>

<span class="sd">        Requires an assessment of maximum Poisson input rate.</span>

<span class="sd">        Assumes knowledge of mean and SD of weight distribution, fan-in\</span>
<span class="sd">        and timestep.</span>

<span class="sd">        All arguments should be assumed real values except n_synapses_in\</span>
<span class="sd">        which will be an integer.</span>

<span class="sd">        :param float weight_mean: Mean of weight distribution (in either nA or\</span>
<span class="sd">            microSiemens as required)</span>
<span class="sd">        :param float weight_std_dev: SD of weight distribution</span>
<span class="sd">        :param float spikes_per_second: Maximum expected Poisson rate in Hz</span>
<span class="sd">        :param int machine_timestep: in us</span>
<span class="sd">        :param int n_synapses_in: No of connected synapses</span>
<span class="sd">        :param float sigma: How many SD above the mean to go for upper bound;\</span>
<span class="sd">            a good starting choice is 5.0. Given length of simulation we can\</span>
<span class="sd">            set this for approximate number of saturation events.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># E[ number of spikes ] in a timestep</span>
        <span class="n">average_spikes_per_timestep</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="n">n_synapses_in</span> <span class="o">*</span> <span class="n">spikes_per_second</span><span class="p">)</span> <span class="o">/</span>
            <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_simulation_time_step_per_s</span><span class="p">())</span>

        <span class="c1"># Exact variance contribution from inherent Poisson variation</span>
        <span class="n">poisson_variance</span> <span class="o">=</span> <span class="n">average_spikes_per_timestep</span> <span class="o">*</span> <span class="p">(</span><span class="n">weight_mean</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Upper end of range for Poisson summation required below</span>
        <span class="c1"># upper_bound needs to be an integer</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span> <span class="o">+</span>
                                <span class="n">POSSION_SIGMA_SUMMATION_LIMIT</span> <span class="o">*</span>
                                <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)))</span>

        <span class="c1"># Closed-form exact solution for summation that gives the variance</span>
        <span class="c1"># contributed by weight distribution variation when modulated by</span>
        <span class="c1"># Poisson PDF.  Requires scipy.special for gamma and incomplete gamma</span>
        <span class="c1"># functions. Beware: incomplete gamma doesn&#39;t work the same as</span>
        <span class="c1"># Mathematica because (1) it&#39;s regularised and needs a further</span>
        <span class="c1"># multiplication and (2) it&#39;s actually the complement that is needed</span>
        <span class="c1"># i.e. &#39;gammaincc&#39;]</span>

        <span class="n">weight_variance</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="n">weight_std_dev</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># pylint: disable=no-member</span>
            <span class="n">lngamma</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">upper_bound</span><span class="p">)</span>
            <span class="n">gammai</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gammaincc</span><span class="p">(</span>
                <span class="mi">1</span> <span class="o">+</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">average_spikes_per_timestep</span><span class="p">)</span>

            <span class="n">big_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">upper_bound</span> <span class="o">-</span>
                         <span class="n">lngamma</span><span class="p">)</span>

            <span class="k">if</span> <span class="o">-</span><span class="mf">701.0</span> <span class="o">&lt;</span> <span class="n">big_ratio</span> <span class="o">&lt;</span> <span class="mf">701.0</span> <span class="ow">and</span> <span class="n">big_ratio</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">log_weight_variance</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="n">average_spikes_per_timestep</span> <span class="o">+</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)</span> <span class="o">+</span>
                    <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">weight_std_dev</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">gammai</span> <span class="o">-</span>
                             <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">big_ratio</span><span class="p">)))</span>
                <span class="n">weight_variance</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_weight_variance</span><span class="p">)</span>

        <span class="c1"># upper bound calculation -&gt; mean + n * SD</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">average_spikes_per_timestep</span> <span class="o">*</span> <span class="n">weight_mean</span><span class="p">)</span> <span class="o">+</span>
                <span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">poisson_variance</span> <span class="o">+</span> <span class="n">weight_variance</span><span class="p">)))</span>

<div class="viewcode-block" id="AbstractPopulationVertex.get_ring_buffer_shifts"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_ring_buffer_shifts">[docs]</a>    <span class="k">def</span> <span class="nf">get_ring_buffer_shifts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the shift of the ring buffers for transfer of values into the</span>
<span class="sd">            input buffers for this model.</span>

<span class="sd">        :param list(~spynnaker.pyNN.models.Projection) incoming_projections:</span>
<span class="sd">            The projections to consider in the calculations</span>
<span class="sd">        :rtype: list(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">_Stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">proj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">incoming_projections</span><span class="p">:</span>
            <span class="c1"># pylint: disable=protected-access</span>
            <span class="n">synapse_info</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">_synapse_information</span>
            <span class="c1"># Skip if this is a synapse dynamics synapse type</span>
            <span class="k">if</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">synapse_type_from_dynamics</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">stats</span><span class="o">.</span><span class="n">add_projection</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>

        <span class="n">n_synapse_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">get_n_synapse_types</span><span class="p">()</span>
        <span class="n">max_weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">synapse_type</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">):</span>
            <span class="n">max_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">get_max_weight</span><span class="p">(</span><span class="n">synapse_type</span><span class="p">)</span>

        <span class="c1"># Convert these to powers; we could use int.bit_length() for this if</span>
        <span class="c1"># they were integers, but they aren&#39;t...</span>
        <span class="n">max_weight_powers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">0</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">w</span><span class="p">))))</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">max_weights</span><span class="p">)</span>

        <span class="c1"># If 2^max_weight_power equals the max weight, we have to add another</span>
        <span class="c1"># power, as range is 0 - (just under 2^max_weight_power)!</span>
        <span class="n">max_weight_powers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">w</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="k">else</span> <span class="n">w</span>
            <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">max_weight_powers</span><span class="p">,</span> <span class="n">max_weights</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">max_weight_powers</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__get_weight_scale</span><span class="p">(</span><span class="n">ring_buffer_to_input_left_shift</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the amount to scale the weights by to convert them from \</span>
<span class="sd">            floating point values to 16-bit fixed point numbers which can be \</span>
<span class="sd">            shifted left by ring_buffer_to_input_left_shift to produce an\</span>
<span class="sd">            s1615 fixed point number</span>

<span class="sd">        :param int ring_buffer_to_input_left_shift:</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">16</span> <span class="o">-</span> <span class="p">(</span><span class="n">ring_buffer_to_input_left_shift</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

<div class="viewcode-block" id="AbstractPopulationVertex.get_weight_scales"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_weight_scales">[docs]</a>    <span class="k">def</span> <span class="nf">get_weight_scales</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring_buffer_shifts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the weight scaling to apply to weights in synapses</span>

<span class="sd">        :param list(int) ring_buffer_shifts:</span>
<span class="sd">            The shifts to convert to weight scales</span>
<span class="sd">        :rtype: list(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">weight_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">get_global_weight_scale</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_weight_scale</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_scale</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ring_buffer_shifts</span><span class="p">])</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_connections_from_machine"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_connections_from_machine">[docs]</a>    <span class="nd">@overrides</span><span class="p">(</span><span class="n">AbstractAcceptsIncomingSynapses</span><span class="o">.</span><span class="n">get_connections_from_machine</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_connections_from_machine</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
        <span class="c1"># If we already have connections cached, return them</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__connection_cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__connection_cache</span><span class="p">[</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">]</span>

        <span class="c1"># Start with something in the list so that concatenate works</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">AbstractSDRAMSynapseDynamics</span><span class="o">.</span><span class="n">NUMPY_CONNECTORS_DTYPE</span><span class="p">)]</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="n">ProgressBar</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">machine_vertices</span><span class="p">),</span>
            <span class="s2">&quot;Getting synaptic data between </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">post_vertex</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">post_vertex</span> <span class="ow">in</span> <span class="n">progress</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">machine_vertices</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">post_vertex</span><span class="p">,</span> <span class="n">HasSynapses</span><span class="p">):</span>
                <span class="n">placement</span> <span class="o">=</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span>
                    <span class="n">post_vertex</span><span class="p">)</span>
                <span class="n">connections</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">post_vertex</span><span class="o">.</span><span class="n">get_connections_from_machine</span><span class="p">(</span>
                    <span class="n">placement</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">))</span>
        <span class="n">all_connections</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">connections</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__connection_cache</span><span class="p">[</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_connections</span>
        <span class="k">return</span> <span class="n">all_connections</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_synapse_params_size"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_synapse_params_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_synapse_params_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the size of the synapse parameters in bytes</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This will only hold ring buffer scaling for the neuron synapse</span>
        <span class="c1"># types</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_SYNAPSES_BASE_SDRAM_USAGE_IN_BYTES</span> <span class="o">+</span>
                <span class="p">(</span><span class="n">BYTES_PER_WORD</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">get_n_synapse_types</span><span class="p">()))</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_synapse_dynamics_size"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_synapse_dynamics_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_synapse_dynamics_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the size of the synapse dynamics region</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">            The slice of the vertex to get the usage of</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="p">,</span> <span class="n">AbstractLocalOnly</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">get_parameters_usage_in_bytes</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">incoming_projections</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">get_parameters_sdram_usage_in_bytes</span><span class="p">(</span>
            <span class="n">n_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">get_n_synapse_types</span><span class="p">())</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_structural_dynamics_size"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_structural_dynamics_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_structural_dynamics_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the size of the structural dynamics region</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">            The slice of the vertex to get the usage of</span>
<span class="sd">        :param list(~spynnaker.pyNN.models.Projection) incoming_projections:</span>
<span class="sd">            The projections to consider in the calculations</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="p">,</span> <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span>\
            <span class="o">.</span><span class="n">get_structural_parameters_sdram_usage_in_bytes</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">incoming_projections</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_synapses_size"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_synapses_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_synapses_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_post_atoms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the maximum SDRAM usage for the synapses on a vertex slice</span>

<span class="sd">        :param int n_post_atoms: The number of atoms projected to</span>
<span class="sd">        :param list(~spynnaker.pyNN.models.Projection) incoming_projections:</span>
<span class="sd">            The projections to consider in the calculations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="p">,</span> <span class="n">AbstractLocalOnly</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
        <span class="k">for</span> <span class="n">proj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">incoming_projections</span><span class="p">:</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add_matrix_size</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">proj</span><span class="p">,</span> <span class="n">n_post_atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">addr</span></div>

    <span class="k">def</span> <span class="nf">__add_matrix_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">projection</span><span class="p">,</span> <span class="n">n_post_atoms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Add to the address the size of the matrices for the projection to</span>
<span class="sd">            the vertex slice</span>

<span class="sd">        :param int addr: The address to start from</span>
<span class="sd">        :param ~spynnaker.pyNN.models.Projection: The projection to add</span>
<span class="sd">        :param int n_post_atoms: The number of atoms projected to</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">synapse_info</span> <span class="o">=</span> <span class="n">projection</span><span class="o">.</span><span class="n">_synapse_information</span>
        <span class="n">app_edge</span> <span class="o">=</span> <span class="n">projection</span><span class="o">.</span><span class="n">_projection_edge</span>

        <span class="n">max_row_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_max_row_info</span><span class="p">(</span>
            <span class="n">synapse_info</span><span class="p">,</span> <span class="n">n_post_atoms</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">)</span>

        <span class="n">vertex</span> <span class="o">=</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span>
        <span class="n">max_atoms</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get_max_atoms_per_core</span><span class="p">()</span>
        <span class="n">n_sub_atoms</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">max_atoms</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">))</span>
        <span class="n">n_sub_edges</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">/</span> <span class="n">n_sub_atoms</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_n_synapses</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">n_sub_atoms</span> <span class="o">*</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_bytes</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sub_edges</span><span class="p">):</span>
                <span class="n">addr</span> <span class="o">=</span> <span class="n">MasterPopTableAsBinarySearch</span><span class="o">.</span><span class="n">get_next_allowed_address</span><span class="p">(</span>
                    <span class="n">addr</span><span class="p">)</span>
                <span class="n">addr</span> <span class="o">+=</span> <span class="n">size</span>
        <span class="k">if</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_n_synapses</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_sub_atoms</span> <span class="o">*</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_bytes</span> <span class="o">*</span>
                    <span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sub_edges</span><span class="p">):</span>
                <span class="n">addr</span> <span class="o">=</span> <span class="n">MasterPopTableAsBinarySearch</span><span class="o">.</span><span class="n">get_next_allowed_address</span><span class="p">(</span>
                    <span class="n">addr</span><span class="p">)</span>
                <span class="n">addr</span> <span class="o">+=</span> <span class="n">size</span>
        <span class="k">return</span> <span class="n">addr</span>

<div class="viewcode-block" id="AbstractPopulationVertex.get_max_row_info"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_max_row_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_max_row_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">n_post_atoms</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get maximum row length data</span>

<span class="sd">        :param SynapseInformation synapse_info: Information about synapses</span>
<span class="sd">        :param int n_post_atoms: The number of atoms projected to</span>
<span class="sd">        :param ProjectionApplicationEdge app_edge: The edge of the projection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">n_post_atoms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_row_info</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_row_info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">max_row_info</span> <span class="o">=</span> <span class="n">get_max_row_info</span><span class="p">(</span>
            <span class="n">synapse_info</span><span class="p">,</span> <span class="n">n_post_atoms</span><span class="p">,</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_row_info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_row_info</span>
        <span class="k">return</span> <span class="n">max_row_info</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_synapse_expander_size"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_synapse_expander_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_synapse_expander_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the size of the synapse expander region in bytes</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">SYNAPSES_BASE_GENERATOR_SDRAM_USAGE_IN_BYTES</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__neuron_impl</span><span class="o">.</span><span class="n">get_n_synapse_types</span><span class="p">()</span> <span class="o">*</span>
                 <span class="n">DataType</span><span class="o">.</span><span class="n">U3232</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">proj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">incoming_projections</span><span class="p">:</span>
            <span class="c1"># pylint: disable=protected-access</span>
            <span class="n">synapse_info</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">_synapse_information</span>
            <span class="n">app_edge</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">_projection_edge</span>
            <span class="n">n_sub_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">splitter</span><span class="o">.</span><span class="n">get_out_going_slices</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">n_sub_edges</span><span class="p">:</span>
                <span class="n">vertex</span> <span class="o">=</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span>
                <span class="n">max_atoms</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">get_max_atoms_per_core</span><span class="p">(),</span>
                                      <span class="n">vertex</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">))</span>
                <span class="n">n_sub_edges</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">/</span> <span class="n">max_atoms</span><span class="p">))</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generator_info_size</span><span class="p">(</span><span class="n">synapse_info</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_sub_edges</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">get_sdram_for_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incoming_projections</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">size</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__generator_info_size</span><span class="p">(</span><span class="n">synapse_info</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The number of bytes required by the generator information</span>

<span class="sd">        :param SynapseInformation synapse_info: The synapse information to use</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">may_generate_on_machine</span><span class="p">():</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">connector</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">connector</span>
        <span class="n">dynamics</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">synapse_dynamics</span>
        <span class="n">gen_size</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span>
            <span class="n">GeneratorData</span><span class="o">.</span><span class="n">BASE_SIZE</span><span class="p">,</span>
            <span class="n">connector</span><span class="o">.</span><span class="n">gen_delay_params_size_in_bytes</span><span class="p">(</span><span class="n">synapse_info</span><span class="o">.</span><span class="n">delays</span><span class="p">),</span>
            <span class="n">connector</span><span class="o">.</span><span class="n">gen_weight_params_size_in_bytes</span><span class="p">(</span><span class="n">synapse_info</span><span class="o">.</span><span class="n">weights</span><span class="p">),</span>
            <span class="n">connector</span><span class="o">.</span><span class="n">gen_connector_params_size_in_bytes</span><span class="p">,</span>
            <span class="n">dynamics</span><span class="o">.</span><span class="n">gen_matrix_params_size_in_bytes</span>
        <span class="p">))</span>
        <span class="k">return</span> <span class="n">gen_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_executable_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The suffix of the executable name due to the type of synapses \</span>
<span class="sd">            in use.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">get_vertex_executable_suffix</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neuron_recordables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the names of variables that can be recorded by the neuron</span>

<span class="sd">        :rtype: list(str)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">get_recordable_variables</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_recordables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the names of variables that can be recorded by the synapses</span>

<span class="sd">        :rtype: list(str)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">get_recordable_variables</span><span class="p">()</span>

<div class="viewcode-block" id="AbstractPopulationVertex.get_common_constant_sdram"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_common_constant_sdram">[docs]</a>    <span class="k">def</span> <span class="nf">get_common_constant_sdram</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">n_record</span><span class="p">,</span> <span class="n">n_provenance</span><span class="p">,</span> <span class="n">common_regions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the amount of SDRAM used by common parts</span>

<span class="sd">        :param int n_record: The number of recording regions</span>
<span class="sd">        :param int n_provenance: The number of provenance items</span>
<span class="sd">        :param CommonRegions common_regions: Region IDs</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sdram</span> <span class="o">=</span> <span class="n">MultiRegionSDRAM</span><span class="p">()</span>
        <span class="n">sdram</span><span class="o">.</span><span class="n">add_cost</span><span class="p">(</span><span class="n">common_regions</span><span class="o">.</span><span class="n">system</span><span class="p">,</span> <span class="n">SYSTEM_BYTES_REQUIREMENT</span><span class="p">)</span>
        <span class="n">sdram</span><span class="o">.</span><span class="n">add_cost</span><span class="p">(</span>
            <span class="n">common_regions</span><span class="o">.</span><span class="n">recording</span><span class="p">,</span>
            <span class="n">get_recording_header_size</span><span class="p">(</span><span class="n">n_record</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">get_recording_data_constant_size</span><span class="p">(</span><span class="n">n_record</span><span class="p">))</span>
        <span class="n">sdram</span><span class="o">.</span><span class="n">add_cost</span><span class="p">(</span>
            <span class="n">common_regions</span><span class="o">.</span><span class="n">provenance</span><span class="p">,</span>
            <span class="n">ProvidesProvenanceDataFromMachineImpl</span><span class="o">.</span><span class="n">get_provenance_data_size</span><span class="p">(</span>
                <span class="n">n_provenance</span><span class="p">))</span>
        <span class="n">sdram</span><span class="o">.</span><span class="n">add_cost</span><span class="p">(</span>
            <span class="n">common_regions</span><span class="o">.</span><span class="n">profile</span><span class="p">,</span>
            <span class="n">get_profile_region_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_profile_samples</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">sdram</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_neuron_variable_sdram"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_neuron_variable_sdram">[docs]</a>    <span class="k">def</span> <span class="nf">get_neuron_variable_sdram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the amount of SDRAM per timestep used by neuron parts</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">            The slice of neurons to get the size of</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">get_variable_sdram_usage</span><span class="p">(</span><span class="n">vertex_slice</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_max_neuron_variable_sdram"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_max_neuron_variable_sdram">[docs]</a>    <span class="k">def</span> <span class="nf">get_max_neuron_variable_sdram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the amount of SDRAM per timestep used by neuron parts</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">            The slice of neurons to get the size of</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">get_max_variable_sdram_usage</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_synapse_variable_sdram"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_synapse_variable_sdram">[docs]</a>    <span class="k">def</span> <span class="nf">get_synapse_variable_sdram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the amount of SDRAM per timestep used by synapse parts</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">            The slice of neurons to get the size of</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="p">,</span>
                      <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">set_max_rewires_per_ts</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">get_max_rewires_per_ts</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">get_variable_sdram_usage</span><span class="p">(</span><span class="n">vertex_slice</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_max_synapse_variable_sdram"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_max_synapse_variable_sdram">[docs]</a>    <span class="k">def</span> <span class="nf">get_max_synapse_variable_sdram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the amount of SDRAM per timestep used by synapse parts</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">            The slice of neurons to get the size of</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="p">,</span>
                      <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">set_max_rewires_per_ts</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">get_max_rewires_per_ts</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_recorder</span><span class="o">.</span><span class="n">get_max_variable_sdram_usage</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.get_neuron_constant_sdram"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_neuron_constant_sdram">[docs]</a>    <span class="k">def</span> <span class="nf">get_neuron_constant_sdram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">,</span> <span class="n">neuron_regions</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the amount of fixed SDRAM used by neuron parts</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">            The slice of neurons to get the size of</span>
<span class="sd">        :param NeuronRegions neuron_regions: Region IDs</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params_cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sdram_usage_for_neuron_params</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">)</span>
        <span class="n">sdram</span> <span class="o">=</span> <span class="n">MultiRegionSDRAM</span><span class="p">()</span>
        <span class="n">sdram</span><span class="o">.</span><span class="n">add_cost</span><span class="p">(</span>
            <span class="n">neuron_regions</span><span class="o">.</span><span class="n">core_params</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_sdram_usage_for_core_neuron_params</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">))</span>
        <span class="n">sdram</span><span class="o">.</span><span class="n">add_cost</span><span class="p">(</span><span class="n">neuron_regions</span><span class="o">.</span><span class="n">neuron_params</span><span class="p">,</span> <span class="n">params_cost</span><span class="p">)</span>
        <span class="n">sdram</span><span class="o">.</span><span class="n">add_cost</span><span class="p">(</span>
            <span class="n">neuron_regions</span><span class="o">.</span><span class="n">current_source_params</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_sdram_usage_for_current_source_params</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">))</span>
        <span class="n">sdram</span><span class="o">.</span><span class="n">add_cost</span><span class="p">(</span>
            <span class="n">neuron_regions</span><span class="o">.</span><span class="n">neuron_recording</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__neuron_recorder</span><span class="o">.</span><span class="n">get_metadata_sdram_usage_in_bytes</span><span class="p">(</span>
                <span class="n">n_atoms</span><span class="p">))</span>
        <span class="n">sdram</span><span class="o">.</span><span class="n">add_cost</span><span class="p">(</span>
            <span class="n">neuron_regions</span><span class="o">.</span><span class="n">neuron_builder</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_sdram_usage_for_neuron_generation</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">))</span>
        <span class="n">sdram</span><span class="o">.</span><span class="n">add_cost</span><span class="p">(</span><span class="n">neuron_regions</span><span class="o">.</span><span class="n">initial_values</span><span class="p">,</span> <span class="n">params_cost</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sdram</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">incoming_projections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The projections that target this population vertex</span>

<span class="sd">        :rtype: iterable(~spynnaker.pyNN.models.projection.Projection)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">proj_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_projections</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">proj</span> <span class="ow">in</span> <span class="n">proj_list</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">proj</span>

<div class="viewcode-block" id="AbstractPopulationVertex.get_incoming_projections_from"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.get_incoming_projections_from">[docs]</a>    <span class="k">def</span> <span class="nf">get_incoming_projections_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_vertex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the projections that target this population vertex from</span>
<span class="sd">            the given source</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_projections</span><span class="p">[</span><span class="n">source_vertex</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">incoming_poisson_projections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The projections that target this population vertex which</span>
<span class="sd">            originate from a Poisson source</span>

<span class="sd">        :rtype: iterable(~spynnaker.pyNN.models.projection.Projection)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_poisson_projections</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pop_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The seed to use for the population overall</span>

<span class="sd">        :return: A list of 4 integers</span>
<span class="sd">        :rtype: list(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pop_seed</span>

<div class="viewcode-block" id="AbstractPopulationVertex.core_seed"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.core_seed">[docs]</a>    <span class="k">def</span> <span class="nf">core_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The seed to use for a core</span>

<span class="sd">        :param Slice vertex_slice: The machine vertex that the seed is for</span>

<span class="sd">        :return: A list of 4 integers</span>
<span class="sd">        :rtype: list(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertex_slice</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__core_seeds</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__core_seeds</span><span class="p">[</span><span class="n">vertex_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_mars_kiss_seeds</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__rng</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__core_seeds</span><span class="p">[</span><span class="n">vertex_slice</span><span class="p">]</span></div>

<div class="viewcode-block" id="AbstractPopulationVertex.copy_initial_state_variables"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.AbstractPopulationVertex.copy_initial_state_variables">[docs]</a>    <span class="k">def</span> <span class="nf">copy_initial_state_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Copies the state variables into the initial state variables</span>

<span class="sd">        :param Slice vertex_slice: The slice to copy now</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__state_variables</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__state_variables</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">vertex_slice</span><span class="o">.</span><span class="n">as_slice</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__initial_state_variables</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">set_value_by_slice</span><span class="p">(</span>
                <span class="n">vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># This is called during reading of initial values, so we don&#39;t</span>
        <span class="c1"># need to do it again</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__read_initial_values</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__have_read_initial_values</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">read_initial_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Determine if initial values need to be stored</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__read_initial_values</span>

    <span class="k">def</span> <span class="nf">__tell_neuron_vertices_to_regenerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">machine_vertices</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">PopulationMachineNeurons</span><span class="p">):</span>
                <span class="n">vertex</span><span class="o">.</span><span class="n">set_do_neuron_regeneration</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@overrides</span><span class="p">(</span><span class="n">PopulationApplicationVertex</span><span class="o">.</span><span class="n">n_colour_bits</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">n_colour_bits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_colour_bits</span>


<span class="k">class</span> <span class="nc">_Stats</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Object to keep hold of and process statistics for ring buffer scaling</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;w_scale&quot;</span><span class="p">,</span>
        <span class="s2">&quot;w_scale_sq&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_synapse_types&quot;</span><span class="p">,</span>
        <span class="s2">&quot;running_totals&quot;</span><span class="p">,</span>
        <span class="s2">&quot;delay_running_totals&quot;</span><span class="p">,</span>
        <span class="s2">&quot;total_weights&quot;</span><span class="p">,</span>
        <span class="s2">&quot;biggest_weight&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rate_stats&quot;</span><span class="p">,</span>
        <span class="s2">&quot;steps_per_second&quot;</span><span class="p">,</span>
        <span class="s2">&quot;default_spikes_per_second&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ring_buffer_sigma&quot;</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">neuron_impl</span><span class="p">,</span> <span class="n">default_spikes_per_second</span><span class="p">,</span> <span class="n">ring_buffer_sigma</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w_scale</span> <span class="o">=</span> <span class="n">neuron_impl</span><span class="o">.</span><span class="n">get_global_weight_scale</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w_scale_sq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_scale</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">n_synapse_types</span> <span class="o">=</span> <span class="n">neuron_impl</span><span class="o">.</span><span class="n">get_n_synapse_types</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">running_totals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">RunningStats</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delay_running_totals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">RunningStats</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">biggest_weight</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate_stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">RunningStats</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">steps_per_second</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_simulation_time_step_per_s</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_spikes_per_second</span> <span class="o">=</span> <span class="n">default_spikes_per_second</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ring_buffer_sigma</span> <span class="o">=</span> <span class="n">ring_buffer_sigma</span>

    <span class="k">def</span> <span class="nf">add_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proj</span><span class="p">):</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">s_dynamics</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">_synapse_information</span><span class="o">.</span><span class="n">synapse_dynamics</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s_dynamics</span><span class="p">,</span> <span class="n">AbstractSupportsSignedWeights</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__add_signed_projection</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__add_unsigned_projection</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add_signed_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proj</span><span class="p">):</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">s_info</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">_synapse_information</span>
        <span class="n">connector</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">.</span><span class="n">connector</span>
        <span class="n">s_dynamics</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">.</span><span class="n">synapse_dynamics</span>

        <span class="n">n_conns</span> <span class="o">=</span> <span class="n">connector</span><span class="o">.</span><span class="n">get_n_connections_to_post_vertex_maximum</span><span class="p">(</span><span class="n">s_info</span><span class="p">)</span>
        <span class="n">d_var</span> <span class="o">=</span> <span class="n">s_dynamics</span><span class="o">.</span><span class="n">get_delay_variance</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">s_info</span><span class="o">.</span><span class="n">delays</span><span class="p">,</span> <span class="n">s_info</span><span class="p">)</span>

        <span class="n">s_type_pos</span> <span class="o">=</span> <span class="n">s_dynamics</span><span class="o">.</span><span class="n">get_positive_synapse_index</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
        <span class="n">w_mean_pos</span> <span class="o">=</span> <span class="n">s_dynamics</span><span class="o">.</span><span class="n">get_mean_positive_weight</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
        <span class="n">w_var_pos</span> <span class="o">=</span> <span class="n">s_dynamics</span><span class="o">.</span><span class="n">get_variance_positive_weight</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
        <span class="n">w_max_pos</span> <span class="o">=</span> <span class="n">s_dynamics</span><span class="o">.</span><span class="n">get_maximum_positive_weight</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__add_details</span><span class="p">(</span>
            <span class="n">proj</span><span class="p">,</span> <span class="n">s_type_pos</span><span class="p">,</span> <span class="n">n_conns</span><span class="p">,</span> <span class="n">w_mean_pos</span><span class="p">,</span> <span class="n">w_var_pos</span><span class="p">,</span> <span class="n">w_max_pos</span><span class="p">,</span> <span class="n">d_var</span><span class="p">)</span>

        <span class="n">s_type_neg</span> <span class="o">=</span> <span class="n">s_dynamics</span><span class="o">.</span><span class="n">get_negative_synapse_index</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
        <span class="n">w_mean_neg</span> <span class="o">=</span> <span class="o">-</span><span class="n">s_dynamics</span><span class="o">.</span><span class="n">get_mean_negative_weight</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
        <span class="n">w_var_neg</span> <span class="o">=</span> <span class="o">-</span><span class="n">s_dynamics</span><span class="o">.</span><span class="n">get_variance_negative_weight</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
        <span class="n">w_max_neg</span> <span class="o">=</span> <span class="o">-</span><span class="n">s_dynamics</span><span class="o">.</span><span class="n">get_minimum_negative_weight</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__add_details</span><span class="p">(</span>
            <span class="n">proj</span><span class="p">,</span> <span class="n">s_type_neg</span><span class="p">,</span> <span class="n">n_conns</span><span class="p">,</span> <span class="n">w_mean_neg</span><span class="p">,</span> <span class="n">w_var_neg</span><span class="p">,</span> <span class="n">w_max_neg</span><span class="p">,</span> <span class="n">d_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add_unsigned_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proj</span><span class="p">):</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">s_info</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">_synapse_information</span>
        <span class="n">s_type</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">.</span><span class="n">synapse_type</span>
        <span class="n">s_dynamics</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">.</span><span class="n">synapse_dynamics</span>
        <span class="n">connector</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">.</span><span class="n">connector</span>

        <span class="n">n_conns</span> <span class="o">=</span> <span class="n">connector</span><span class="o">.</span><span class="n">get_n_connections_to_post_vertex_maximum</span><span class="p">(</span><span class="n">s_info</span><span class="p">)</span>
        <span class="n">w_mean</span> <span class="o">=</span> <span class="n">s_dynamics</span><span class="o">.</span><span class="n">get_weight_mean</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">s_info</span><span class="p">)</span>
        <span class="n">w_var</span> <span class="o">=</span> <span class="n">s_dynamics</span><span class="o">.</span><span class="n">get_weight_variance</span><span class="p">(</span>
            <span class="n">connector</span><span class="p">,</span> <span class="n">s_info</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">s_info</span><span class="p">)</span>
        <span class="n">w_max</span> <span class="o">=</span> <span class="n">s_dynamics</span><span class="o">.</span><span class="n">get_weight_maximum</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">s_info</span><span class="p">)</span>
        <span class="n">d_var</span> <span class="o">=</span> <span class="n">s_dynamics</span><span class="o">.</span><span class="n">get_delay_variance</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">s_info</span><span class="o">.</span><span class="n">delays</span><span class="p">,</span> <span class="n">s_info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__add_details</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">s_type</span><span class="p">,</span> <span class="n">n_conns</span><span class="p">,</span> <span class="n">w_mean</span><span class="p">,</span> <span class="n">w_var</span><span class="p">,</span> <span class="n">w_max</span><span class="p">,</span> <span class="n">d_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add_details</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">proj</span><span class="p">,</span> <span class="n">s_type</span><span class="p">,</span> <span class="n">n_conns</span><span class="p">,</span> <span class="n">w_mean</span><span class="p">,</span> <span class="n">w_var</span><span class="p">,</span> <span class="n">w_max</span><span class="p">,</span> <span class="n">d_var</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_totals</span><span class="p">[</span><span class="n">s_type</span><span class="p">]</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span>
            <span class="n">w_mean</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_scale</span><span class="p">,</span> <span class="n">w_var</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_scale_sq</span><span class="p">,</span> <span class="n">n_conns</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">biggest_weight</span><span class="p">[</span><span class="n">s_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">biggest_weight</span><span class="p">[</span><span class="n">s_type</span><span class="p">],</span> <span class="n">w_max</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_scale</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delay_running_totals</span><span class="p">[</span><span class="n">s_type</span><span class="p">]</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">d_var</span><span class="p">,</span> <span class="n">n_conns</span><span class="p">)</span>

        <span class="n">spikes_per_tick</span><span class="p">,</span> <span class="n">spikes_per_second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pre_spike_stats</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate_stats</span><span class="p">[</span><span class="n">s_type</span><span class="p">]</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span><span class="n">spikes_per_second</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_conns</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_weights</span><span class="p">[</span><span class="n">s_type</span><span class="p">]</span> <span class="o">+=</span> <span class="n">spikes_per_tick</span> <span class="o">*</span> <span class="p">(</span><span class="n">w_max</span> <span class="o">*</span> <span class="n">n_conns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__pre_spike_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proj</span><span class="p">):</span>
        <span class="n">spikes_per_tick</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="mf">1.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_spikes_per_second</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">steps_per_second</span><span class="p">)</span>
        <span class="n">spikes_per_second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_spikes_per_second</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">pre_vertex</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">_projection_edge</span><span class="o">.</span><span class="n">pre_vertex</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pre_vertex</span><span class="p">,</span> <span class="n">AbstractMaxSpikes</span><span class="p">):</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="n">pre_vertex</span><span class="o">.</span><span class="n">max_spikes_per_second</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">rate</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">spikes_per_second</span> <span class="o">=</span> <span class="n">rate</span>
            <span class="n">spikes_per_tick</span> <span class="o">=</span> <span class="n">pre_vertex</span><span class="o">.</span><span class="n">max_spikes_per_ts</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">spikes_per_tick</span><span class="p">,</span> <span class="n">spikes_per_second</span>

    <span class="k">def</span> <span class="nf">get_max_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_type</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delay_running_totals</span><span class="p">[</span><span class="n">s_type</span><span class="p">]</span><span class="o">.</span><span class="n">variance</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_weights</span><span class="p">[</span><span class="n">s_type</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">biggest_weight</span><span class="p">[</span><span class="n">s_type</span><span class="p">])</span>

        <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_totals</span><span class="p">[</span><span class="n">s_type</span><span class="p">]</span>
        <span class="n">rates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_stats</span><span class="p">[</span><span class="n">s_type</span><span class="p">]</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">w_max</span> <span class="o">=</span> <span class="n">AbstractPopulationVertex</span><span class="o">.</span><span class="n">_ring_buffer_expected_upper_bound</span><span class="p">(</span>
            <span class="n">stats</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">standard_deviation</span><span class="p">,</span> <span class="n">rates</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
            <span class="n">stats</span><span class="o">.</span><span class="n">n_items</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring_buffer_sigma</span><span class="p">)</span>
        <span class="n">w_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">w_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_weights</span><span class="p">[</span><span class="n">s_type</span><span class="p">])</span>
        <span class="n">w_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">w_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">biggest_weight</span><span class="p">[</span><span class="n">s_type</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">w_max</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">sPyNNaker 6.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../pyNN.html" >spynnaker.pyNN</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spynnaker.pyNN.models.neuron.abstract_population_vertex</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-2021.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.1.2.
    </div>
  </body>
</html>