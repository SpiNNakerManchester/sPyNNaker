
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>spynnaker.pyNN.models.neuron.synaptic_manager &#8212; sPyNNaker  documentation</title>
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/sphinxdoc.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../_static/jquery.js"></script>
    <script src="../../../../../_static/underscore.js"></script>
    <script src="../../../../../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">sPyNNaker  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spynnaker.pyNN.models.neuron.synaptic_manager</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for spynnaker.pyNN.models.neuron.synaptic_manager</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2017-2019 The University of Manchester</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">special</span>  <span class="c1"># @UnresolvedImport</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">itervalues</span>

<span class="kn">from</span> <span class="nn">spinn_utilities.progress_bar</span> <span class="kn">import</span> <span class="n">ProgressBar</span>

<span class="kn">from</span> <span class="nn">data_specification.enums</span> <span class="kn">import</span> <span class="n">DataType</span>

<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BYTES_PER_WORD</span><span class="p">,</span> <span class="n">MICRO_TO_SECOND_CONVERSION</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neural_projections</span> <span class="kn">import</span> <span class="n">ProjectionApplicationEdge</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.abstract_models</span> <span class="kn">import</span> <span class="n">AbstractMaxSpikes</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neuron.synapse_io</span> <span class="kn">import</span> <span class="n">SynapseIORowBased</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">POPULATION_BASED_REGIONS</span><span class="p">,</span> <span class="n">POSSION_SIGMA_SUMMATION_LIMIT</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.utility_calls</span> <span class="kn">import</span> <span class="p">(</span><span class="n">get_n_bits</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.running_stats</span> <span class="kn">import</span> <span class="n">RunningStats</span>

<span class="kn">from</span> <span class="nn">.synapse_dynamics</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AbstractSynapseDynamics</span><span class="p">,</span> <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.synaptic_matrices</span> <span class="kn">import</span> <span class="n">SYNAPSES_BASE_GENERATOR_SDRAM_USAGE_IN_BYTES</span>
<span class="kn">from</span> <span class="nn">.synaptic_matrices</span> <span class="kn">import</span> <span class="n">SynapticMatrices</span>

<span class="n">TIME_STAMP_BYTES</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span>

<span class="c1"># TODO: Make sure these values are correct (particularly CPU cycles)</span>
<span class="n">_SYNAPSES_BASE_DTCM_USAGE_IN_BYTES</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>

<span class="c1"># 1 for drop late packets.</span>
<span class="n">_SYNAPSES_BASE_SDRAM_USAGE_IN_BYTES</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
<span class="n">_SYNAPSES_BASE_N_CPU_CYCLES_PER_NEURON</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">_SYNAPSES_BASE_N_CPU_CYCLES</span> <span class="o">=</span> <span class="mi">8</span>

<span class="c1"># Struct to read or write a word</span>
<span class="n">_ONE_WORD</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">Struct</span><span class="p">(</span><span class="s2">&quot;&lt;I&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="SynapticManager"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager">[docs]</a><span class="k">class</span> <span class="nc">SynapticManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Deals with synapses</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=too-many-arguments, too-many-locals</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># The number of synapse types</span>
        <span class="s2">&quot;__n_synapse_types&quot;</span><span class="p">,</span>
        <span class="c1"># The maximum size of the direct or single synaptic matrix</span>
        <span class="s2">&quot;__all_single_syn_sz&quot;</span><span class="p">,</span>
        <span class="c1"># The number of sigmas to use when calculating the ring buffer upper</span>
        <span class="c1"># bound</span>
        <span class="s2">&quot;__ring_buffer_sigma&quot;</span><span class="p">,</span>
        <span class="c1"># The spikes-per-second to use for an incoming population that doesn&#39;t</span>
        <span class="c1"># specify this</span>
        <span class="s2">&quot;__spikes_per_second&quot;</span><span class="p">,</span>
        <span class="c1"># The dynamics used by the synapses e.g. STDP, static etc.</span>
        <span class="s2">&quot;__synapse_dynamics&quot;</span><span class="p">,</span>
        <span class="c1"># The reader and writer of synapses to and from SpiNNaker</span>
        <span class="s2">&quot;__synapse_io&quot;</span><span class="p">,</span>
        <span class="c1"># A list of scale factors for the weights for each synapse type</span>
        <span class="s2">&quot;__weight_scales&quot;</span><span class="p">,</span>
        <span class="c1"># A list of ring buffer shift values corresponding to the weight</span>
        <span class="c1"># scales; a left shift by this amount will do the multiplication by</span>
        <span class="c1"># the weight scale</span>
        <span class="s2">&quot;__ring_buffer_shifts&quot;</span><span class="p">,</span>
        <span class="c1"># The actual synaptic matrix handling code, split for simplicity</span>
        <span class="s2">&quot;__synaptic_matrices&quot;</span><span class="p">,</span>
        <span class="c1"># Determine whether spikes should be dropped if they arrive after the</span>
        <span class="c1"># end of a timestep</span>
        <span class="s2">&quot;__drop_late_spikes&quot;</span><span class="p">,</span>
        <span class="c1"># Overridable (for testing only) region IDs</span>
        <span class="s2">&quot;_synapse_params_region&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_pop_table_region&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_synaptic_matrix_region&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_synapse_dynamics_region&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_struct_dynamics_region&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_connector_builder_region&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_direct_matrix_region&quot;</span><span class="p">]</span>

    <span class="c1"># TODO make this right</span>
    <span class="n">FUDGE</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># 1. address of direct addresses, 2. size of direct addresses matrix size</span>
    <span class="n">STATIC_SYNAPSE_MATRIX_SDRAM_IN_BYTES</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>

    <span class="n">NOT_EXACT_SLICES_ERROR_MESSAGE</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;The splitter </span><span class="si">{}</span><span class="s2"> is returning estimated slices during DSG. &quot;</span>
        <span class="s2">&quot;This is deemed an error. Please fix and try again&quot;</span><span class="p">)</span>

    <span class="n">TOO_MUCH_WRITTEN_SYNAPTIC_DATA</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;Too much synaptic memory has been written: </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="p">)</span>

    <span class="n">INDEXS_DONT_MATCH_ERROR_MESSAGE</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;Delay index </span><span class="si">{}</span><span class="s2"> and normal index </span><span class="si">{}</span><span class="s2"> do not match&quot;</span><span class="p">)</span>

    <span class="n">NO_DELAY_EDGE_FOR_SRC_IDS_MESSAGE</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;Found delayed source IDs but no delay machine edge for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_synapse_types</span><span class="p">,</span> <span class="n">ring_buffer_sigma</span><span class="p">,</span> <span class="n">spikes_per_second</span><span class="p">,</span>
                 <span class="n">config</span><span class="p">,</span> <span class="n">drop_late_spikes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int n_synapse_types:</span>
<span class="sd">            number of synapse types on a neuron (e.g., 2 for excitatory and</span>
<span class="sd">            inhibitory)</span>
<span class="sd">        :param ring_buffer_sigma:</span>
<span class="sd">            How many SD above the mean to go for upper bound; a</span>
<span class="sd">            good starting choice is 5.0. Given length of simulation we can</span>
<span class="sd">            set this for approximate number of saturation events.</span>
<span class="sd">        :type ring_buffer_sigma: float or None</span>
<span class="sd">        :param spikes_per_second: Estimated spikes per second</span>
<span class="sd">        :type spikes_per_second: float or None</span>
<span class="sd">        :param ~configparser.RawConfigParser config: The system configuration</span>
<span class="sd">        :param bool drop_late_spikes: control flag for dropping late packets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span> <span class="o">=</span> <span class="n">n_synapse_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="o">=</span> <span class="n">ring_buffer_sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">=</span> <span class="n">spikes_per_second</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span> <span class="o">=</span> <span class="n">drop_late_spikes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synapse_params_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPSE_PARAMS</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pop_table_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">POPULATION_TABLE</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synaptic_matrix_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPTIC_MATRIX</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synapse_dynamics_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPSE_DYNAMICS</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_struct_dynamics_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">STRUCTURAL_DYNAMICS</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connector_builder_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">CONNECTOR_BUILDER</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_direct_matrix_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">DIRECT_MATRIX</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Create the synapse IO</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span> <span class="o">=</span> <span class="n">SynapseIORowBased</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span>
                <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;ring_buffer_sigma&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span>
                <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;spikes_per_second&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span>
                <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;drop_late_spikes&quot;</span><span class="p">)</span>

        <span class="c1"># Prepare for dealing with STDP - there can only be one (non-static)</span>
        <span class="c1"># synapse dynamics per vertex at present</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Keep the details once computed to allow reading back</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__weight_scales</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Limit the DTCM used by one-to-one connections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__all_single_syn_sz</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span>
            <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;one_to_one_connection_dtcm_max_bytes&quot;</span><span class="p">)</span>

        <span class="c1"># Post vertex slice to synaptic matrices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synaptic_matrices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__get_synaptic_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the synaptic matrices for a given slice of the vertex</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice post_vertex_slice:</span>
<span class="sd">            the slice of the vertex to get the matrices for</span>
<span class="sd">        :rtype: SynapticMatrices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use the cached version if possible</span>
        <span class="k">if</span> <span class="n">post_vertex_slice</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synaptic_matrices</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synaptic_matrices</span><span class="p">[</span><span class="n">post_vertex_slice</span><span class="p">]</span>

        <span class="c1"># Otherwise generate new ones</span>
        <span class="n">matrices</span> <span class="o">=</span> <span class="n">SynapticMatrices</span><span class="p">(</span>
            <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__all_single_syn_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_synaptic_matrix_region</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direct_matrix_region</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pop_table_region</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synaptic_matrices</span><span class="p">[</span><span class="n">post_vertex_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrices</span>
        <span class="k">return</span> <span class="n">matrices</span>

<div class="viewcode-block" id="SynapticManager.host_written_matrix_size"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.host_written_matrix_size">[docs]</a>    <span class="k">def</span> <span class="nf">host_written_matrix_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The size of the matrix written by the host for a given\</span>
<span class="sd">            machine vertex</span>

<span class="sd">        :param post_vertex_slice: The slice of the vertex to get the size of</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_synaptic_matrices</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">matrices</span><span class="o">.</span><span class="n">host_generated_block_addr</span></div>

<div class="viewcode-block" id="SynapticManager.on_chip_written_matrix_size"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.on_chip_written_matrix_size">[docs]</a>    <span class="k">def</span> <span class="nf">on_chip_written_matrix_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The size of the matrix that will be written on the machine for a\</span>
<span class="sd">            given machine vertex</span>

<span class="sd">        :param post_vertex_slice: The slice of the vertex to get the size of</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_synaptic_matrices</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">matrices</span><span class="o">.</span><span class="n">on_chip_generated_block_addr</span> <span class="o">-</span>
                <span class="n">matrices</span><span class="o">.</span><span class="n">host_generated_block_addr</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The synapse dynamics used by the synapses e.g. plastic or static.\</span>
<span class="sd">            Settable.</span>

<span class="sd">        :rtype: AbstractSynapseDynamics or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">drop_late_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span>

    <span class="nd">@synapse_dynamics</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">synapse_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synapse_dynamics</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set the synapse dynamics.  Note that after setting, the dynamics\</span>
<span class="sd">            might not be the type set as it can be combined with the existing\</span>
<span class="sd">            dynamics in exciting ways.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="o">=</span> <span class="n">synapse_dynamics</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">synapse_dynamics</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ring_buffer_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The sigma in the estimation of the maximum summed ring buffer\</span>
<span class="sd">            weights.  Settable.</span>

<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span>

    <span class="nd">@ring_buffer_sigma</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ring_buffer_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring_buffer_sigma</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="o">=</span> <span class="n">ring_buffer_sigma</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spikes_per_second</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The assumed maximum spikes per second of an incoming population.\</span>
<span class="sd">            Used when calculating the ring buffer weight scaling. Settable.</span>

<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span>

    <span class="nd">@spikes_per_second</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">spikes_per_second</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spikes_per_second</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">=</span> <span class="n">spikes_per_second</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vertex_executable_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The suffix of the executable name due to the type of synapses \</span>
<span class="sd">            in use.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">get_vertex_executable_suffix</span><span class="p">()</span>

<div class="viewcode-block" id="SynapticManager.get_n_cpu_cycles"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.get_n_cpu_cycles">[docs]</a>    <span class="k">def</span> <span class="nf">get_n_cpu_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Calculate this correctly</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">FUDGE</span></div>

<div class="viewcode-block" id="SynapticManager.get_dtcm_usage_in_bytes"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.get_dtcm_usage_in_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">get_dtcm_usage_in_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Calculate this correctly</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">FUDGE</span></div>

    <span class="k">def</span> <span class="nf">_get_synapse_params_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_SYNAPSES_BASE_SDRAM_USAGE_IN_BYTES</span> <span class="o">+</span>
                <span class="p">(</span><span class="n">BYTES_PER_WORD</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_synapse_dynamics_parameter_size</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">,</span> <span class="n">app_graph</span><span class="p">,</span> <span class="n">app_vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the size of the synapse dynamics region</span>

<span class="sd">        :param int n_atoms: The number of atoms on the core</span>
<span class="sd">        :param ~.ApplicationGraph app_graph: The application graph</span>
<span class="sd">        :param ~.ApplicationVertex app_vertex: The application vertex</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Does the size of the parameters area depend on presynaptic</span>
        <span class="c1"># connections in any way?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="p">,</span>
                      <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span>\
                <span class="o">.</span><span class="n">get_structural_parameters_sdram_usage_in_bytes</span><span class="p">(</span>
                     <span class="n">app_graph</span><span class="p">,</span> <span class="n">app_vertex</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">get_parameters_sdram_usage_in_bytes</span><span class="p">(</span>
                <span class="n">n_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">)</span>

<div class="viewcode-block" id="SynapticManager.get_sdram_usage_in_bytes"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.get_sdram_usage_in_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">get_sdram_usage_in_bytes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">app_vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the SDRAM usage of a slice of atoms of this vertex</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice post_vertex_slice:</span>
<span class="sd">            The slice of atoms to get the size of</span>
<span class="sd">        :param ~pacman.model.graphs.application.ApplicationGraph \</span>
<span class="sd">                application_graph: The application graph</span>
<span class="sd">        :param AbstractPopulationVertex app_vertex: The application vertex</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">in_edges</span> <span class="o">=</span> <span class="n">application_graph</span><span class="o">.</span><span class="n">get_edges_ending_at_vertex</span><span class="p">(</span><span class="n">app_vertex</span><span class="p">)</span>
        <span class="n">matrices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_synaptic_matrices</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_synapse_params_size</span><span class="p">()</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_synapse_dynamics_parameter_size</span><span class="p">(</span>
                <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">app_vertex</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">matrices</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">in_edges</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_reserve_memory_regions</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span>
            <span class="n">machine_vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reserve memory regions for a core</span>

<span class="sd">        :param ~.DataSpecificationGenerator spec: The data spec to reserve in</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">            The slice of the vertex to allocate for</span>
<span class="sd">        :param int all_syn_block_sz: The memory to reserve for synapses</span>
<span class="sd">        :param ~pacman.model.graphs.machine.MachineGraph machine_graph:</span>
<span class="sd">            The machine graph</span>
<span class="sd">        :param ~pacman.model.graphs.machine.MachineVertex machine_vertex:</span>
<span class="sd">            The machine vertex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
            <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_synapse_params_region</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_synapse_params_size</span><span class="p">(),</span>
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;SynapseParams&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">all_syn_block_sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_synaptic_matrix_region</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;SynBlocks&#39;</span><span class="p">)</span>

        <span class="c1"># return if not got a synapse dynamics</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">synapse_dynamics_sz</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">get_parameters_sdram_usage_in_bytes</span><span class="p">(</span>
                <span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">synapse_dynamics_sz</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_synapse_dynamics_region</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="n">synapse_dynamics_sz</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;synapseDynamicsParams&#39;</span><span class="p">)</span>

        <span class="c1"># if structural, create structural region</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="p">,</span> <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">):</span>

            <span class="n">synapse_structural_dynamics_sz</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span>
                <span class="n">get_structural_parameters_sdram_usage_in_bytes</span><span class="p">(</span>
                    <span class="n">machine_graph</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">synapse_structural_dynamics_sz</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                    <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_struct_dynamics_region</span><span class="p">,</span>
                    <span class="n">size</span><span class="o">=</span><span class="n">synapse_structural_dynamics_sz</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s1">&#39;synapseDynamicsStructuralParams&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_ring_buffer_expected_upper_bound</span><span class="p">(</span>
            <span class="n">weight_mean</span><span class="p">,</span> <span class="n">weight_std_dev</span><span class="p">,</span> <span class="n">spikes_per_second</span><span class="p">,</span>
            <span class="n">machine_timestep</span><span class="p">,</span> <span class="n">n_synapses_in</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Provides expected upper bound on accumulated values in a ring\</span>
<span class="sd">            buffer element.</span>

<span class="sd">        Requires an assessment of maximum Poisson input rate.</span>

<span class="sd">        Assumes knowledge of mean and SD of weight distribution, fan-in</span>
<span class="sd">        and timestep.</span>

<span class="sd">        All arguments should be assumed real values except n_synapses_in</span>
<span class="sd">        which will be an integer.</span>

<span class="sd">        :param float weight_mean: Mean of weight distribution (in either nA or</span>
<span class="sd">            microSiemens as required)</span>
<span class="sd">        :param float weight_std_dev: SD of weight distribution</span>
<span class="sd">        :param float spikes_per_second: Maximum expected Poisson rate in Hz</span>
<span class="sd">        :param int machine_timestep: in us</span>
<span class="sd">        :param int n_synapses_in: No of connected synapses</span>
<span class="sd">        :param float sigma: How many SD above the mean to go for upper bound;</span>
<span class="sd">            a good starting choice is 5.0. Given length of simulation we can</span>
<span class="sd">            set this for approximate number of saturation events.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># E[ number of spikes ] in a timestep</span>
        <span class="n">steps_per_second</span> <span class="o">=</span> <span class="n">MICRO_TO_SECOND_CONVERSION</span> <span class="o">/</span> <span class="n">machine_timestep</span>
        <span class="n">average_spikes_per_timestep</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="n">n_synapses_in</span> <span class="o">*</span> <span class="n">spikes_per_second</span><span class="p">)</span> <span class="o">/</span> <span class="n">steps_per_second</span><span class="p">)</span>

        <span class="c1"># Exact variance contribution from inherent Poisson variation</span>
        <span class="n">poisson_variance</span> <span class="o">=</span> <span class="n">average_spikes_per_timestep</span> <span class="o">*</span> <span class="p">(</span><span class="n">weight_mean</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Upper end of range for Poisson summation required below</span>
        <span class="c1"># upper_bound needs to be an integer</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span> <span class="o">+</span>
                                <span class="n">POSSION_SIGMA_SUMMATION_LIMIT</span> <span class="o">*</span>
                                <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)))</span>

        <span class="c1"># Closed-form exact solution for summation that gives the variance</span>
        <span class="c1"># contributed by weight distribution variation when modulated by</span>
        <span class="c1"># Poisson PDF.  Requires scipy.special for gamma and incomplete gamma</span>
        <span class="c1"># functions. Beware: incomplete gamma doesn&#39;t work the same as</span>
        <span class="c1"># Mathematica because (1) it&#39;s regularised and needs a further</span>
        <span class="c1"># multiplication and (2) it&#39;s actually the complement that is needed</span>
        <span class="c1"># i.e. &#39;gammaincc&#39;]</span>

        <span class="n">weight_variance</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="n">weight_std_dev</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># pylint: disable=no-member</span>
            <span class="n">lngamma</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">upper_bound</span><span class="p">)</span>
            <span class="n">gammai</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gammaincc</span><span class="p">(</span>
                <span class="mi">1</span> <span class="o">+</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">average_spikes_per_timestep</span><span class="p">)</span>

            <span class="n">big_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">upper_bound</span> <span class="o">-</span>
                         <span class="n">lngamma</span><span class="p">)</span>

            <span class="k">if</span> <span class="o">-</span><span class="mf">701.0</span> <span class="o">&lt;</span> <span class="n">big_ratio</span> <span class="o">&lt;</span> <span class="mf">701.0</span> <span class="ow">and</span> <span class="n">big_ratio</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">log_weight_variance</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="n">average_spikes_per_timestep</span> <span class="o">+</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)</span> <span class="o">+</span>
                    <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">weight_std_dev</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">gammai</span> <span class="o">-</span>
                             <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">big_ratio</span><span class="p">)))</span>
                <span class="n">weight_variance</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_weight_variance</span><span class="p">)</span>

        <span class="c1"># upper bound calculation -&gt; mean + n * SD</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">average_spikes_per_timestep</span> <span class="o">*</span> <span class="n">weight_mean</span><span class="p">)</span> <span class="o">+</span>
                <span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">poisson_variance</span> <span class="o">+</span> <span class="n">weight_variance</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_get_ring_buffer_to_input_left_shifts</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span> <span class="n">machine_timestep</span><span class="p">,</span>
            <span class="n">weight_scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the scaling of the ring buffer to provide as much accuracy as\</span>
<span class="sd">            possible without too much overflow</span>

<span class="sd">        :param ~pacman.model.graphs.machine.MachineVertex machine_vertex:</span>
<span class="sd">        :param ~pacman.model.graphs.machine.MachineGraph machine_graph:</span>
<span class="sd">        :param int machine_timestep:</span>
<span class="sd">        :param float weight_scale:</span>
<span class="sd">        :rtype: list(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">weight_scale_squared</span> <span class="o">=</span> <span class="n">weight_scale</span> <span class="o">*</span> <span class="n">weight_scale</span>
        <span class="n">n_synapse_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span>
        <span class="n">running_totals</span> <span class="o">=</span> <span class="p">[</span><span class="n">RunningStats</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)]</span>
        <span class="n">delay_running_totals</span> <span class="o">=</span> <span class="p">[</span><span class="n">RunningStats</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)]</span>
        <span class="n">total_weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)</span>
        <span class="n">biggest_weight</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)</span>
        <span class="n">weights_signed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">rate_stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">RunningStats</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)]</span>
        <span class="n">steps_per_second</span> <span class="o">=</span> <span class="n">MICRO_TO_SECOND_CONVERSION</span> <span class="o">/</span> <span class="n">machine_timestep</span>

        <span class="n">synapse_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">machine_edge</span> <span class="ow">in</span> <span class="n">machine_graph</span><span class="o">.</span><span class="n">get_edges_ending_at_vertex</span><span class="p">(</span>
                <span class="n">machine_vertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">machine_edge</span><span class="o">.</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">ProjectionApplicationEdge</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">synapse_info</span> <span class="ow">in</span> <span class="n">machine_edge</span><span class="o">.</span><span class="n">app_edge</span><span class="o">.</span><span class="n">synapse_information</span><span class="p">:</span>
                    <span class="c1"># Per synapse info we need any one of the edges</span>
                    <span class="n">synapse_map</span><span class="p">[</span><span class="n">synapse_info</span><span class="p">]</span> <span class="o">=</span> <span class="n">machine_edge</span>

        <span class="k">for</span> <span class="n">synapse_info</span> <span class="ow">in</span> <span class="n">synapse_map</span><span class="p">:</span>
            <span class="n">synapse_type</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">synapse_type</span>
            <span class="n">synapse_dynamics</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">synapse_dynamics</span>
            <span class="n">connector</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">connector</span>

            <span class="n">weight_mean</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">get_weight_mean</span><span class="p">(</span>
                    <span class="n">connector</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_scale</span><span class="p">)</span>
            <span class="n">n_connections</span> <span class="o">=</span> \
                <span class="n">connector</span><span class="o">.</span><span class="n">get_n_connections_to_post_vertex_maximum</span><span class="p">(</span>
                    <span class="n">synapse_info</span><span class="p">)</span>
            <span class="n">weight_variance</span> <span class="o">=</span> <span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">get_weight_variance</span><span class="p">(</span>
                <span class="n">connector</span><span class="p">,</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_scale_squared</span>
            <span class="n">running_totals</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span>
                <span class="n">weight_mean</span><span class="p">,</span> <span class="n">weight_variance</span><span class="p">,</span> <span class="n">n_connections</span><span class="p">)</span>

            <span class="n">delay_variance</span> <span class="o">=</span> <span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">get_delay_variance</span><span class="p">(</span>
                <span class="n">connector</span><span class="p">,</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">delays</span><span class="p">)</span>
            <span class="n">delay_running_totals</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span>
                <span class="mf">0.0</span><span class="p">,</span> <span class="n">delay_variance</span><span class="p">,</span> <span class="n">n_connections</span><span class="p">)</span>

            <span class="n">weight_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">get_weight_maximum</span><span class="p">(</span>
                <span class="n">connector</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_scale</span><span class="p">)</span>
            <span class="n">biggest_weight</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">biggest_weight</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">],</span> <span class="n">weight_max</span><span class="p">)</span>

            <span class="n">spikes_per_tick</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="mf">1.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">/</span> <span class="n">steps_per_second</span><span class="p">)</span>
            <span class="n">spikes_per_second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span>
            <span class="n">pre_vertex</span> <span class="o">=</span> <span class="n">synapse_map</span><span class="p">[</span><span class="n">synapse_info</span><span class="p">]</span><span class="o">.</span><span class="n">pre_vertex</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pre_vertex</span><span class="p">,</span> <span class="n">AbstractMaxSpikes</span><span class="p">):</span>
                <span class="n">rate</span> <span class="o">=</span> <span class="n">pre_vertex</span><span class="o">.</span><span class="n">max_spikes_per_second</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">rate</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">spikes_per_second</span> <span class="o">=</span> <span class="n">rate</span>
                <span class="n">spikes_per_tick</span> <span class="o">=</span> \
                    <span class="n">pre_vertex</span><span class="o">.</span><span class="n">max_spikes_per_ts</span><span class="p">(</span><span class="n">machine_timestep</span><span class="p">)</span>
            <span class="n">rate_stats</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span>
                <span class="n">spikes_per_second</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_connections</span><span class="p">)</span>
            <span class="n">total_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">+=</span> <span class="n">spikes_per_tick</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">weight_max</span> <span class="o">*</span> <span class="n">n_connections</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">are_weights_signed</span><span class="p">():</span>
                <span class="n">weights_signed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">max_weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">synapse_type</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">delay_running_totals</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span><span class="o">.</span><span class="n">variance</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">max_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">total_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">],</span>
                                                <span class="n">biggest_weight</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stats</span> <span class="o">=</span> <span class="n">running_totals</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span>
                <span class="n">rates</span> <span class="o">=</span> <span class="n">rate_stats</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span>
                <span class="n">max_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ring_buffer_expected_upper_bound</span><span class="p">(</span>
                        <span class="n">stats</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">standard_deviation</span><span class="p">,</span> <span class="n">rates</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
                        <span class="n">machine_timestep</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">n_items</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span><span class="p">),</span>
                    <span class="n">total_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">])</span>
                <span class="n">max_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                    <span class="n">max_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">],</span> <span class="n">biggest_weight</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">])</span>

        <span class="c1"># Convert these to powers; we could use int.bit_length() for this if</span>
        <span class="c1"># they were integers, but they aren&#39;t...</span>
        <span class="n">max_weight_powers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">0</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">max_weights</span><span class="p">)</span>

        <span class="c1"># If 2^max_weight_power equals the max weight, we have to add another</span>
        <span class="c1"># power, as range is 0 - (just under 2^max_weight_power)!</span>
        <span class="n">max_weight_powers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">w</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="k">else</span> <span class="n">w</span>
            <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">max_weight_powers</span><span class="p">,</span> <span class="n">max_weights</span><span class="p">))</span>

        <span class="c1"># If we have synapse dynamics that uses signed weights,</span>
        <span class="c1"># Add another bit of shift to prevent overflows</span>
        <span class="k">if</span> <span class="n">weights_signed</span><span class="p">:</span>
            <span class="n">max_weight_powers</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">max_weight_powers</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">max_weight_powers</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__get_weight_scale</span><span class="p">(</span><span class="n">ring_buffer_to_input_left_shift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the amount to scale the weights by to convert them from \</span>
<span class="sd">            floating point values to 16-bit fixed point numbers which can be \</span>
<span class="sd">            shifted left by ring_buffer_to_input_left_shift to produce an\</span>
<span class="sd">            s1615 fixed point number</span>

<span class="sd">        :param int ring_buffer_to_input_left_shift:</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">16</span> <span class="o">-</span> <span class="p">(</span><span class="n">ring_buffer_to_input_left_shift</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__update_ring_buffer_shifts_and_weight_scales</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span>
            <span class="n">weight_scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Update the ring buffer shifts and weight scales for this vertex</span>

<span class="sd">        :param ~pacman.model.graphs.machine.MachineVertex machine_vertex:</span>
<span class="sd">        :param ~pacman.model.graphs.machine.MachineGraph machine_graph:</span>
<span class="sd">        :param float machine_time_step:</span>
<span class="sd">        :param float weight_scale:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_ring_buffer_to_input_left_shifts</span><span class="p">(</span>
                    <span class="n">machine_vertex</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span>
                    <span class="n">weight_scale</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weight_scales</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__get_weight_scale</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_scale</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span><span class="p">])</span>

<div class="viewcode-block" id="SynapticManager.write_data_spec"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.write_data_spec">[docs]</a>    <span class="k">def</span> <span class="nf">write_data_spec</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span>
            <span class="n">machine_graph</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">routing_info</span><span class="p">,</span> <span class="n">weight_scale</span><span class="p">,</span>
            <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~data_specification.DataSpecificationGenerator spec:</span>
<span class="sd">            The data specification to write to</span>
<span class="sd">        :param AbstractPopulationVertex application_vertex:</span>
<span class="sd">            The vertex owning the synapses</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice post_vertex_slice:</span>
<span class="sd">            The part of the vertex we&#39;re dealing with</span>
<span class="sd">        :param PopulationMachineVertex machine_vertex: The machine vertex</span>
<span class="sd">        :param ~pacman.model.graphs.machine.MachineGraph machine_graph:</span>
<span class="sd">            The graph containing the machine vertex</span>
<span class="sd">        :param ~pacman.model.graphs.application.ApplicationGraph \</span>
<span class="sd">                application_graph:</span>
<span class="sd">            The graph containing the application vertex</span>
<span class="sd">        :param ~pacman.model.routing_info.RoutingInfo routing_info:</span>
<span class="sd">            How messages are routed</span>
<span class="sd">        :param float weight_scale: How to scale the weights of the synapses</span>
<span class="sd">        :param float machine_time_step:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Reserve the memory</span>
        <span class="n">in_edges</span> <span class="o">=</span> <span class="n">application_graph</span><span class="o">.</span><span class="n">get_edges_ending_at_vertex</span><span class="p">(</span>
            <span class="n">application_vertex</span><span class="p">)</span>
        <span class="n">matrices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_synaptic_matrices</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="p">)</span>
        <span class="n">all_syn_block_sz</span> <span class="o">=</span> <span class="n">matrices</span><span class="o">.</span><span class="n">synapses_size</span><span class="p">(</span><span class="n">in_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reserve_memory_regions</span><span class="p">(</span>
            <span class="n">spec</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span>
            <span class="n">machine_vertex</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__update_ring_buffer_shifts_and_weight_scales</span><span class="p">(</span>
            <span class="n">machine_vertex</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">weight_scale</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_synapse_params_region</span><span class="p">)</span>
        <span class="c1"># write the bool for deleting packets that were too late for a timer</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span><span class="p">))</span>
        <span class="c1"># Write the ring buffer shifts</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span><span class="p">)</span>

        <span class="n">gen_data</span> <span class="o">=</span> <span class="n">matrices</span><span class="o">.</span><span class="n">write_synaptic_matrix_and_master_population_table</span><span class="p">(</span>
            <span class="n">spec</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weight_scales</span><span class="p">,</span>
            <span class="n">routing_info</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">write_parameters</span><span class="p">(</span>
                <span class="n">spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synapse_dynamics_region</span><span class="p">,</span>
                <span class="n">machine_time_step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weight_scales</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="p">,</span>
                          <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">write_structural_parameters</span><span class="p">(</span>
                    <span class="n">spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_struct_dynamics_region</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__weight_scales</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span>
                    <span class="n">routing_info</span><span class="p">,</span> <span class="n">matrices</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_write_on_machine_data_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">gen_data</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_write_on_machine_data_spec</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">generator_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write the data spec for the synapse expander</span>

<span class="sd">        :param ~.DataSpecificationGenerator spec:</span>
<span class="sd">            The specification to write to</span>
<span class="sd">        :param ~pacman.model.common.Slice post_vertex_slice:</span>
<span class="sd">            The slice of the vertex being written</span>
<span class="sd">        :param list(GeneratorData) generator_data:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">generator_data</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">n_bytes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">SYNAPSES_BASE_GENERATOR_SDRAM_USAGE_IN_BYTES</span> <span class="o">+</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span> <span class="o">*</span> <span class="n">DataType</span><span class="o">.</span><span class="n">U3232</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">generator_data</span><span class="p">:</span>
            <span class="n">n_bytes</span> <span class="o">+=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>

        <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
            <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_connector_builder_region</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="n">n_bytes</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ConnectorBuilderRegion&quot;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connector_builder_region</span><span class="p">)</span>

        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">generator_data</span><span class="p">))</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">get_n_bits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">))</span>
        <span class="n">n_neuron_id_bits</span> <span class="o">=</span> <span class="n">get_n_bits</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">n_neuron_id_bits</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weight_scales</span><span class="p">:</span>
            <span class="c1"># if the weights are high enough and the population size large</span>
            <span class="c1"># enough, then weight_scales &lt; 1 will result in a zero scale</span>
            <span class="c1"># if converted to an int, so we use U3232 here instead (as there</span>
            <span class="c1"># can be scales larger than U1616.max in conductance-based models)</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">DataType</span><span class="o">.</span><span class="n">U3232</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">dtype</span><span class="o">.</span><span class="n">max</span><span class="p">),</span> <span class="n">data_type</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">generator_data</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">gen_data</span><span class="p">)</span>

<div class="viewcode-block" id="SynapticManager.get_connections_from_machine"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.get_connections_from_machine">[docs]</a>    <span class="k">def</span> <span class="nf">get_connections_from_machine</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read the connections from the machine for a given projection</span>

<span class="sd">        :param ~spinnman.transciever.Transceiver transceiver:</span>
<span class="sd">            Used to read the data from the machine</span>
<span class="sd">        :param ~pacman.model.placements.Placements placements:</span>
<span class="sd">            Where the vertices are on the machine</span>
<span class="sd">        :param ProjectionApplicationEdge app_edge:</span>
<span class="sd">            The application edge of the projection</span>
<span class="sd">        :param SynapseInformation synapse_info:</span>
<span class="sd">            The synapse information of the projection</span>
<span class="sd">        :return: The connections from the machine, with dtype</span>
<span class="sd">            AbstractSynapseDynamics.NUMPY_CONNECTORS_DTYPE</span>
<span class="sd">        :rtype: ~numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">post_vertices</span> <span class="o">=</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">post_vertex</span><span class="o">.</span><span class="n">machine_vertices</span>

        <span class="c1"># Start with something in the list so that concatenate works</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">AbstractSynapseDynamics</span><span class="o">.</span><span class="n">NUMPY_CONNECTORS_DTYPE</span><span class="p">)]</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="n">ProgressBar</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">post_vertices</span><span class="p">),</span>
            <span class="s2">&quot;Getting synaptic data between </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">post_vertex</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">post_vertex</span> <span class="ow">in</span> <span class="n">progress</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">post_vertices</span><span class="p">):</span>
            <span class="n">post_slice</span> <span class="o">=</span> <span class="n">post_vertex</span><span class="o">.</span><span class="n">vertex_slice</span>
            <span class="n">placement</span> <span class="o">=</span> <span class="n">placements</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span><span class="n">post_vertex</span><span class="p">)</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_synaptic_matrices</span><span class="p">(</span><span class="n">post_slice</span><span class="p">)</span>
            <span class="n">connections</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">get_connections_from_machine</span><span class="p">(</span>
                <span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">connections</span><span class="p">)</span></div>

<div class="viewcode-block" id="SynapticManager.gen_on_machine"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.gen_on_machine">[docs]</a>    <span class="k">def</span> <span class="nf">gen_on_machine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; True if the synapses should be generated on the machine</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice post_vertex_slice:</span>
<span class="sd">            The slice of the vertex to determine the generation status of</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_synaptic_matrices</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">matrices</span><span class="o">.</span><span class="n">gen_on_machine</span></div>

<div class="viewcode-block" id="SynapticManager.reset_ring_buffer_shifts"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.reset_ring_buffer_shifts">[docs]</a>    <span class="k">def</span> <span class="nf">reset_ring_buffer_shifts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset the ring buffer shifts; needed if projection data changes</span>
<span class="sd">            between runs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__weight_scales</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="SynapticManager.clear_connection_cache"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.clear_connection_cache">[docs]</a>    <span class="k">def</span> <span class="nf">clear_connection_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Flush the cache of connection information; needed for a second run</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">matrices</span> <span class="ow">in</span> <span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__synaptic_matrices</span><span class="p">):</span>
            <span class="n">matrices</span><span class="o">.</span><span class="n">clear_connection_cache</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">changes_during_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Whether the synapses being managed change during running.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">changes_during_run</span>

<div class="viewcode-block" id="SynapticManager.read_generated_connection_holders"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.read_generated_connection_holders">[docs]</a>    <span class="k">def</span> <span class="nf">read_generated_connection_holders</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Fill in any pre-run connection holders for data which is generated</span>
<span class="sd">            on the machine, after it has been generated</span>

<span class="sd">        :param ~spinnman.transceiver.Transceiver transceiver:</span>
<span class="sd">            How to read the data from the machine</span>
<span class="sd">        :param ~pacman.model.placements.Placement placement:</span>
<span class="sd">            where the data is to be read from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_synaptic_matrices</span><span class="p">(</span><span class="n">placement</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">vertex_slice</span><span class="p">)</span>
        <span class="n">matrices</span><span class="o">.</span><span class="n">read_generated_connection_holders</span><span class="p">(</span><span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">)</span></div>

<div class="viewcode-block" id="SynapticManager.clear_all_caches"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.clear_all_caches">[docs]</a>    <span class="k">def</span> <span class="nf">clear_all_caches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Clears all cached data in the case that a reset requires remapping</span>
<span class="sd">            which might change things</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Clear the local caches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_connection_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_ring_buffer_shifts</span><span class="p">()</span>

        <span class="c1"># We can simply reset this dict to reset everything downstream</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synaptic_matrices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">sPyNNaker  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spynnaker.pyNN.models.neuron.synaptic_manager</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-2017.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.1.
    </div>
  </body>
</html>