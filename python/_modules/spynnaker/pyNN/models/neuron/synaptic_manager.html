<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>spynnaker.pyNN.models.neuron.synaptic_manager &#8212; sPyNNaker  documentation</title>
    
    <link rel="stylesheet" href="../../../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">sPyNNaker  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for spynnaker.pyNN.models.neuron.synaptic_manager</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2017-2019 The University of Manchester</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">special</span>  <span class="c1"># @UnresolvedImport</span>
<span class="kn">from</span> <span class="nn">data_specification.enums</span> <span class="kn">import</span> <span class="n">DataType</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.helpful_functions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">locate_memory_region_for_placement</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BYTES_PER_WORD</span><span class="p">,</span> <span class="n">MICRO_TO_SECOND_CONVERSION</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neuron.generator_data</span> <span class="kn">import</span> <span class="n">GeneratorData</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neural_projections.connectors</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AbstractGenerateConnectorOnMachine</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neural_projections</span> <span class="kn">import</span> <span class="n">ProjectionApplicationEdge</span>
<span class="kn">from</span> <span class="nn">.synapse_dynamics</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">,</span>
    <span class="n">AbstractGenerateOnMachine</span><span class="p">,</span> <span class="n">SynapseDynamicsStructuralSTDP</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neuron.synapse_io</span> <span class="kn">import</span> <span class="n">SynapseIORowBased</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.spike_source.spike_source_poisson_vertex</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">SpikeSourcePoissonVertex</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.utility_models.delays</span> <span class="kn">import</span> <span class="n">DelayExtensionVertex</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">POPULATION_BASED_REGIONS</span><span class="p">,</span> <span class="n">POSSION_SIGMA_SUMMATION_LIMIT</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.utility_calls</span> <span class="kn">import</span> <span class="p">(</span><span class="n">get_n_bits</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.running_stats</span> <span class="kn">import</span> <span class="n">RunningStats</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neuron.master_pop_table</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">MasterPopTableAsBinarySearch</span><span class="p">)</span>

<span class="n">TIME_STAMP_BYTES</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span>

<span class="c1"># TODO: Make sure these values are correct (particularly CPU cycles)</span>
<span class="n">_SYNAPSES_BASE_DTCM_USAGE_IN_BYTES</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>

<span class="c1"># 1 for drop late packets.</span>
<span class="n">_SYNAPSES_BASE_SDRAM_USAGE_IN_BYTES</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
<span class="n">_SYNAPSES_BASE_N_CPU_CYCLES_PER_NEURON</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">_SYNAPSES_BASE_N_CPU_CYCLES</span> <span class="o">=</span> <span class="mi">8</span>

<span class="c1"># 4 for n_edges</span>
<span class="c1"># 8 for post_vertex_slice.lo_atom, post_vertex_slice.n_atoms</span>
<span class="c1"># 4 for n_synapse_types</span>
<span class="c1"># 4 for n_synapse_type_bits</span>
<span class="c1"># 4 for n_synapse_index_bits</span>
<span class="n">_SYNAPSES_BASE_GENERATOR_SDRAM_USAGE_IN_BYTES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>

<span class="c1"># Amount to scale synapse SDRAM estimate by to make sure the synapses fit</span>
<span class="n">_SYNAPSE_SDRAM_OVERSCALE</span> <span class="o">=</span> <span class="mf">1.1</span>

<span class="n">_ONE_WORD</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">Struct</span><span class="p">(</span><span class="s2">&quot;&lt;I&quot;</span><span class="p">)</span>

<span class="c1"># Information about a connector to be generated on machine</span>
<span class="n">_Gen</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span>
    <span class="s2">&quot;_Gen&quot;</span><span class="p">,</span> <span class="s2">&quot;synapse_info, pre_slices, pre_slice, pre_index, app_edge, rinfo&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="SynapticManager"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager">[docs]</a><span class="k">class</span> <span class="nc">SynapticManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Deals with synapses</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=too-many-arguments, too-many-locals</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;__delay_key_index&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__n_synapse_types&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__one_to_one_connection_dtcm_max_bytes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__poptable_type&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__pre_run_connection_holders&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__retrieved_blocks&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__ring_buffer_sigma&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__spikes_per_second&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__synapse_dynamics&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__synapse_io&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__weight_scales&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__ring_buffer_shifts&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__gen_on_machine&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__max_row_info&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__synapse_indices&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__drop_late_spikes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_host_generated_block_addr&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_on_chip_generated_block_addr&quot;</span><span class="p">,</span>
        <span class="c1"># Overridable (for testing only) region IDs</span>
        <span class="s2">&quot;_synapse_params_region&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_pop_table_region&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_synaptic_matrix_region&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_synapse_dynamics_region&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_struct_dynamics_region&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_connector_builder_region&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_direct_matrix_region&quot;</span><span class="p">]</span>

    <span class="c1"># TODO make this right</span>
    <span class="n">FUDGE</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># 1. address of direct addresses, 2. size of direct addresses matrix size</span>
    <span class="n">STATIC_SYNAPSE_MATRIX_SDRAM_IN_BYTES</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_synapse_types</span><span class="p">,</span> <span class="n">ring_buffer_sigma</span><span class="p">,</span> <span class="n">spikes_per_second</span><span class="p">,</span>
                 <span class="n">config</span><span class="p">,</span> <span class="n">drop_late_spikes</span><span class="p">,</span> <span class="n">population_table_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">synapse_io</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int n_synapse_types:</span>
<span class="sd">            number of synapse types on a neuron (e.g., 2 for excitatory and</span>
<span class="sd">            inhibitory)</span>
<span class="sd">        :param ring_buffer_sigma:</span>
<span class="sd">            How many SD above the mean to go for upper bound; a</span>
<span class="sd">            good starting choice is 5.0. Given length of simulation we can</span>
<span class="sd">            set this for approximate number of saturation events.</span>
<span class="sd">        :type ring_buffer_sigma: float or None</span>
<span class="sd">        :param spikes_per_second: Estimated spikes per second</span>
<span class="sd">        :type spikes_per_second: float or None</span>
<span class="sd">        :param ~configparser.RawConfigParser config: The system configuration</span>
<span class="sd">        :param population_table_type:</span>
<span class="sd">            What type of master population table is used</span>
<span class="sd">        :type population_table_type: MasterPopTableAsBinarySearch or None</span>
<span class="sd">        :param synapse_io: How IO for synapses is performed</span>
<span class="sd">        :type synapse_io: SynapseIORowBased or None</span>
<span class="sd">        :param bool drop_late_spikes: control flag for dropping late packets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span> <span class="o">=</span> <span class="n">n_synapse_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="o">=</span> <span class="n">ring_buffer_sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">=</span> <span class="n">spikes_per_second</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span> <span class="o">=</span> <span class="n">drop_late_spikes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synapse_params_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPSE_PARAMS</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pop_table_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">POPULATION_TABLE</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synaptic_matrix_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPTIC_MATRIX</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synapse_dynamics_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPSE_DYNAMICS</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_struct_dynamics_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">STRUCTURAL_DYNAMICS</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connector_builder_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">CONNECTOR_BUILDER</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_direct_matrix_region</span> <span class="o">=</span> \
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">DIRECT_MATRIX</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Get the type of population table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span> <span class="o">=</span> <span class="n">population_table_type</span>
        <span class="k">if</span> <span class="n">population_table_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span> <span class="o">=</span> <span class="n">MasterPopTableAsBinarySearch</span><span class="p">()</span>

        <span class="c1"># Get the synapse IO</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span> <span class="o">=</span> <span class="n">synapse_io</span>
        <span class="k">if</span> <span class="n">synapse_io</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span> <span class="o">=</span> <span class="n">SynapseIORowBased</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span>
                <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;ring_buffer_sigma&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span>
                <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;spikes_per_second&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span>
                <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;drop_late_spikes&quot;</span><span class="p">)</span>

        <span class="c1"># Prepare for dealing with STDP - there can only be one (non-static)</span>
        <span class="c1"># synapse dynamics per vertex at present</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Keep the details once computed to allow reading back</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__weight_scales</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__delay_key_index</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__retrieved_blocks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># A list of connection holders to be filled in pre-run, indexed by</span>
        <span class="c1"># the edge the connection is for</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__pre_run_connection_holders</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># Limit the DTCM used by one-to-one connections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__one_to_one_connection_dtcm_max_bytes</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span>
            <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;one_to_one_connection_dtcm_max_bytes&quot;</span><span class="p">)</span>

        <span class="c1"># Whether to generate on machine or not for a given vertex slice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__gen_on_machine</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># A map of synapse information to maximum row / delayed row length and</span>
        <span class="c1"># size in bytes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_row_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># A map of synapse information for each machine pre vertex to index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Track writes inside the synaptic matrix region (to meet sizes):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_host_generated_block_addr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_on_chip_generated_block_addr</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">host_written_matrix_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_host_generated_block_addr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">on_chip_written_matrix_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_on_chip_generated_block_addr</span> <span class="o">-</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_host_generated_block_addr</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Settable.</span>

<span class="sd">        :rtype: AbstractSynapseDynamics or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">drop_late_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__combine_structural_stdp_dynamics</span><span class="p">(</span><span class="n">structural</span><span class="p">,</span> <span class="n">stdp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param AbstractSynapseDynamicsStructural structural:</span>
<span class="sd">        :param SynapseDynamicsSTDP stdp:</span>
<span class="sd">        :rtype: SynapseDynamicsStructuralSTDP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SynapseDynamicsStructuralSTDP</span><span class="p">(</span>
            <span class="n">structural</span><span class="o">.</span><span class="n">partner_selection</span><span class="p">,</span> <span class="n">structural</span><span class="o">.</span><span class="n">formation</span><span class="p">,</span>
            <span class="n">structural</span><span class="o">.</span><span class="n">elimination</span><span class="p">,</span>
            <span class="n">stdp</span><span class="o">.</span><span class="n">timing_dependence</span><span class="p">,</span> <span class="n">stdp</span><span class="o">.</span><span class="n">weight_dependence</span><span class="p">,</span>
            <span class="c1"># voltage dependence is not supported</span>
            <span class="kc">None</span><span class="p">,</span> <span class="n">stdp</span><span class="o">.</span><span class="n">dendritic_delay_fraction</span><span class="p">,</span>
            <span class="n">structural</span><span class="o">.</span><span class="n">f_rew</span><span class="p">,</span> <span class="n">structural</span><span class="o">.</span><span class="n">initial_weight</span><span class="p">,</span>
            <span class="n">structural</span><span class="o">.</span><span class="n">initial_delay</span><span class="p">,</span> <span class="n">structural</span><span class="o">.</span><span class="n">s_max</span><span class="p">,</span> <span class="n">structural</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

    <span class="nd">@synapse_dynamics</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">synapse_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synapse_dynamics</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="o">=</span> <span class="n">synapse_dynamics</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">synapse_dynamics</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ring_buffer_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Settable.</span>

<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span>

    <span class="nd">@ring_buffer_sigma</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ring_buffer_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring_buffer_sigma</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="o">=</span> <span class="n">ring_buffer_sigma</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spikes_per_second</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Settable.</span>

<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span>

    <span class="nd">@spikes_per_second</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">spikes_per_second</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spikes_per_second</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">=</span> <span class="n">spikes_per_second</span>

<div class="viewcode-block" id="SynapticManager.get_maximum_delay_supported_in_ms"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.get_maximum_delay_supported_in_ms">[docs]</a>    <span class="k">def</span> <span class="nf">get_maximum_delay_supported_in_ms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: int or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span><span class="o">.</span><span class="n">get_maximum_delay_supported_in_ms</span><span class="p">(</span>
            <span class="n">machine_time_step</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vertex_executable_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The suffix of the executable name due to the type of synapses \</span>
<span class="sd">            in use.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">get_vertex_executable_suffix</span><span class="p">()</span>

<div class="viewcode-block" id="SynapticManager.add_pre_run_connection_holder"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.add_pre_run_connection_holder">[docs]</a>    <span class="k">def</span> <span class="nf">add_pre_run_connection_holder</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">connection_holder</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ConnectionHolder connection_holder:</span>
<span class="sd">        :param ProjectionApplicationEdge edge:</span>
<span class="sd">        :param SynapseInformation synapse_info:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__pre_run_connection_holders</span><span class="p">[</span><span class="n">edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">connection_holder</span><span class="p">)</span></div>

<div class="viewcode-block" id="SynapticManager.get_connection_holders"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.get_connection_holders">[docs]</a>    <span class="k">def</span> <span class="nf">get_connection_holders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: dict(tuple(ProjectionApplicationEdge,SynapseInformation),\</span>
<span class="sd">            ConnectionHolder)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pre_run_connection_holders</span></div>

<div class="viewcode-block" id="SynapticManager.get_n_cpu_cycles"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.get_n_cpu_cycles">[docs]</a>    <span class="k">def</span> <span class="nf">get_n_cpu_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Calculate this correctly</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">FUDGE</span></div>

<div class="viewcode-block" id="SynapticManager.get_dtcm_usage_in_bytes"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.get_dtcm_usage_in_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">get_dtcm_usage_in_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Calculate this correctly</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">FUDGE</span></div>

    <span class="k">def</span> <span class="nf">_get_synapse_params_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_SYNAPSES_BASE_SDRAM_USAGE_IN_BYTES</span> <span class="o">+</span>
                <span class="p">(</span><span class="n">BYTES_PER_WORD</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_static_synaptic_matrix_sdram_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 4 for address of direct addresses, and</span>
        <span class="c1"># 4 for the size of the direct addresses matrix in bytes</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">STATIC_SYNAPSE_MATRIX_SDRAM_IN_BYTES</span>

    <span class="k">def</span> <span class="nf">__get_max_row_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span>
            <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the maximum size of each row for a given slice of the vertex</span>

<span class="sd">        :param SynapseInformation synapse_info:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice post_vertex_slice:</span>
<span class="sd">        :param ProjectionApplicationEdge app_edge:</span>
<span class="sd">        :param int machine_time_step:</span>
<span class="sd">        :rtype: MaxRowInfo</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_row_info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__max_row_info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span><span class="o">.</span><span class="n">get_max_row_info</span><span class="p">(</span>
                <span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
                <span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="p">,</span>
                <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_row_info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_synaptic_blocks_size</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">in_edges</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the size of the synaptic blocks in bytes</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice post_vertex_slice:</span>
<span class="sd">        :param list(.ApplicationEdge) in_edges:</span>
<span class="sd">        :param int machine_time_step:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memory_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_static_synaptic_matrix_sdram_requirements</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">in_edge</span> <span class="ow">in</span> <span class="n">in_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_edge</span><span class="p">,</span> <span class="n">ProjectionApplicationEdge</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">synapse_info</span> <span class="ow">in</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">synapse_information</span><span class="p">:</span>
                    <span class="n">memory_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add_synapse_size</span><span class="p">(</span>
                        <span class="n">memory_size</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">in_edge</span><span class="p">,</span>
                        <span class="n">machine_time_step</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">memory_size</span> <span class="o">*</span> <span class="n">_SYNAPSE_SDRAM_OVERSCALE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add_synapse_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memory_size</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
                           <span class="n">in_edge</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int memory_size:</span>
<span class="sd">        :param SynapseInformation synapse_info:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice post_vertex_slice:</span>
<span class="sd">        :param ProjectionApplicationEdge in_edge:</span>
<span class="sd">        :param int machine_time_step:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_row_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_max_row_info</span><span class="p">(</span>
            <span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">in_edge</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">)</span>
        <span class="n">n_atoms</span> <span class="o">=</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">n_atoms</span>
        <span class="n">memory_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_next_allowed_address</span><span class="p">(</span>
            <span class="n">memory_size</span><span class="p">)</span>
        <span class="n">memory_size</span> <span class="o">+=</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_bytes</span> <span class="o">*</span> <span class="n">n_atoms</span>
        <span class="n">memory_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_next_allowed_address</span><span class="p">(</span>
            <span class="n">memory_size</span><span class="p">)</span>
        <span class="n">memory_size</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_bytes</span> <span class="o">*</span> <span class="n">n_atoms</span> <span class="o">*</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">n_delay_stages</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">memory_size</span>

    <span class="k">def</span> <span class="nf">_get_size_of_generator_information</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the size of the synaptic expander parameters</span>

<span class="sd">        :param list(.ApplicationEdge) in_edges:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gen_on_machine</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">in_edge</span> <span class="ow">in</span> <span class="n">in_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_edge</span><span class="p">,</span> <span class="n">ProjectionApplicationEdge</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">synapse_info</span> <span class="ow">in</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">synapse_information</span><span class="p">:</span>
                <span class="c1"># Get the number of likely vertices</span>
                <span class="n">max_atoms</span> <span class="o">=</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">get_max_atoms_per_core</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">&lt;</span> <span class="n">max_atoms</span><span class="p">:</span>
                    <span class="n">max_atoms</span> <span class="o">=</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">n_atoms</span>
                <span class="n">n_edge_vertices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">in_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_atoms</span><span class="p">)))</span>

                <span class="c1"># Get the size</span>
                <span class="k">if</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">may_generate_on_machine</span><span class="p">():</span>
                    <span class="n">gen_on_machine</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">connector</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">connector</span>
                    <span class="n">dynamics</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">synapse_dynamics</span>
                    <span class="n">gen_size</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span>
                        <span class="n">GeneratorData</span><span class="o">.</span><span class="n">BASE_SIZE</span><span class="p">,</span>
                        <span class="n">connector</span><span class="o">.</span><span class="n">gen_delay_params_size_in_bytes</span><span class="p">(</span>
                            <span class="n">synapse_info</span><span class="o">.</span><span class="n">delays</span><span class="p">),</span>
                        <span class="n">connector</span><span class="o">.</span><span class="n">gen_weight_params_size_in_bytes</span><span class="p">(</span>
                            <span class="n">synapse_info</span><span class="o">.</span><span class="n">weights</span><span class="p">),</span>
                        <span class="n">connector</span><span class="o">.</span><span class="n">gen_connector_params_size_in_bytes</span><span class="p">,</span>
                        <span class="n">dynamics</span><span class="o">.</span><span class="n">gen_matrix_params_size_in_bytes</span>
                    <span class="p">))</span>
                    <span class="n">size</span> <span class="o">+=</span> <span class="n">gen_size</span> <span class="o">*</span> <span class="n">n_edge_vertices</span>
        <span class="k">if</span> <span class="n">gen_on_machine</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="n">_SYNAPSES_BASE_GENERATOR_SDRAM_USAGE_IN_BYTES</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
        <span class="k">return</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">_get_synapse_dynamics_parameter_size</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">app_graph</span><span class="p">,</span> <span class="n">app_vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the size of the synapse dynamics region</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :param ~.ApplicationGraph app_graph:</span>
<span class="sd">        :param ~.ApplicationVertex app_vertex:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Does the size of the parameters area depend on presynaptic</span>
        <span class="c1"># connections in any way?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="p">,</span>
                      <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span>\
                <span class="o">.</span><span class="n">get_structural_parameters_sdram_usage_in_bytes</span><span class="p">(</span>
                     <span class="n">app_graph</span><span class="p">,</span> <span class="n">app_vertex</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">get_parameters_sdram_usage_in_bytes</span><span class="p">(</span>
                <span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">)</span>

<div class="viewcode-block" id="SynapticManager.get_sdram_usage_in_bytes"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.get_sdram_usage_in_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">get_sdram_usage_in_bytes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span>
            <span class="n">app_vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :param int machine_time_step:</span>
<span class="sd">        :param ~pacman.model.graphs.application.ApplicationGraph \</span>
<span class="sd">                application_graph:</span>
<span class="sd">        :param AbstractPopulationVertex app_vertex:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">in_edges</span> <span class="o">=</span> <span class="n">application_graph</span><span class="o">.</span><span class="n">get_edges_ending_at_vertex</span><span class="p">(</span><span class="n">app_vertex</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_synapse_params_size</span><span class="p">()</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_synapse_dynamics_parameter_size</span><span class="p">(</span>
                <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">app_vertex</span><span class="p">)</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_synaptic_blocks_size</span><span class="p">(</span>
                <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">in_edges</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">)</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_master_population_table_size</span><span class="p">(</span><span class="n">in_edges</span><span class="p">)</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_size_of_generator_information</span><span class="p">(</span><span class="n">in_edges</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_reserve_memory_regions</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span>
            <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~.DataSpecificationGenerator spec:</span>
<span class="sd">        :param ~.MachineVertex machine_vertex:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :param ~.MachineGraph machine_graph:</span>
<span class="sd">        :param int all_syn_block_sz:</span>
<span class="sd">        :param ~.ApplicationGraph application_graph:</span>
<span class="sd">        :param ~.ApplicationVertex application_vertex:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
            <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_synapse_params_region</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_synapse_params_size</span><span class="p">(),</span>
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;SynapseParams&#39;</span><span class="p">)</span>

        <span class="n">master_pop_table_sz</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_exact_master_population_table_size</span><span class="p">(</span>
                <span class="n">machine_vertex</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">master_pop_table_sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_pop_table_region</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="n">master_pop_table_sz</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;PopTable&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">all_syn_block_sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_synaptic_matrix_region</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;SynBlocks&#39;</span><span class="p">)</span>

        <span class="c1"># return if not got a synapse dynamics</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">synapse_dynamics_sz</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">get_parameters_sdram_usage_in_bytes</span><span class="p">(</span>
                <span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">synapse_dynamics_sz</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_synapse_dynamics_region</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="n">synapse_dynamics_sz</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;synapseDynamicsParams&#39;</span><span class="p">)</span>

        <span class="c1"># if structural, create structural region</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="p">,</span> <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">):</span>

            <span class="n">synapse_structural_dynamics_sz</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span>
                <span class="n">get_structural_parameters_sdram_usage_in_bytes</span><span class="p">(</span>
                    <span class="n">application_graph</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">,</span>
                    <span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">synapse_structural_dynamics_sz</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                    <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_struct_dynamics_region</span><span class="p">,</span>
                    <span class="n">size</span><span class="o">=</span><span class="n">synapse_structural_dynamics_sz</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s1">&#39;synapseDynamicsStructuralParams&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_ring_buffer_expected_upper_bound</span><span class="p">(</span>
            <span class="n">weight_mean</span><span class="p">,</span> <span class="n">weight_std_dev</span><span class="p">,</span> <span class="n">spikes_per_second</span><span class="p">,</span>
            <span class="n">machine_timestep</span><span class="p">,</span> <span class="n">n_synapses_in</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Provides expected upper bound on accumulated values in a ring\</span>
<span class="sd">            buffer element.</span>

<span class="sd">        Requires an assessment of maximum Poisson input rate.</span>

<span class="sd">        Assumes knowledge of mean and SD of weight distribution, fan-in\</span>
<span class="sd">        and timestep.</span>

<span class="sd">        All arguments should be assumed real values except n_synapses_in\</span>
<span class="sd">        which will be an integer.</span>

<span class="sd">        :param float weight_mean: Mean of weight distribution (in either nA or\</span>
<span class="sd">            microSiemens as required)</span>
<span class="sd">        :param float weight_std_dev: SD of weight distribution</span>
<span class="sd">        :param float spikes_per_second: Maximum expected Poisson rate in Hz</span>
<span class="sd">        :param int machine_timestep: in us</span>
<span class="sd">        :param int n_synapses_in: No of connected synapses</span>
<span class="sd">        :param float sigma: How many SD above the mean to go for upper bound;\</span>
<span class="sd">            a good starting choice is 5.0. Given length of simulation we can\</span>
<span class="sd">            set this for approximate number of saturation events.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># E[ number of spikes ] in a timestep</span>
        <span class="n">steps_per_second</span> <span class="o">=</span> <span class="n">MICRO_TO_SECOND_CONVERSION</span> <span class="o">/</span> <span class="n">machine_timestep</span>
        <span class="n">average_spikes_per_timestep</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="n">n_synapses_in</span> <span class="o">*</span> <span class="n">spikes_per_second</span><span class="p">)</span> <span class="o">/</span> <span class="n">steps_per_second</span><span class="p">)</span>

        <span class="c1"># Exact variance contribution from inherent Poisson variation</span>
        <span class="n">poisson_variance</span> <span class="o">=</span> <span class="n">average_spikes_per_timestep</span> <span class="o">*</span> <span class="p">(</span><span class="n">weight_mean</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Upper end of range for Poisson summation required below</span>
        <span class="c1"># upper_bound needs to be an integer</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span> <span class="o">+</span>
                                <span class="n">POSSION_SIGMA_SUMMATION_LIMIT</span> <span class="o">*</span>
                                <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)))</span>

        <span class="c1"># Closed-form exact solution for summation that gives the variance</span>
        <span class="c1"># contributed by weight distribution variation when modulated by</span>
        <span class="c1"># Poisson PDF.  Requires scipy.special for gamma and incomplete gamma</span>
        <span class="c1"># functions. Beware: incomplete gamma doesn&#39;t work the same as</span>
        <span class="c1"># Mathematica because (1) it&#39;s regularised and needs a further</span>
        <span class="c1"># multiplication and (2) it&#39;s actually the complement that is needed</span>
        <span class="c1"># i.e. &#39;gammaincc&#39;]</span>

        <span class="n">weight_variance</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="n">weight_std_dev</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># pylint: disable=no-member</span>
            <span class="n">lngamma</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">upper_bound</span><span class="p">)</span>
            <span class="n">gammai</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gammaincc</span><span class="p">(</span>
                <span class="mi">1</span> <span class="o">+</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">average_spikes_per_timestep</span><span class="p">)</span>

            <span class="n">big_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">upper_bound</span> <span class="o">-</span>
                         <span class="n">lngamma</span><span class="p">)</span>

            <span class="k">if</span> <span class="o">-</span><span class="mf">701.0</span> <span class="o">&lt;</span> <span class="n">big_ratio</span> <span class="o">&lt;</span> <span class="mf">701.0</span> <span class="ow">and</span> <span class="n">big_ratio</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">log_weight_variance</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="n">average_spikes_per_timestep</span> <span class="o">+</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)</span> <span class="o">+</span>
                    <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">weight_std_dev</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">gammai</span> <span class="o">-</span>
                             <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">big_ratio</span><span class="p">)))</span>
                <span class="n">weight_variance</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_weight_variance</span><span class="p">)</span>

        <span class="c1"># upper bound calculation -&gt; mean + n * SD</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">average_spikes_per_timestep</span> <span class="o">*</span> <span class="n">weight_mean</span><span class="p">)</span> <span class="o">+</span>
                <span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">poisson_variance</span> <span class="o">+</span> <span class="n">weight_variance</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_get_ring_buffer_to_input_left_shifts</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">machine_timestep</span><span class="p">,</span>
            <span class="n">weight_scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the scaling of the ring buffer to provide as much accuracy as\</span>
<span class="sd">            possible without too much overflow</span>

<span class="sd">        :param .ApplicationVertex application_vertex:</span>
<span class="sd">        :param .ApplicationGraph application_graph:</span>
<span class="sd">        :param int machine_timestep:</span>
<span class="sd">        :param float weight_scale:</span>
<span class="sd">        :rtype: list(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">weight_scale_squared</span> <span class="o">=</span> <span class="n">weight_scale</span> <span class="o">*</span> <span class="n">weight_scale</span>
        <span class="n">n_synapse_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span>
        <span class="n">running_totals</span> <span class="o">=</span> <span class="p">[</span><span class="n">RunningStats</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)]</span>
        <span class="n">delay_running_totals</span> <span class="o">=</span> <span class="p">[</span><span class="n">RunningStats</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)]</span>
        <span class="n">total_weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)</span>
        <span class="n">biggest_weight</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)</span>
        <span class="n">weights_signed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">rate_stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">RunningStats</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)]</span>
        <span class="n">steps_per_second</span> <span class="o">=</span> <span class="n">MICRO_TO_SECOND_CONVERSION</span> <span class="o">/</span> <span class="n">machine_timestep</span>

        <span class="k">for</span> <span class="n">app_edge</span> <span class="ow">in</span> <span class="n">application_graph</span><span class="o">.</span><span class="n">get_edges_ending_at_vertex</span><span class="p">(</span>
                <span class="n">application_vertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">ProjectionApplicationEdge</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">synapse_info</span> <span class="ow">in</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">synapse_information</span><span class="p">:</span>
                    <span class="n">synapse_type</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">synapse_type</span>
                    <span class="n">synapse_dynamics</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">synapse_dynamics</span>
                    <span class="n">connector</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">connector</span>

                    <span class="n">weight_mean</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">get_weight_mean</span><span class="p">(</span>
                            <span class="n">connector</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_scale</span><span class="p">)</span>
                    <span class="n">n_connections</span> <span class="o">=</span> \
                        <span class="n">connector</span><span class="o">.</span><span class="n">get_n_connections_to_post_vertex_maximum</span><span class="p">(</span>
                            <span class="n">synapse_info</span><span class="p">)</span>
                    <span class="n">weight_variance</span> <span class="o">=</span> <span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">get_weight_variance</span><span class="p">(</span>
                        <span class="n">connector</span><span class="p">,</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_scale_squared</span>
                    <span class="n">running_totals</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span>
                        <span class="n">weight_mean</span><span class="p">,</span> <span class="n">weight_variance</span><span class="p">,</span> <span class="n">n_connections</span><span class="p">)</span>

                    <span class="n">delay_variance</span> <span class="o">=</span> <span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">get_delay_variance</span><span class="p">(</span>
                        <span class="n">connector</span><span class="p">,</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">delays</span><span class="p">)</span>
                    <span class="n">delay_running_totals</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span>
                        <span class="mf">0.0</span><span class="p">,</span> <span class="n">delay_variance</span><span class="p">,</span> <span class="n">n_connections</span><span class="p">)</span>

                    <span class="n">weight_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">get_weight_maximum</span><span class="p">(</span>
                        <span class="n">connector</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_scale</span><span class="p">)</span>
                    <span class="n">biggest_weight</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                        <span class="n">biggest_weight</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">],</span> <span class="n">weight_max</span><span class="p">)</span>

                    <span class="n">spikes_per_tick</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                        <span class="mf">1.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">/</span> <span class="n">steps_per_second</span><span class="p">)</span>
                    <span class="n">spikes_per_second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">,</span>
                                  <span class="n">SpikeSourcePoissonVertex</span><span class="p">):</span>
                        <span class="n">rate</span> <span class="o">=</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">max_rate</span>
                        <span class="c1"># If non-zero rate then use it; otherwise keep default</span>
                        <span class="k">if</span> <span class="n">rate</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">spikes_per_second</span> <span class="o">=</span> <span class="n">rate</span>
                        <span class="n">spikes_per_tick</span> <span class="o">=</span> \
                            <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">max_spikes_per_ts</span><span class="p">(</span>
                                <span class="n">machine_timestep</span><span class="p">)</span>
                    <span class="n">rate_stats</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span>
                        <span class="n">spikes_per_second</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_connections</span><span class="p">)</span>
                    <span class="n">total_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">+=</span> <span class="n">spikes_per_tick</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">weight_max</span> <span class="o">*</span> <span class="n">n_connections</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">are_weights_signed</span><span class="p">():</span>
                        <span class="n">weights_signed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">max_weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">synapse_type</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">delay_running_totals</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span><span class="o">.</span><span class="n">variance</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">max_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">total_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">],</span>
                                                <span class="n">biggest_weight</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stats</span> <span class="o">=</span> <span class="n">running_totals</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span>
                <span class="n">rates</span> <span class="o">=</span> <span class="n">rate_stats</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span>
                <span class="n">max_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ring_buffer_expected_upper_bound</span><span class="p">(</span>
                        <span class="n">stats</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">standard_deviation</span><span class="p">,</span> <span class="n">rates</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
                        <span class="n">machine_timestep</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">n_items</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span><span class="p">),</span>
                    <span class="n">total_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">])</span>
                <span class="n">max_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                    <span class="n">max_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">],</span> <span class="n">biggest_weight</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">])</span>

        <span class="c1"># Convert these to powers; we could use int.bit_length() for this if</span>
        <span class="c1"># they were integers, but they aren&#39;t...</span>
        <span class="n">max_weight_powers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">0</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">max_weights</span><span class="p">)</span>

        <span class="c1"># If 2^max_weight_power equals the max weight, we have to add another</span>
        <span class="c1"># power, as range is 0 - (just under 2^max_weight_power)!</span>
        <span class="n">max_weight_powers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">w</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="k">else</span> <span class="n">w</span>
            <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">max_weight_powers</span><span class="p">,</span> <span class="n">max_weights</span><span class="p">))</span>

        <span class="c1"># If we have synapse dynamics that uses signed weights,</span>
        <span class="c1"># Add another bit of shift to prevent overflows</span>
        <span class="k">if</span> <span class="n">weights_signed</span><span class="p">:</span>
            <span class="n">max_weight_powers</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">max_weight_powers</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">max_weight_powers</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__get_weight_scale</span><span class="p">(</span><span class="n">ring_buffer_to_input_left_shift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the amount to scale the weights by to convert them from \</span>
<span class="sd">            floating point values to 16-bit fixed point numbers which can be \</span>
<span class="sd">            shifted left by ring_buffer_to_input_left_shift to produce an\</span>
<span class="sd">            s1615 fixed point number</span>

<span class="sd">        :param int ring_buffer_to_input_left_shift:</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">16</span> <span class="o">-</span> <span class="p">(</span><span class="n">ring_buffer_to_input_left_shift</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_write_synapse_parameters</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">ring_buffer_shifts</span><span class="p">,</span> <span class="n">weight_scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the ring buffer shifts and scaling factors.</span>

<span class="sd">        :param ~.DataSpecificationGenerator spec:</span>
<span class="sd">        :param ~numpy.ndarray ring_buffer_shifts:</span>
<span class="sd">        :param float weight_scale:</span>
<span class="sd">        :rtype: ~numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Write the ring buffer shifts</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_synapse_params_region</span><span class="p">)</span>

        <span class="c1"># write the bool for deleting packets that were too late for a timer</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__drop_late_spikes</span><span class="p">))</span>

        <span class="c1"># Write the ring buffer shifts</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">ring_buffer_shifts</span><span class="p">)</span>

        <span class="c1"># Return the weight scaling factors</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_weight_scale</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_scale</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ring_buffer_shifts</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_write_padding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">next_block_start_address</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~.DataSpecificationGenerator spec:</span>
<span class="sd">        :param int next_block_start_address:</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">next_block_allowed_address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span>\
            <span class="o">.</span><span class="n">get_next_allowed_address</span><span class="p">(</span><span class="n">next_block_start_address</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">next_block_allowed_address</span> <span class="o">!=</span> <span class="n">next_block_start_address</span><span class="p">:</span>

            <span class="c1"># Pad out data file with the added alignment bytes:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">comment</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Writing population table required padding</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_synaptic_matrix_region</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">set_register_value</span><span class="p">(</span>
                <span class="n">register_id</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">next_block_allowed_address</span> <span class="o">-</span> <span class="n">next_block_start_address</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_repeated_value</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="mh">0xDD</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">repeats_is_register</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">data_type</span><span class="o">=</span><span class="n">DataType</span><span class="o">.</span><span class="n">UINT8</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">next_block_allowed_address</span>
        <span class="k">return</span> <span class="n">next_block_start_address</span>

    <span class="k">def</span> <span class="nf">_write_synaptic_matrix_and_master_population_table</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span> <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span>
            <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span>
            <span class="n">routing_info</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Simultaneously generates both the master population table and</span>
<span class="sd">            the synaptic matrix.</span>

<span class="sd">        :param ~.DataSpecificationGenerator spec:</span>
<span class="sd">        :param list(~pacman.model.graphs.common.Slice) post_slices:</span>
<span class="sd">        :param int post_slice_index:</span>
<span class="sd">        :param .MachineVertex machine_vertex:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice post_vertex_slice:</span>
<span class="sd">        :param all_syn_block_sz:</span>
<span class="sd">        :param weight_scales:</span>
<span class="sd">        :param .RoutingInfo routing_info:</span>
<span class="sd">        :param .MachineGraph machine_graph:</span>
<span class="sd">        :param int machine_time_step:</span>
<span class="sd">        :rtype: list(GeneratorData)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">comment</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Writing Synaptic Matrix and Master Population Table:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Track writes inside the synaptic matrix region:</span>
        <span class="n">block_addr</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Get the edges</span>
        <span class="n">in_edges</span> <span class="o">=</span> <span class="n">machine_graph</span><span class="o">.</span><span class="n">get_edges_ending_at_vertex</span><span class="p">(</span><span class="n">machine_vertex</span><span class="p">)</span>

        <span class="c1"># Set up the master population table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">initialise_table</span><span class="p">()</span>

        <span class="c1"># Set up for single synapses - write the offset of the single synapses</span>
        <span class="c1"># initially 0</span>
        <span class="n">single_synapses</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_synaptic_matrix_region</span><span class="p">)</span>
        <span class="n">single_addr</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Store a list of synapse info to be generated on the machine</span>
        <span class="n">generate_on_machine</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># For each machine edge in the vertex, create a synaptic list</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">in_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">ProjectionApplicationEdge</span><span class="p">):</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">comment</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Writing matrix for edge:</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">edge</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>

                <span class="n">pre_vertex</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">pre_vertex</span>
                <span class="n">pre_vertex_slice</span> <span class="o">=</span> <span class="n">pre_vertex</span><span class="o">.</span><span class="n">vertex_slice</span>
                <span class="n">pre_slices</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">vertex_slices</span>

                <span class="k">for</span> <span class="n">synapse_info</span> <span class="ow">in</span> <span class="n">edge</span><span class="o">.</span><span class="n">app_edge</span><span class="o">.</span><span class="n">synapse_information</span><span class="p">:</span>
                    <span class="n">rinfo</span> <span class="o">=</span> <span class="n">routing_info</span><span class="o">.</span><span class="n">get_routing_info_for_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

                    <span class="c1"># If connector is being built on SpiNNaker,</span>
                    <span class="c1"># compute matrix sizes only</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__may_generate_on_machine</span><span class="p">(</span>
                            <span class="n">synapse_info</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span>
                            <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">app_edge</span><span class="p">):</span>
                        <span class="c1"># We will process this a little later</span>
                        <span class="n">generate_on_machine</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_Gen</span><span class="p">(</span>
                            <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_slices</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span>
                            <span class="n">pre_vertex</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">))</span>
                        <span class="n">spec</span><span class="o">.</span><span class="n">comment</span><span class="p">(</span><span class="s2">&quot;Will generate on machine&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__write_block</span><span class="p">(</span>
                        <span class="n">spec</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_slices</span><span class="p">,</span> <span class="n">pre_vertex</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                        <span class="n">post_slices</span><span class="p">,</span> <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span>
                        <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">single_synapses</span><span class="p">,</span>
                        <span class="n">weight_scales</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">,</span>
                        <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span>
                        <span class="n">machine_edge</span><span class="o">=</span><span class="n">edge</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_indices</span><span class="p">[</span>
                        <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

        <span class="c1"># Skip blocks that will be written on the machine, but add them</span>
        <span class="c1"># to the master population table</span>
        <span class="n">generator_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_host_generated_block_addr</span> <span class="o">=</span> <span class="n">block_addr</span>
        <span class="c1"># numpy.random.shuffle(order)</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">generate_on_machine</span><span class="p">:</span>
            <span class="n">block_addr</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_on_chip_data</span><span class="p">(</span>
                <span class="n">gen</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span> <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
                <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span>
                <span class="n">generator_data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_indices</span><span class="p">[</span>
                <span class="n">gen</span><span class="o">.</span><span class="n">synapse_info</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">pre_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_on_chip_generated_block_addr</span> <span class="o">=</span> <span class="n">block_addr</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">finish_master_pop_table</span><span class="p">(</span>
            <span class="n">spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pop_table_region</span><span class="p">)</span>

        <span class="c1"># Write the size and data of single synapses to the direct region</span>
        <span class="k">if</span> <span class="n">single_synapses</span><span class="p">:</span>
            <span class="n">single_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">single_synapses</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_direct_matrix_region</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">single_data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s1">&#39;DirectMatrix&#39;</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_direct_matrix_region</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">single_data</span><span class="p">)</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">single_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_direct_matrix_region</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">BYTES_PER_WORD</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;DirectMatrix&quot;</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_direct_matrix_region</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">generator_data</span>

    <span class="k">def</span> <span class="nf">__may_generate_on_machine</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">pre_slice</span><span class="p">,</span> <span class="n">post_slice</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param SynapseInformation synapse_info:</span>
<span class="sd">        :param int single_addr:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice pre_slice:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice post_slice:</span>
<span class="sd">        :param ~.ApplicationEdge app_edge:</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">connector</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">connector</span>
        <span class="n">dynamics</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">synapse_dynamics</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">AbstractGenerateConnectorOnMachine</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">connector</span><span class="o">.</span><span class="n">generate_on_machine</span><span class="p">(</span>
                <span class="n">synapse_info</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">delays</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamics</span><span class="p">,</span> <span class="n">AbstractGenerateOnMachine</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">dynamics</span><span class="o">.</span><span class="n">generate_on_machine</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">synapse_dynamics</span><span class="p">,</span> <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">)</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_direct</span><span class="p">(</span>
                <span class="n">single_addr</span><span class="p">,</span> <span class="n">connector</span><span class="p">,</span> <span class="n">pre_slice</span><span class="p">,</span> <span class="n">post_slice</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span>
                <span class="n">synapse_info</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__generate_on_chip_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span> <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
            <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">generator_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generate data for the synapse expander</span>

<span class="sd">        :param _Gen gen:</span>
<span class="sd">        :param list(.Slice) post_slices:</span>
<span class="sd">        :param int post_slice_index:</span>
<span class="sd">        :param .Slice post_vertex_slice:</span>
<span class="sd">        :param int all_syn_block_sz:</span>
<span class="sd">        :param int block_addr:</span>
<span class="sd">        :param int machine_time_step:</span>
<span class="sd">        :param list(GeneratorData) generator_data:</span>
<span class="sd">        :rtype: tuple(int,int)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the size of the matrices that will be required</span>
        <span class="n">max_row_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_max_row_info</span><span class="p">(</span>
            <span class="n">gen</span><span class="o">.</span><span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">app_edge</span><span class="p">,</span>
            <span class="n">machine_time_step</span><span class="p">)</span>

        <span class="c1"># If delay edge exists, tell this about the data too, so it can</span>
        <span class="c1"># generate its own data</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_n_synapses</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span>
                <span class="n">gen</span><span class="o">.</span><span class="n">app_edge</span><span class="o">.</span><span class="n">delay_edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">gen</span><span class="o">.</span><span class="n">app_edge</span><span class="o">.</span><span class="n">delay_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">add_generator_data</span><span class="p">(</span>
                <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_n_synapses</span><span class="p">,</span>
                <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_n_synapses</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">pre_slices</span><span class="p">,</span>
                <span class="n">gen</span><span class="o">.</span><span class="n">pre_index</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span> <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">pre_slice</span><span class="p">,</span>
                <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">synapse_info</span><span class="p">,</span>
                <span class="n">gen</span><span class="o">.</span><span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_n_synapses</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Found delayed items but no delay machine edge for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">gen</span><span class="o">.</span><span class="n">app_edge</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>

        <span class="c1"># Skip over the normal bytes but still write a master pop entry</span>
        <span class="n">synaptic_matrix_offset</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>
        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_n_synapses</span><span class="p">:</span>
            <span class="n">synaptic_matrix_offset</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_next_allowed_address</span><span class="p">(</span><span class="n">block_addr</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="n">synaptic_matrix_offset</span><span class="p">,</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_words</span><span class="p">,</span>
                <span class="n">gen</span><span class="o">.</span><span class="n">rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>
            <span class="n">n_bytes_undelayed</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_bytes</span> <span class="o">*</span> <span class="n">gen</span><span class="o">.</span><span class="n">pre_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
            <span class="n">block_addr</span> <span class="o">=</span> <span class="n">synaptic_matrix_offset</span> <span class="o">+</span> <span class="n">n_bytes_undelayed</span>

            <span class="c1"># The synaptic matrix offset is in words for the generator</span>
            <span class="n">synaptic_matrix_offset</span> <span class="o">//=</span> <span class="n">BYTES_PER_WORD</span>
        <span class="k">elif</span> <span class="n">gen</span><span class="o">.</span><span class="n">rinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">block_addr</span> <span class="o">&gt;</span> <span class="n">all_syn_block_sz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Too much synaptic memory has been written: </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">block_addr</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">))</span>

        <span class="c1"># Skip over the delayed bytes but still write a master pop entry</span>
        <span class="n">delayed_synaptic_matrix_offset</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>
        <span class="n">n_delay_stages</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">delay_rinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delay_key_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">pre_slice</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">d_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_n_synapses</span><span class="p">:</span>
            <span class="n">n_delay_stages</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span>
            <span class="n">delayed_synaptic_matrix_offset</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_next_allowed_address</span><span class="p">(</span>
                    <span class="n">block_addr</span><span class="p">)</span>
            <span class="n">d_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="n">delayed_synaptic_matrix_offset</span><span class="p">,</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_words</span><span class="p">,</span>
                <span class="n">delay_rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>
            <span class="n">n_bytes_delayed</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_bytes</span> <span class="o">*</span> <span class="n">gen</span><span class="o">.</span><span class="n">pre_slice</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">*</span>
                <span class="n">n_delay_stages</span><span class="p">)</span>
            <span class="n">block_addr</span> <span class="o">=</span> <span class="n">delayed_synaptic_matrix_offset</span> <span class="o">+</span> <span class="n">n_bytes_delayed</span>

            <span class="c1"># The delayed synaptic matrix offset is in words for the generator</span>
            <span class="n">delayed_synaptic_matrix_offset</span> <span class="o">//=</span> <span class="n">BYTES_PER_WORD</span>
        <span class="k">elif</span> <span class="n">delay_rinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delay_rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">block_addr</span> <span class="o">&gt;</span> <span class="n">all_syn_block_sz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Too much synaptic memory has been written: </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">block_addr</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">))</span>

        <span class="c1"># Get additional data for the synapse expander</span>
        <span class="n">generator_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">GeneratorData</span><span class="p">(</span>
            <span class="n">synaptic_matrix_offset</span><span class="p">,</span> <span class="n">delayed_synaptic_matrix_offset</span><span class="p">,</span>
            <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_words</span><span class="p">,</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_words</span><span class="p">,</span>
            <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_n_synapses</span><span class="p">,</span>
            <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_n_synapses</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">pre_slices</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">pre_index</span><span class="p">,</span>
            <span class="n">post_slices</span><span class="p">,</span> <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">pre_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
            <span class="n">gen</span><span class="o">.</span><span class="n">synapse_info</span><span class="p">,</span> <span class="n">n_delay_stages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__gen_on_machine</span><span class="p">[</span><span class="n">post_vertex_slice</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">d_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">d_index</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Delay index </span><span class="si">{}</span><span class="s2"> and normal index </span><span class="si">{}</span><span class="s2"> do not match&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">d_index</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">__write_block</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_slices</span><span class="p">,</span>
            <span class="n">pre_slice_index</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span> <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span>
            <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span> <span class="n">single_synapses</span><span class="p">,</span>
            <span class="n">weight_scales</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">,</span>
            <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">machine_edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~.DataSpecificationGenerator spec:</span>
<span class="sd">        :param SynapseInformation synapse_info:</span>
<span class="sd">        :param list(.Slice) pre_slices:</span>
<span class="sd">        :param int pre_slice_index:</span>
<span class="sd">        :param list(.Slice) post_slices:</span>
<span class="sd">        :param int post_slice_index:</span>
<span class="sd">        :param .Slice pre_vertex_slice:</span>
<span class="sd">        :param .Slice post_vertex_slice:</span>
<span class="sd">        :param ProjectionApplicationEdge app_edge:</span>
<span class="sd">        :param list(~numpy.ndarray) single_synapses:</span>
<span class="sd">        :param dict(AbstractSynapseType,float) weight_scales:</span>
<span class="sd">        :param int machine_time_step:</span>
<span class="sd">        :param .PartitionRoutingInfo rinfo:</span>
<span class="sd">        :param int all_syn_block_sz:</span>
<span class="sd">        :param int block_addr:</span>
<span class="sd">        :param int single_addr:</span>
<span class="sd">        :param ProjectionMachineEdge machine_edge:</span>
<span class="sd">        :rtype: tuple(int,int,int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">row_data</span><span class="p">,</span> <span class="n">row_length</span><span class="p">,</span> <span class="n">delayed_row_data</span><span class="p">,</span> <span class="n">delayed_row_length</span><span class="p">,</span>
         <span class="n">delayed_source_ids</span><span class="p">,</span> <span class="n">delay_stages</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span><span class="o">.</span><span class="n">get_synapses</span><span class="p">(</span>
             <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_slices</span><span class="p">,</span> <span class="n">pre_slice_index</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span>
             <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
             <span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span>
             <span class="n">app_edge</span><span class="o">=</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">machine_edge</span><span class="o">=</span><span class="n">machine_edge</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">delay_edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">app_edge</span><span class="o">.</span><span class="n">delay_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">add_delays</span><span class="p">(</span>
                <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">delayed_source_ids</span><span class="p">,</span> <span class="n">delay_stages</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">delayed_source_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Found delayed source IDs but no delay &quot;</span>
                <span class="s2">&quot;machine edge for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">app_edge</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pre_run_connection_holders</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">conn_holder</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pre_run_connection_holders</span><span class="p">[</span>
                    <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">]:</span>
                <span class="n">conn_holder</span><span class="o">.</span><span class="n">add_connections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_synapses</span><span class="p">(</span>
                    <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
                    <span class="n">row_length</span><span class="p">,</span> <span class="n">delayed_row_length</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span>
                    <span class="n">row_data</span><span class="p">,</span> <span class="n">delayed_row_data</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">))</span>
                <span class="n">conn_holder</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>

        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">row_data</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__write_row_data</span><span class="p">(</span>
                <span class="n">spec</span><span class="p">,</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">connector</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span>
                <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">row_length</span><span class="p">,</span> <span class="n">row_data</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">,</span>
                <span class="n">single_synapses</span><span class="p">,</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span>
                <span class="n">synapse_info</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">row_data</span>

        <span class="k">if</span> <span class="n">block_addr</span> <span class="o">&gt;</span> <span class="n">all_syn_block_sz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Too much synaptic memory has been written: </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">block_addr</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">))</span>

        <span class="n">delay_rinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delay_key_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="p">(</span><span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">d_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">delayed_row_data</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">d_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__write_row_data</span><span class="p">(</span>
                <span class="n">spec</span><span class="p">,</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">connector</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span>
                <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">delayed_row_length</span><span class="p">,</span> <span class="n">delayed_row_data</span><span class="p">,</span>
                <span class="n">delay_rinfo</span><span class="p">,</span> <span class="n">single_synapses</span><span class="p">,</span>  <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span>
                <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">delay_rinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delay_rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">delayed_row_data</span>

        <span class="k">if</span> <span class="n">block_addr</span> <span class="o">&gt;</span> <span class="n">all_syn_block_sz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Too much synaptic memory has been written: </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">block_addr</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">d_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">d_index</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Delay index </span><span class="si">{}</span><span class="s2"> and normal index </span><span class="si">{}</span><span class="s2"> do not match&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">d_index</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">__is_direct</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">connector</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
            <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Determine if the given connection can be done with a &quot;direct&quot;\</span>
<span class="sd">            synaptic matrix - this must have an exactly 1 entry per row</span>

<span class="sd">        :param int single_addr:</span>
<span class="sd">        :param AbstractConnector connector:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice pre_vertex_slice:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice post_vertex_slice:</span>
<span class="sd">        :param ProjectionApplicationEdge app_edge:</span>
<span class="sd">        :param SynapseInformation synapse_info:</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
            <span class="n">connector</span><span class="o">.</span><span class="n">use_direct_matrix</span><span class="p">(</span><span class="n">synapse_info</span><span class="p">)</span> <span class="ow">and</span>
            <span class="p">(</span><span class="n">single_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">)</span> <span class="o">&lt;=</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__one_to_one_connection_dtcm_max_bytes</span><span class="p">)</span> <span class="ow">and</span>
            <span class="p">(</span><span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span> <span class="o">==</span> <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">)</span> <span class="ow">and</span>
            <span class="p">(</span><span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span> <span class="o">==</span> <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__write_row_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">connector</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
            <span class="n">row_length</span><span class="p">,</span> <span class="n">row_data</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">,</span> <span class="n">single_synapses</span><span class="p">,</span>
            <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~.DataSpecificationGenerator spec:</span>
<span class="sd">        :param AbstractConnector connector:</span>
<span class="sd">        :param ~.Slice pre_vertex_slice:</span>
<span class="sd">        :param ~.Slice post_vertex_slice:</span>
<span class="sd">        :param int row_length:</span>
<span class="sd">        :param ~numpy.ndarray row_data:</span>
<span class="sd">        :param .PartitionRoutingInfo rinfo:</span>
<span class="sd">        :param list(~numpy.ndarray) single_synapses:</span>
<span class="sd">        :param int block_addr:</span>
<span class="sd">        :param int single_addr:</span>
<span class="sd">        :param ProjectionApplicationEdge app_edge:</span>
<span class="sd">        :param SynapseInfornation synapse_info:</span>
<span class="sd">        :rtype: tuple(int,int,int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">row_length</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_direct</span><span class="p">(</span>
                <span class="n">single_addr</span><span class="p">,</span> <span class="n">connector</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
                <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
            <span class="n">single_rows</span> <span class="o">=</span> <span class="n">row_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)[:,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">single_synapses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">single_rows</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="n">single_addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">,</span> <span class="n">is_single</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">single_addr</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">single_rows</span><span class="p">)</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">block_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_padding</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">block_addr</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_synaptic_matrix_region</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">row_data</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="n">block_addr</span><span class="p">,</span> <span class="n">row_length</span><span class="p">,</span> <span class="n">rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>
            <span class="n">block_addr</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_data</span><span class="p">)</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
        <span class="k">return</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">_get_ring_buffer_shifts</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span>
            <span class="n">weight_scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the ring buffer shifts for this vertex</span>

<span class="sd">        :param .ApplicationVertex application_vertex:</span>
<span class="sd">        :param .ApplicationGraph application_graph:</span>
<span class="sd">        :param int machine_time_step:</span>
<span class="sd">        :param float weight_scale:</span>
<span class="sd">        :rtype: list(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_ring_buffer_to_input_left_shifts</span><span class="p">(</span>
                    <span class="n">application_vertex</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span>
                    <span class="n">weight_scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span>

<div class="viewcode-block" id="SynapticManager.write_data_spec"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.write_data_spec">[docs]</a>    <span class="k">def</span> <span class="nf">write_data_spec</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span>
            <span class="n">placement</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">routing_info</span><span class="p">,</span>
            <span class="n">weight_scale</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~data_specification.DataSpecificationGenerator spec:</span>
<span class="sd">            The data specification to write to</span>
<span class="sd">        :param ~pacman.model.graphs.application_graph.ApplicationGraph \</span>
<span class="sd">        application_graph: the app graph</span>
<span class="sd">        :param AbstractPopulationVertex application_vertex:</span>
<span class="sd">            The vertex owning the synapses</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice post_vertex_slice:</span>
<span class="sd">            The part of the vertex we&#39;re dealing with</span>
<span class="sd">        :param PopulationMachineVertex machine_vertex: The machine vertex</span>
<span class="sd">        :param ~pacman.model.placements.Placement placement:</span>
<span class="sd">            Where the vertex is placed</span>
<span class="sd">        :param ~pacman.model.graphs.machine.MachineGraph machine_graph:</span>
<span class="sd">            The graph containing the machine vertex</span>
<span class="sd">        :param ~pacman.model.graphs.application.ApplicationGraph \</span>
<span class="sd">                application_graph:</span>
<span class="sd">            The graph containing the application vertex</span>
<span class="sd">        :param ~pacman.model.routing_info.RoutingInfo routing_info:</span>
<span class="sd">            How messages are routed</span>
<span class="sd">        :param float weight_scale: How to scale the weights of the synapses</span>
<span class="sd">        :param int machine_time_step:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># reset for this machine vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_host_generated_block_addr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_on_chip_generated_block_addr</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Create an index of delay keys into this vertex</span>
        <span class="k">for</span> <span class="n">m_edge</span> <span class="ow">in</span> <span class="n">machine_graph</span><span class="o">.</span><span class="n">get_edges_ending_at_vertex</span><span class="p">(</span><span class="n">machine_vertex</span><span class="p">):</span>
            <span class="n">app_edge</span> <span class="o">=</span> <span class="n">m_edge</span><span class="o">.</span><span class="n">app_edge</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">,</span> <span class="n">DelayExtensionVertex</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__delay_key_index</span><span class="p">[</span><span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">source_vertex</span><span class="p">,</span>
                                       <span class="n">m_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">vertex_slice</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">routing_info</span><span class="o">.</span><span class="n">get_routing_info_for_edge</span><span class="p">(</span><span class="n">m_edge</span><span class="p">)</span>

        <span class="n">post_slices</span> <span class="o">=</span> <span class="n">application_vertex</span><span class="o">.</span><span class="n">vertex_slices</span>
        <span class="n">post_slice_idx</span> <span class="o">=</span> <span class="n">machine_vertex</span><span class="o">.</span><span class="n">index</span>

        <span class="c1"># Reserve the memory</span>
        <span class="n">in_edges</span> <span class="o">=</span> <span class="n">application_graph</span><span class="o">.</span><span class="n">get_edges_ending_at_vertex</span><span class="p">(</span>
            <span class="n">application_vertex</span><span class="p">)</span>
        <span class="n">all_syn_block_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_synaptic_blocks_size</span><span class="p">(</span>
            <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">in_edges</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reserve_memory_regions</span><span class="p">(</span>
            <span class="n">spec</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span>
            <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">)</span>

        <span class="n">ring_buffer_shifts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ring_buffer_shifts</span><span class="p">(</span>
            <span class="n">application_vertex</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span>
            <span class="n">weight_scale</span><span class="p">)</span>
        <span class="n">weight_scales</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_synapse_parameters</span><span class="p">(</span>
            <span class="n">spec</span><span class="p">,</span> <span class="n">ring_buffer_shifts</span><span class="p">,</span> <span class="n">weight_scale</span><span class="p">)</span>

        <span class="n">gen_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_synaptic_matrix_and_master_population_table</span><span class="p">(</span>
            <span class="n">spec</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span> <span class="n">post_slice_idx</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span>
            <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span>
            <span class="n">routing_info</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">write_parameters</span><span class="p">(</span>
                <span class="n">spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synapse_dynamics_region</span><span class="p">,</span>
                <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="p">,</span>
                          <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">write_structural_parameters</span><span class="p">(</span>
                    <span class="n">spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_struct_dynamics_region</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span>
                    <span class="n">weight_scales</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">,</span>
                    <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">routing_info</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_indices</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__weight_scales</span><span class="p">[</span><span class="n">placement</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight_scales</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_write_on_machine_data_spec</span><span class="p">(</span>
            <span class="n">spec</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span> <span class="n">gen_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="SynapticManager.clear_connection_cache"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.clear_connection_cache">[docs]</a>    <span class="k">def</span> <span class="nf">clear_connection_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Flush the cache of connection information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__retrieved_blocks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span></div>

<div class="viewcode-block" id="SynapticManager.get_connections_from_machine"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.get_connections_from_machine">[docs]</a>    <span class="k">def</span> <span class="nf">get_connections_from_machine</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">machine_edge</span><span class="p">,</span>
            <span class="n">routing_infos</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span>
            <span class="n">using_extra_monitor_cores</span><span class="p">,</span> <span class="n">placements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">monitor_api</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">fixed_routes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~spinnman.transceiver.Transceiver transceiver:</span>
<span class="sd">            How to talk to the machine</span>
<span class="sd">        :param ~pacman.model.placements.Placement placement:</span>
<span class="sd">            Where on the machine are we talking to?</span>
<span class="sd">        :param ProjectionMachineEdge machine_edge:</span>
<span class="sd">            What edge&#39;s connections are we talking about?</span>
<span class="sd">        :param ~pacman.model.routing_info.RoutingInfo routing_infos:</span>
<span class="sd">            Where did the edge go?</span>
<span class="sd">        :param SynapseInformation synapse_info:</span>
<span class="sd">            What do we know about the edge&#39;s synapses?</span>
<span class="sd">        :param int machine_time_step: How fast the clock ticks</span>
<span class="sd">        :param bool using_extra_monitor_cores:</span>
<span class="sd">            Are we to use the fast download protocol?</span>
<span class="sd">        :param placements: Where are all the vertices?</span>
<span class="sd">            Must not be ``None`` if ``using_extra_monitor_cores`` is true.</span>
<span class="sd">        :type placements: ~pacman.model.placements.Placements or None</span>
<span class="sd">        :param monitor_api:</span>
<span class="sd">            How do we talk the fast protocol?</span>
<span class="sd">            Must not be ``None`` if ``using_extra_monitor_cores`` is true.</span>
<span class="sd">        :type monitor_api:</span>
<span class="sd">            ~spinn_front_end_common.utility_models.DataSpeedUpPacketGatherMachineVertex</span>
<span class="sd">        :param fixed_routes:</span>
<span class="sd">            What is the planned configuration of the Fixed Route packet</span>
<span class="sd">            routing?</span>
<span class="sd">            Must not be ``None`` if ``using_extra_monitor_cores`` is true.</span>
<span class="sd">        :type fixed_routes:</span>
<span class="sd">            dict(tuple(int,int),~spinn_machine.FixedRouteEntry) or None</span>
<span class="sd">        :param extra_monitor:</span>
<span class="sd">        :type extra_monitor:</span>
<span class="sd">            ~spinn_front_end_common.utility_models.ExtraMonitorSupportMachineVertex</span>
<span class="sd">        :rtype: ~numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">app_edge</span> <span class="o">=</span> <span class="n">machine_edge</span><span class="o">.</span><span class="n">app_edge</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">ProjectionApplicationEdge</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Get details for extraction</span>
        <span class="n">pre_vertex_slice</span> <span class="o">=</span> <span class="n">machine_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">vertex_slice</span>
        <span class="n">post_vertex_slice</span> <span class="o">=</span> <span class="n">machine_edge</span><span class="o">.</span><span class="n">post_vertex</span><span class="o">.</span><span class="n">vertex_slice</span>

        <span class="c1"># Get the key for the pre_vertex</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">routing_infos</span><span class="o">.</span><span class="n">get_first_key_for_edge</span><span class="p">(</span><span class="n">machine_edge</span><span class="p">)</span>

        <span class="c1"># Get the key for the delayed pre_vertex</span>
        <span class="n">delayed_key</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">delay_edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">delayed_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delay_key_index</span><span class="p">[</span>
                <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">]</span><span class="o">.</span><span class="n">first_key</span>

        <span class="c1"># Get the block for the connections from the pre_vertex</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_indices</span><span class="p">[</span><span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">]</span>
        <span class="n">master_pop_table</span><span class="p">,</span> <span class="n">direct_synapses</span><span class="p">,</span> <span class="n">indirect_synapses</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">__compute_addresses</span><span class="p">(</span><span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">)</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">max_row_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieve_synaptic_block</span><span class="p">(</span>
            <span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">master_pop_table</span><span class="p">,</span> <span class="n">indirect_synapses</span><span class="p">,</span>
            <span class="n">direct_synapses</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
            <span class="n">using_extra_monitor_cores</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span> <span class="n">monitor_api</span><span class="p">,</span>
            <span class="n">extra_monitor</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="o">=</span><span class="n">fixed_routes</span><span class="p">)</span>

        <span class="c1"># Get the block for the connections from the delayed pre_vertex</span>
        <span class="n">delayed_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">delayed_max_row_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">delayed_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">delayed_data</span><span class="p">,</span> <span class="n">delayed_max_row_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieve_synaptic_block</span><span class="p">(</span>
                <span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">master_pop_table</span><span class="p">,</span> <span class="n">indirect_synapses</span><span class="p">,</span>
                <span class="n">direct_synapses</span><span class="p">,</span> <span class="n">delayed_key</span><span class="p">,</span>
                <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">*</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span><span class="p">,</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">using_extra_monitor_cores</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span>
                <span class="n">monitor_api</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="o">=</span><span class="n">fixed_routes</span><span class="p">)</span>

        <span class="c1"># Convert the blocks into connections</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_synapses</span><span class="p">(</span>
            <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">max_row_length</span><span class="p">,</span>
            <span class="n">delayed_max_row_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weight_scales</span><span class="p">[</span><span class="n">placement</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span>
            <span class="n">delayed_data</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__compute_addresses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Helper for computing the addresses of the master pop table and\</span>
<span class="sd">            synaptic-matrix-related bits.</span>

<span class="sd">        :param ~.Transceiver transceiver:</span>
<span class="sd">        :param ~.Placement placement:</span>
<span class="sd">        :rtype: tuple(int, int, int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">master_pop_table</span> <span class="o">=</span> <span class="n">locate_memory_region_for_placement</span><span class="p">(</span>
            <span class="n">placement</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pop_table_region</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">)</span>
        <span class="n">synaptic_matrix</span> <span class="o">=</span> <span class="n">locate_memory_region_for_placement</span><span class="p">(</span>
            <span class="n">placement</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synaptic_matrix_region</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">)</span>
        <span class="n">direct_synapses</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span> <span class="o">+</span> <span class="n">locate_memory_region_for_placement</span><span class="p">(</span>
            <span class="n">placement</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direct_matrix_region</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">master_pop_table</span><span class="p">,</span> <span class="n">direct_synapses</span><span class="p">,</span> <span class="n">synaptic_matrix</span>

    <span class="k">def</span> <span class="nf">_extract_synaptic_matrix_data_location</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">master_pop_table_address</span><span class="p">,</span> <span class="n">txrx</span><span class="p">,</span> <span class="n">placement</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int key:</span>
<span class="sd">        :param int master_pop_table_address:</span>
<span class="sd">        :param ~spinnman.transceiver.Transceiver txrx:</span>
<span class="sd">        :param ~.Placement placement:</span>
<span class="sd">        :rtype: list(tuple(int, int, bool))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">extract_synaptic_matrix_data_location</span><span class="p">(</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">master_pop_table_address</span><span class="p">,</span> <span class="n">txrx</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">pre_slice</span><span class="p">,</span> <span class="n">post_slice</span><span class="p">,</span> <span class="n">max_row_length</span><span class="p">,</span>
                       <span class="n">delayed_max_row_length</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span>
                       <span class="n">data</span><span class="p">,</span> <span class="n">delayed_data</span><span class="p">,</span> <span class="n">timestep</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param SynapseInformation synapse_info:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice pre_vertex_slice:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice post_vertex_slice:</span>
<span class="sd">        :param int max_row_length:</span>
<span class="sd">        :param int delayed_max_row_length:</span>
<span class="sd">        :param dict(AbstractSynapseType,float) weight_scales:</span>
<span class="sd">        :param data:</span>
<span class="sd">        :type data: bytes or bytearray or memoryview</span>
<span class="sd">        :param delayed_data:</span>
<span class="sd">        :type delayed_data: bytes or bytearray or memoryview</span>
<span class="sd">        :param int timestep:</span>
<span class="sd">        :return: array with ``weight`` and ``delay`` columns</span>
<span class="sd">        :rtype: ~numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span><span class="o">.</span><span class="n">read_synapses</span><span class="p">(</span>
            <span class="n">info</span><span class="p">,</span> <span class="n">pre_slice</span><span class="p">,</span> <span class="n">post_slice</span><span class="p">,</span> <span class="n">max_row_length</span><span class="p">,</span>
            <span class="n">delayed_max_row_length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">delayed_data</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_retrieve_synaptic_block</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">txrx</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">master_pop_table_address</span><span class="p">,</span>
            <span class="n">indirect_synapses_address</span><span class="p">,</span> <span class="n">direct_synapses_address</span><span class="p">,</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">using_monitors</span><span class="p">,</span> <span class="n">placements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">data_receiver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read in a synaptic block from a given processor and vertex on\</span>
<span class="sd">            the machine</span>

<span class="sd">        :param ~.Transceiver txrx:</span>
<span class="sd">        :param ~.Placement placement:</span>
<span class="sd">        :param int master_pop_table_address:</span>
<span class="sd">        :param int indirect_synapses_address:</span>
<span class="sd">        :param int direct_synapses_address:</span>
<span class="sd">        :param int key:</span>
<span class="sd">        :param int n_rows:</span>
<span class="sd">        :param int index:</span>
<span class="sd">        :param bool using_monitors:</span>
<span class="sd">        :param ~.Placements placements:</span>
<span class="sd">        :param ~.DataSpeedUpPacketGatherMachineVertex data_receiver:</span>
<span class="sd">        :param ~.ExtraMonitorSupportMachineVertex extra_monitor:</span>
<span class="sd">        :param dict(tuple(int,int),~.FixedRouteEntry) fixed_routes:</span>
<span class="sd">        :rtype: tuple(bytearray, int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># See if we have already got this block</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">placement</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__retrieved_blocks</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__retrieved_blocks</span><span class="p">[</span><span class="n">placement</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>

        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_synaptic_matrix_data_location</span><span class="p">(</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">master_pop_table_address</span><span class="p">,</span> <span class="n">txrx</span><span class="p">,</span> <span class="n">placement</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>

        <span class="n">max_row_length</span><span class="p">,</span> <span class="n">synaptic_block_offset</span><span class="p">,</span> <span class="n">is_single</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">max_row_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>

        <span class="n">block</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">max_row_length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">synaptic_block_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># read in the synaptic block</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_single</span><span class="p">:</span>
                <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__read_multiple_synaptic_blocks</span><span class="p">(</span>
                    <span class="n">txrx</span><span class="p">,</span> <span class="n">data_receiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">max_row_length</span><span class="p">,</span>
                    <span class="n">indirect_synapses_address</span> <span class="o">+</span> <span class="n">synaptic_block_offset</span><span class="p">,</span>
                    <span class="n">using_monitors</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="p">,</span> <span class="n">placements</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">block</span><span class="p">,</span> <span class="n">max_row_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__read_single_synaptic_block</span><span class="p">(</span>
                    <span class="n">txrx</span><span class="p">,</span> <span class="n">data_receiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span>
                    <span class="n">direct_synapses_address</span> <span class="o">+</span> <span class="n">synaptic_block_offset</span><span class="p">,</span>
                    <span class="n">using_monitors</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="p">,</span> <span class="n">placements</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">max_row_length</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__retrieved_blocks</span><span class="p">[</span><span class="n">placement</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__read_multiple_synaptic_blocks</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">,</span> <span class="n">data_receiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span>
            <span class="n">max_row_length</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">using_monitors</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="p">,</span>
            <span class="n">fixed_routes</span><span class="p">,</span> <span class="n">placements</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read in an array of synaptic blocks.</span>

<span class="sd">        :param ~.Transceiver transceiver:</span>
<span class="sd">        :param ~.DataSpeedUpPacketGatherMachineVertex data_receiver:</span>
<span class="sd">        :param ~.Placement placement:</span>
<span class="sd">        :param int n_rows:</span>
<span class="sd">        :param int max_row_length:</span>
<span class="sd">        :param int address:</span>
<span class="sd">        :param bool using_monitors:</span>
<span class="sd">        :param ~.ExtraMonitorSupportMachineVertex extra_monitor:</span>
<span class="sd">        :param dict(tuple(int,int),~.FixedRouteEntry) fixed_routes:</span>
<span class="sd">        :param ~.Placements placements:</span>
<span class="sd">        :rtype: bytearray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># calculate the synaptic block size in bytes</span>
        <span class="n">synaptic_block_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span><span class="o">.</span><span class="n">get_block_n_bytes</span><span class="p">(</span>
            <span class="n">max_row_length</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">)</span>

        <span class="c1"># read in the synaptic block</span>
        <span class="k">if</span> <span class="n">using_monitors</span><span class="p">:</span>
            <span class="n">extra_monitor</span><span class="o">.</span><span class="n">update_transaction_id_from_machine</span><span class="p">(</span><span class="n">transceiver</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">data_receiver</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span>
                <span class="n">extra_monitor</span><span class="p">,</span>
                <span class="n">placements</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span><span class="n">extra_monitor</span><span class="p">),</span>
                <span class="n">address</span><span class="p">,</span> <span class="n">synaptic_block_size</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transceiver</span><span class="o">.</span><span class="n">read_memory</span><span class="p">(</span>
            <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">synaptic_block_size</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__read_single_synaptic_block</span><span class="p">(</span>
            <span class="n">transceiver</span><span class="p">,</span> <span class="n">data_receiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
            <span class="n">using_monitors</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="p">,</span> <span class="n">placements</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read in a single synaptic block.</span>

<span class="sd">        :param ~.Transceiver transceiver:</span>
<span class="sd">        :param ~.DataSpeedUpPacketGatherMachineVertex data_receiver:</span>
<span class="sd">        :param ~.Placement placement:</span>
<span class="sd">        :param int n_rows:</span>
<span class="sd">        :param int address:</span>
<span class="sd">        :param bool using_monitors:</span>
<span class="sd">        :param ~.ExtraMonitorSupportMachineVertex extra_monitor:</span>
<span class="sd">        :param dict(tuple(int,int),~.FixedRouteEntry) fixed_routes:</span>
<span class="sd">        :param ~.Placements placements:</span>
<span class="sd">        :rtype: tuple(bytearray, int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The data is one per row</span>
        <span class="n">synaptic_block_size</span> <span class="o">=</span> <span class="n">n_rows</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>

        <span class="c1"># read in the synaptic row data</span>
        <span class="k">if</span> <span class="n">using_monitors</span><span class="p">:</span>
            <span class="n">extra_monitor</span><span class="o">.</span><span class="n">update_transaction_id_from_machine</span><span class="p">(</span><span class="n">transceiver</span><span class="p">)</span>
            <span class="n">single_block</span> <span class="o">=</span> <span class="n">data_receiver</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span>
                <span class="n">extra_monitor</span><span class="p">,</span>
                <span class="n">placements</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span><span class="n">extra_monitor</span><span class="p">),</span>
                <span class="n">address</span><span class="p">,</span> <span class="n">synaptic_block_size</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_block</span> <span class="o">=</span> <span class="n">transceiver</span><span class="o">.</span><span class="n">read_memory</span><span class="p">(</span>
                <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">synaptic_block_size</span><span class="p">)</span>

        <span class="c1"># Convert the block into a set of rows</span>
        <span class="n">numpy_block</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">BYTES_PER_WORD</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint32&quot;</span><span class="p">)</span>
        <span class="n">numpy_block</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">single_block</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;uint32&quot;</span><span class="p">)</span>
        <span class="n">numpy_block</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">numpy_block</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()),</span> <span class="mi">1</span>

    <span class="c1"># inherited from AbstractProvidesIncomingPartitionConstraints</span>
<div class="viewcode-block" id="SynapticManager.get_incoming_partition_constraints"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.get_incoming_partition_constraints">[docs]</a>    <span class="k">def</span> <span class="nf">get_incoming_partition_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Gets the constraints due to synapses managed by this class.</span>

<span class="sd">        :return: a list of constraints</span>
<span class="sd">        :rtype: list(~pacman.model.constraints.AbstractConstraint)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_edge_constraints</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_write_on_machine_data_spec</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span> <span class="n">generator_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write the data spec for the synapse expander</span>

<span class="sd">        :param ~.DataSpecificationGenerator spec:</span>
<span class="sd">            The specification to write to</span>
<span class="sd">        :param ~pacman.model.common.Slice post_vertex_slice:</span>
<span class="sd">            The slice of the vertex being written</span>
<span class="sd">        :param weight_scales: scaling of weights on each synapse</span>
<span class="sd">        :type weight_scales: list(int or float)</span>
<span class="sd">        :param list(GeneratorData) generator_data:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">generator_data</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">n_bytes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_SYNAPSES_BASE_GENERATOR_SDRAM_USAGE_IN_BYTES</span> <span class="o">+</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">generator_data</span><span class="p">:</span>
            <span class="n">n_bytes</span> <span class="o">+=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>

        <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
            <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_connector_builder_region</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="n">n_bytes</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ConnectorBuilderRegion&quot;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connector_builder_region</span><span class="p">)</span>

        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">generator_data</span><span class="p">))</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">get_n_bits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">))</span>
        <span class="n">n_neuron_id_bits</span> <span class="o">=</span> <span class="n">get_n_bits</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">n_neuron_id_bits</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weight_scales</span><span class="p">:</span>
            <span class="c1"># if the weights are high enough and the population size large</span>
            <span class="c1"># enough, then weight_scales &lt; 1 will result in a zero scale</span>
            <span class="c1"># if converted to an int, so we use U3232 here instead (as there</span>
            <span class="c1"># can be scales larger than U1616.max in conductance-based models)</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">DataType</span><span class="o">.</span><span class="n">U3232</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">dtype</span><span class="o">.</span><span class="n">max</span><span class="p">),</span> <span class="n">data_type</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">generator_data</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">gen_data</span><span class="p">)</span>

<div class="viewcode-block" id="SynapticManager.gen_on_machine"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.gen_on_machine">[docs]</a>    <span class="k">def</span> <span class="nf">gen_on_machine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; True if the synapses should be generated on the machine</span>

<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gen_on_machine</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">vertex_slice</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SynapticManager.reset_ring_buffer_shifts"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.SynapticManager.reset_ring_buffer_shifts">[docs]</a>    <span class="k">def</span> <span class="nf">reset_ring_buffer_shifts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">changes_during_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Whether the synapses being managed change during running.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">changes_during_run</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">sPyNNaker  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>