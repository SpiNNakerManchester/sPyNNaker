<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>spynnaker.pyNN.models.neuron.synaptic_manager &#8212; sPyNNaker  documentation</title>
    
    <link rel="stylesheet" href="../../../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">sPyNNaker  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for spynnaker.pyNN.models.neuron.synaptic_manager</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2017-2019 The University of Manchester</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.constants</span> <span class="kn">import</span> \
    <span class="n">MICRO_TO_SECOND_CONVERSION</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>  <span class="c1"># @UnresolvedImport</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">special</span>  <span class="c1"># @UnresolvedImport</span>
<span class="kn">from</span> <span class="nn">pyNN.random</span> <span class="kn">import</span> <span class="n">RandomDistribution</span>
<span class="kn">from</span> <span class="nn">data_specification.enums</span> <span class="kn">import</span> <span class="n">DataType</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.helpful_functions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">locate_memory_region_for_placement</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.constants</span> <span class="kn">import</span> <span class="n">BYTES_PER_WORD</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neuron.generator_data</span> <span class="kn">import</span> <span class="n">GeneratorData</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neural_projections.connectors</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AbstractGenerateConnectorOnMachine</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neural_projections</span> <span class="kn">import</span> <span class="n">ProjectionApplicationEdge</span>
<span class="kn">from</span> <span class="nn">.synapse_dynamics</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">,</span>
    <span class="n">AbstractGenerateOnMachine</span><span class="p">,</span> <span class="n">SynapseDynamicsStructuralSTDP</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neuron.synapse_io</span> <span class="kn">import</span> <span class="n">SynapseIORowBased</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.spike_source.spike_source_poisson_vertex</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">SpikeSourcePoissonVertex</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.utility_models.delays</span> <span class="kn">import</span> <span class="n">DelayExtensionVertex</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">POPULATION_BASED_REGIONS</span><span class="p">,</span> <span class="n">POSSION_SIGMA_SUMMATION_LIMIT</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.utility_calls</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_maximum_probable_value</span><span class="p">,</span> <span class="n">get_n_bits</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.running_stats</span> <span class="kn">import</span> <span class="n">RunningStats</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.models.neuron.master_pop_table</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">MasterPopTableAsBinarySearch</span><span class="p">)</span>

<span class="n">TIME_STAMP_BYTES</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span>

<span class="c1"># TODO: Make sure these values are correct (particularly CPU cycles)</span>
<span class="n">_SYNAPSES_BASE_DTCM_USAGE_IN_BYTES</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
<span class="n">_SYNAPSES_BASE_SDRAM_USAGE_IN_BYTES</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_SYNAPSES_BASE_N_CPU_CYCLES_PER_NEURON</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">_SYNAPSES_BASE_N_CPU_CYCLES</span> <span class="o">=</span> <span class="mi">8</span>

<span class="c1"># 4 for n_edges</span>
<span class="c1"># 8 for post_vertex_slice.lo_atom, post_vertex_slice.n_atoms</span>
<span class="c1"># 4 for n_synapse_types</span>
<span class="c1"># 4 for n_synapse_type_bits</span>
<span class="c1"># 4 for n_synapse_index_bits</span>
<span class="n">_SYNAPSES_BASE_GENERATOR_SDRAM_USAGE_IN_BYTES</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>

<span class="c1"># Amount to scale synapse SDRAM estimate by to make sure the synapses fit</span>
<span class="n">_SYNAPSE_SDRAM_OVERSCALE</span> <span class="o">=</span> <span class="mf">1.1</span>

<span class="n">_ONE_WORD</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">Struct</span><span class="p">(</span><span class="s2">&quot;&lt;I&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="SynapticManager"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.synaptic_manager.SynapticManager">[docs]</a><span class="k">class</span> <span class="nc">SynapticManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Deals with synapses</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=too-many-arguments, too-many-locals</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;__delay_key_index&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__n_synapse_types&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__one_to_one_connection_dtcm_max_bytes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__poptable_type&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__pre_run_connection_holders&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__retrieved_blocks&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__ring_buffer_sigma&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__spikes_per_second&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__synapse_dynamics&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__synapse_io&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__weight_scales&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__ring_buffer_shifts&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__gen_on_machine&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__max_row_info&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__synapse_indices&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_synapse_types</span><span class="p">,</span> <span class="n">ring_buffer_sigma</span><span class="p">,</span> <span class="n">spikes_per_second</span><span class="p">,</span>
                 <span class="n">config</span><span class="p">,</span> <span class="n">population_table_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">synapse_io</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span> <span class="o">=</span> <span class="n">n_synapse_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="o">=</span> <span class="n">ring_buffer_sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">=</span> <span class="n">spikes_per_second</span>

        <span class="c1"># Get the type of population table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span> <span class="o">=</span> <span class="n">population_table_type</span>
        <span class="k">if</span> <span class="n">population_table_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span> <span class="o">=</span> <span class="n">MasterPopTableAsBinarySearch</span><span class="p">()</span>

        <span class="c1"># Get the synapse IO</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span> <span class="o">=</span> <span class="n">synapse_io</span>
        <span class="k">if</span> <span class="n">synapse_io</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span> <span class="o">=</span> <span class="n">SynapseIORowBased</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span>
                <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;ring_buffer_sigma&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span>
                <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;spikes_per_second&quot;</span><span class="p">)</span>

        <span class="c1"># Prepare for dealing with STDP - there can only be one (non-static)</span>
        <span class="c1"># synapse dynamics per vertex at present</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Keep the details once computed to allow reading back</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__weight_scales</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__delay_key_index</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__retrieved_blocks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># A list of connection holders to be filled in pre-run, indexed by</span>
        <span class="c1"># the edge the connection is for</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__pre_run_connection_holders</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># Limit the DTCM used by one-to-one connections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__one_to_one_connection_dtcm_max_bytes</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span>
            <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;one_to_one_connection_dtcm_max_bytes&quot;</span><span class="p">)</span>

        <span class="c1"># Whether to generate on machine or not for a given vertex slice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__gen_on_machine</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># A map of synapse information to maximum row / delayed row length and</span>
        <span class="c1"># size in bytes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_row_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># A map of synapse information for each machine pre vertex to index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span>

    <span class="k">def</span> <span class="nf">__combine_structural_stdp_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structural</span><span class="p">,</span> <span class="n">stdp</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SynapseDynamicsStructuralSTDP</span><span class="p">(</span>
            <span class="n">structural</span><span class="o">.</span><span class="n">partner_selection</span><span class="p">,</span> <span class="n">structural</span><span class="o">.</span><span class="n">formation</span><span class="p">,</span>
            <span class="n">structural</span><span class="o">.</span><span class="n">elimination</span><span class="p">,</span>
            <span class="n">stdp</span><span class="o">.</span><span class="n">timing_dependence</span><span class="p">,</span> <span class="n">stdp</span><span class="o">.</span><span class="n">weight_dependence</span><span class="p">,</span>
            <span class="c1"># voltage dependence is not supported</span>
            <span class="kc">None</span><span class="p">,</span> <span class="n">stdp</span><span class="o">.</span><span class="n">dendritic_delay_fraction</span><span class="p">,</span>
            <span class="n">structural</span><span class="o">.</span><span class="n">f_rew</span><span class="p">,</span> <span class="n">structural</span><span class="o">.</span><span class="n">initial_weight</span><span class="p">,</span>
            <span class="n">structural</span><span class="o">.</span><span class="n">initial_delay</span><span class="p">,</span> <span class="n">structural</span><span class="o">.</span><span class="n">s_max</span><span class="p">,</span> <span class="n">structural</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

    <span class="nd">@synapse_dynamics</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">synapse_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synapse_dynamics</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="o">=</span> <span class="n">synapse_dynamics</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">synapse_dynamics</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ring_buffer_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span>

    <span class="nd">@ring_buffer_sigma</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ring_buffer_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring_buffer_sigma</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span> <span class="o">=</span> <span class="n">ring_buffer_sigma</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spikes_per_second</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span>

    <span class="nd">@spikes_per_second</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">spikes_per_second</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spikes_per_second</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">=</span> <span class="n">spikes_per_second</span>

<div class="viewcode-block" id="SynapticManager.get_maximum_delay_supported_in_ms"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.synaptic_manager.SynapticManager.get_maximum_delay_supported_in_ms">[docs]</a>    <span class="k">def</span> <span class="nf">get_maximum_delay_supported_in_ms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span><span class="o">.</span><span class="n">get_maximum_delay_supported_in_ms</span><span class="p">(</span>
            <span class="n">machine_time_step</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vertex_executable_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">get_vertex_executable_suffix</span><span class="p">()</span>

<div class="viewcode-block" id="SynapticManager.add_pre_run_connection_holder"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.synaptic_manager.SynapticManager.add_pre_run_connection_holder">[docs]</a>    <span class="k">def</span> <span class="nf">add_pre_run_connection_holder</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">connection_holder</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__pre_run_connection_holders</span><span class="p">[</span><span class="n">edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">connection_holder</span><span class="p">)</span></div>

<div class="viewcode-block" id="SynapticManager.get_connection_holders"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.synaptic_manager.SynapticManager.get_connection_holders">[docs]</a>    <span class="k">def</span> <span class="nf">get_connection_holders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pre_run_connection_holders</span></div>

<div class="viewcode-block" id="SynapticManager.get_n_cpu_cycles"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.synaptic_manager.SynapticManager.get_n_cpu_cycles">[docs]</a>    <span class="k">def</span> <span class="nf">get_n_cpu_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Calculate this correctly</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SynapticManager.get_dtcm_usage_in_bytes"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.synaptic_manager.SynapticManager.get_dtcm_usage_in_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">get_dtcm_usage_in_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Calculate this correctly</span>
        <span class="k">return</span> <span class="mi">0</span></div>

    <span class="k">def</span> <span class="nf">_get_synapse_params_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_SYNAPSES_BASE_SDRAM_USAGE_IN_BYTES</span> <span class="o">+</span>
                <span class="p">(</span><span class="n">BYTES_PER_WORD</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_static_synaptic_matrix_sdram_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># 4 for address of direct addresses, and</span>
        <span class="c1"># 4 for the size of the direct addresses matrix in bytes</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>

    <span class="k">def</span> <span class="nf">__get_max_row_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span>
            <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the maximum size of each row for a given slice of the vertex</span>

<span class="sd">        :rtype: MaxRowInfo</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span>
               <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_row_info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__max_row_info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span><span class="o">.</span><span class="n">get_max_row_info</span><span class="p">(</span>
                <span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
                <span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="p">,</span>
                <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_row_info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_synaptic_blocks_size</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">in_edges</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the size of the synaptic blocks in bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memory_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_static_synaptic_matrix_sdram_requirements</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">in_edge</span> <span class="ow">in</span> <span class="n">in_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_edge</span><span class="p">,</span> <span class="n">ProjectionApplicationEdge</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">synapse_info</span> <span class="ow">in</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">synapse_information</span><span class="p">:</span>
                    <span class="n">memory_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add_synapse_size</span><span class="p">(</span>
                        <span class="n">memory_size</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">in_edge</span><span class="p">,</span>
                        <span class="n">machine_time_step</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">memory_size</span> <span class="o">*</span> <span class="n">_SYNAPSE_SDRAM_OVERSCALE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add_synapse_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memory_size</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
                           <span class="n">in_edge</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="n">max_row_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_max_row_info</span><span class="p">(</span>
            <span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">in_edge</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">)</span>
        <span class="n">n_atoms</span> <span class="o">=</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">n_atoms</span>
        <span class="n">memory_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_next_allowed_address</span><span class="p">(</span>
            <span class="n">memory_size</span><span class="p">)</span>
        <span class="n">memory_size</span> <span class="o">+=</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_bytes</span> <span class="o">*</span> <span class="n">n_atoms</span>
        <span class="n">memory_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_next_allowed_address</span><span class="p">(</span>
            <span class="n">memory_size</span><span class="p">)</span>
        <span class="n">memory_size</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_bytes</span> <span class="o">*</span> <span class="n">n_atoms</span> <span class="o">*</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">n_delay_stages</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">memory_size</span>

    <span class="k">def</span> <span class="nf">_get_size_of_generator_information</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the size of the synaptic expander parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gen_on_machine</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">in_edge</span> <span class="ow">in</span> <span class="n">in_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_edge</span><span class="p">,</span> <span class="n">ProjectionApplicationEdge</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">synapse_info</span> <span class="ow">in</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">synapse_information</span><span class="p">:</span>

                    <span class="c1"># Get the number of likely vertices</span>
                    <span class="n">max_atoms</span> <span class="o">=</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">get_max_atoms_per_core</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">&lt;</span> <span class="n">max_atoms</span><span class="p">:</span>
                        <span class="n">max_atoms</span> <span class="o">=</span> <span class="n">in_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">n_atoms</span>
                    <span class="n">n_edge_vertices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">in_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_atoms</span><span class="p">)))</span>

                    <span class="c1"># Get the size</span>
                    <span class="n">connector</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">connector</span>
                    <span class="n">dynamics</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">synapse_dynamics</span>
                    <span class="n">connector_gen</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">connector</span><span class="p">,</span> <span class="n">AbstractGenerateConnectorOnMachine</span><span class="p">)</span> <span class="ow">and</span> \
                        <span class="n">connector</span><span class="o">.</span><span class="n">generate_on_machine</span><span class="p">(</span>
                            <span class="n">synapse_info</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">delays</span><span class="p">)</span>
                    <span class="n">synapse_gen</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">dynamics</span><span class="p">,</span> <span class="n">AbstractGenerateOnMachine</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">connector_gen</span> <span class="ow">and</span> <span class="n">synapse_gen</span><span class="p">:</span>
                        <span class="n">gen_on_machine</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">gen_size</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span>
                            <span class="n">GeneratorData</span><span class="o">.</span><span class="n">BASE_SIZE</span><span class="p">,</span>
                            <span class="n">connector</span><span class="o">.</span><span class="n">gen_delay_params_size_in_bytes</span><span class="p">(</span>
                                <span class="n">synapse_info</span><span class="o">.</span><span class="n">delays</span><span class="p">),</span>
                            <span class="n">connector</span><span class="o">.</span><span class="n">gen_weight_params_size_in_bytes</span><span class="p">(</span>
                                <span class="n">synapse_info</span><span class="o">.</span><span class="n">weights</span><span class="p">),</span>
                            <span class="n">connector</span><span class="o">.</span><span class="n">gen_connector_params_size_in_bytes</span><span class="p">,</span>
                            <span class="n">dynamics</span><span class="o">.</span><span class="n">gen_matrix_params_size_in_bytes</span>
                        <span class="p">))</span>
                        <span class="n">size</span> <span class="o">+=</span> <span class="n">gen_size</span> <span class="o">*</span> <span class="n">n_edge_vertices</span>
        <span class="k">if</span> <span class="n">gen_on_machine</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="n">_SYNAPSES_BASE_GENERATOR_SDRAM_USAGE_IN_BYTES</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
        <span class="k">return</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">_get_synapse_dynamics_parameter_size</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">app_vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the size of the synapse dynamics region</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Does the size of the parameters area depend on presynaptic</span>
        <span class="c1"># connections in any way?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="p">,</span>
                      <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span>\
                <span class="o">.</span><span class="n">get_structural_parameters_sdram_usage_in_bytes</span><span class="p">(</span>
                     <span class="n">application_graph</span><span class="p">,</span> <span class="n">app_vertex</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">get_parameters_sdram_usage_in_bytes</span><span class="p">(</span>
                <span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">)</span>

<div class="viewcode-block" id="SynapticManager.get_sdram_usage_in_bytes"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.synaptic_manager.SynapticManager.get_sdram_usage_in_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">get_sdram_usage_in_bytes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span>
            <span class="n">app_vertex</span><span class="p">):</span>
        <span class="n">in_edges</span> <span class="o">=</span> <span class="n">application_graph</span><span class="o">.</span><span class="n">get_edges_ending_at_vertex</span><span class="p">(</span><span class="n">app_vertex</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_synapse_params_size</span><span class="p">()</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_synapse_dynamics_parameter_size</span><span class="p">(</span>
                <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">app_vertex</span><span class="p">)</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_synaptic_blocks_size</span><span class="p">(</span>
                <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">in_edges</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">)</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_master_population_table_size</span><span class="p">(</span><span class="n">in_edges</span><span class="p">)</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_size_of_generator_information</span><span class="p">(</span><span class="n">in_edges</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_reserve_memory_regions</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span>
            <span class="n">machine_graph</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">graph_mapper</span><span class="p">,</span>
            <span class="n">application_graph</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">):</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
            <span class="n">region</span><span class="o">=</span><span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPSE_PARAMS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_synapse_params_size</span><span class="p">(),</span>
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;SynapseParams&#39;</span><span class="p">)</span>

        <span class="n">master_pop_table_sz</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_exact_master_population_table_size</span><span class="p">(</span>
                <span class="n">machine_vertex</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span> <span class="n">graph_mapper</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">master_pop_table_sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                <span class="n">region</span><span class="o">=</span><span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">POPULATION_TABLE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="n">master_pop_table_sz</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;PopTable&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">all_syn_block_sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                <span class="n">region</span><span class="o">=</span><span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPTIC_MATRIX</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;SynBlocks&#39;</span><span class="p">)</span>

        <span class="n">synapse_dynamics_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_synapse_dynamics_parameter_size</span><span class="p">(</span>
            <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">synapse_dynamics_sz</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                <span class="n">region</span><span class="o">=</span><span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPSE_DYNAMICS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="n">synapse_dynamics_sz</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;synapseDynamicsParams&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_ring_buffer_expected_upper_bound</span><span class="p">(</span>
            <span class="n">weight_mean</span><span class="p">,</span> <span class="n">weight_std_dev</span><span class="p">,</span> <span class="n">spikes_per_second</span><span class="p">,</span>
            <span class="n">machine_timestep</span><span class="p">,</span> <span class="n">n_synapses_in</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Provides expected upper bound on accumulated values in a ring\</span>
<span class="sd">            buffer element.</span>

<span class="sd">        Requires an assessment of maximum Poisson input rate.</span>

<span class="sd">        Assumes knowledge of mean and SD of weight distribution, fan-in\</span>
<span class="sd">        and timestep.</span>

<span class="sd">        All arguments should be assumed real values except n_synapses_in\</span>
<span class="sd">        which will be an integer.</span>

<span class="sd">        :param weight_mean: Mean of weight distribution (in either nA or\</span>
<span class="sd">            microSiemens as required)</span>
<span class="sd">        :param weight_std_dev: SD of weight distribution</span>
<span class="sd">        :param spikes_per_second: Maximum expected Poisson rate in Hz</span>
<span class="sd">        :param machine_timestep: in us</span>
<span class="sd">        :param n_synapses_in: No of connected synapses</span>
<span class="sd">        :param sigma: How many SD above the mean to go for upper bound; a\</span>
<span class="sd">            good starting choice is 5.0. Given length of simulation we can\</span>
<span class="sd">            set this for approximate number of saturation events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># E[ number of spikes ] in a timestep</span>
        <span class="n">steps_per_second</span> <span class="o">=</span> <span class="n">MICRO_TO_SECOND_CONVERSION</span> <span class="o">/</span> <span class="n">machine_timestep</span>
        <span class="n">average_spikes_per_timestep</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="n">n_synapses_in</span> <span class="o">*</span> <span class="n">spikes_per_second</span><span class="p">)</span> <span class="o">/</span> <span class="n">steps_per_second</span><span class="p">)</span>

        <span class="c1"># Exact variance contribution from inherent Poisson variation</span>
        <span class="n">poisson_variance</span> <span class="o">=</span> <span class="n">average_spikes_per_timestep</span> <span class="o">*</span> <span class="p">(</span><span class="n">weight_mean</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Upper end of range for Poisson summation required below</span>
        <span class="c1"># upper_bound needs to be an integer</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span> <span class="o">+</span>
                                <span class="n">POSSION_SIGMA_SUMMATION_LIMIT</span> <span class="o">*</span>
                                <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)))</span>

        <span class="c1"># Closed-form exact solution for summation that gives the variance</span>
        <span class="c1"># contributed by weight distribution variation when modulated by</span>
        <span class="c1"># Poisson PDF.  Requires scipy.special for gamma and incomplete gamma</span>
        <span class="c1"># functions. Beware: incomplete gamma doesn&#39;t work the same as</span>
        <span class="c1"># Mathematica because (1) it&#39;s regularised and needs a further</span>
        <span class="c1"># multiplication and (2) it&#39;s actually the complement that is needed</span>
        <span class="c1"># i.e. &#39;gammaincc&#39;]</span>

        <span class="n">weight_variance</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="n">weight_std_dev</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># pylint: disable=no-member</span>
            <span class="n">lngamma</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">upper_bound</span><span class="p">)</span>
            <span class="n">gammai</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gammaincc</span><span class="p">(</span>
                <span class="mi">1</span> <span class="o">+</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">average_spikes_per_timestep</span><span class="p">)</span>

            <span class="n">big_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">upper_bound</span> <span class="o">-</span>
                         <span class="n">lngamma</span><span class="p">)</span>

            <span class="k">if</span> <span class="o">-</span><span class="mf">701.0</span> <span class="o">&lt;</span> <span class="n">big_ratio</span> <span class="o">&lt;</span> <span class="mf">701.0</span> <span class="ow">and</span> <span class="n">big_ratio</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">log_weight_variance</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="n">average_spikes_per_timestep</span> <span class="o">+</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)</span> <span class="o">+</span>
                    <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">weight_std_dev</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">average_spikes_per_timestep</span><span class="p">)</span> <span class="o">*</span> <span class="n">gammai</span> <span class="o">-</span>
                             <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">big_ratio</span><span class="p">)))</span>
                <span class="n">weight_variance</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_weight_variance</span><span class="p">)</span>

        <span class="c1"># upper bound calculation -&gt; mean + n * SD</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">average_spikes_per_timestep</span> <span class="o">*</span> <span class="n">weight_mean</span><span class="p">)</span> <span class="o">+</span>
                <span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">poisson_variance</span> <span class="o">+</span> <span class="n">weight_variance</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_get_ring_buffer_to_input_left_shifts</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">machine_timestep</span><span class="p">,</span>
            <span class="n">weight_scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the scaling of the ring buffer to provide as much accuracy as\</span>
<span class="sd">            possible without too much overflow</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">weight_scale_squared</span> <span class="o">=</span> <span class="n">weight_scale</span> <span class="o">*</span> <span class="n">weight_scale</span>
        <span class="n">n_synapse_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span>
        <span class="n">running_totals</span> <span class="o">=</span> <span class="p">[</span><span class="n">RunningStats</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)]</span>
        <span class="n">delay_running_totals</span> <span class="o">=</span> <span class="p">[</span><span class="n">RunningStats</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)]</span>
        <span class="n">total_weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)</span>
        <span class="n">biggest_weight</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)</span>
        <span class="n">weights_signed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">rate_stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">RunningStats</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)]</span>
        <span class="n">steps_per_second</span> <span class="o">=</span> <span class="n">MICRO_TO_SECOND_CONVERSION</span> <span class="o">/</span> <span class="n">machine_timestep</span>

        <span class="k">for</span> <span class="n">app_edge</span> <span class="ow">in</span> <span class="n">application_graph</span><span class="o">.</span><span class="n">get_edges_ending_at_vertex</span><span class="p">(</span>
                <span class="n">application_vertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">ProjectionApplicationEdge</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">synapse_info</span> <span class="ow">in</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">synapse_information</span><span class="p">:</span>
                    <span class="n">synapse_type</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">synapse_type</span>
                    <span class="n">synapse_dynamics</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">synapse_dynamics</span>
                    <span class="n">connector</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">connector</span>

                    <span class="n">weight_mean</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">get_weight_mean</span><span class="p">(</span>
                            <span class="n">connector</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_scale</span><span class="p">)</span>
                    <span class="n">n_connections</span> <span class="o">=</span> \
                        <span class="n">connector</span><span class="o">.</span><span class="n">get_n_connections_to_post_vertex_maximum</span><span class="p">(</span>
                            <span class="n">synapse_info</span><span class="p">)</span>
                    <span class="n">weight_variance</span> <span class="o">=</span> <span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">get_weight_variance</span><span class="p">(</span>
                        <span class="n">connector</span><span class="p">,</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_scale_squared</span>
                    <span class="n">running_totals</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span>
                        <span class="n">weight_mean</span><span class="p">,</span> <span class="n">weight_variance</span><span class="p">,</span> <span class="n">n_connections</span><span class="p">)</span>

                    <span class="n">delay_variance</span> <span class="o">=</span> <span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">get_delay_variance</span><span class="p">(</span>
                        <span class="n">connector</span><span class="p">,</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">delays</span><span class="p">)</span>
                    <span class="n">delay_running_totals</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span>
                        <span class="mf">0.0</span><span class="p">,</span> <span class="n">delay_variance</span><span class="p">,</span> <span class="n">n_connections</span><span class="p">)</span>

                    <span class="n">weight_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">get_weight_maximum</span><span class="p">(</span>
                        <span class="n">connector</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_scale</span><span class="p">)</span>
                    <span class="n">biggest_weight</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                        <span class="n">biggest_weight</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">],</span> <span class="n">weight_max</span><span class="p">)</span>

                    <span class="n">spikes_per_tick</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                        <span class="mf">1.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span> <span class="o">/</span> <span class="n">steps_per_second</span><span class="p">)</span>
                    <span class="n">spikes_per_second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spikes_per_second</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">,</span>
                                  <span class="n">SpikeSourcePoissonVertex</span><span class="p">):</span>
                        <span class="n">rate</span> <span class="o">=</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">max_rate</span>
                        <span class="c1"># If non-zero rate then use it; otherwise keep default</span>
                        <span class="k">if</span> <span class="n">rate</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">spikes_per_second</span> <span class="o">=</span> <span class="n">rate</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spikes_per_second</span><span class="p">,</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">):</span>
                            <span class="n">spikes_per_second</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spikes_per_second</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spikes_per_second</span><span class="p">,</span> <span class="n">RandomDistribution</span><span class="p">):</span>
                            <span class="n">spikes_per_second</span> <span class="o">=</span> <span class="n">get_maximum_probable_value</span><span class="p">(</span>
                                <span class="n">spikes_per_second</span><span class="p">,</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
                        <span class="n">prob</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span>
                            <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
                        <span class="n">spikes_per_tick</span> <span class="o">=</span> <span class="n">spikes_per_second</span> <span class="o">/</span> <span class="n">steps_per_second</span>
                        <span class="n">spikes_per_tick</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">poisson</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span>
                            <span class="n">prob</span><span class="p">,</span> <span class="n">spikes_per_tick</span><span class="p">)</span>
                    <span class="n">rate_stats</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span><span class="o">.</span><span class="n">add_items</span><span class="p">(</span>
                        <span class="n">spikes_per_second</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_connections</span><span class="p">)</span>
                    <span class="n">total_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">+=</span> <span class="n">spikes_per_tick</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">weight_max</span> <span class="o">*</span> <span class="n">n_connections</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">synapse_dynamics</span><span class="o">.</span><span class="n">are_weights_signed</span><span class="p">():</span>
                        <span class="n">weights_signed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">max_weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">synapse_type</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapse_types</span><span class="p">):</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="n">running_totals</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span>
            <span class="n">rates</span> <span class="o">=</span> <span class="n">rate_stats</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">delay_running_totals</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span><span class="o">.</span><span class="n">variance</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">max_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">total_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">],</span>
                                                <span class="n">biggest_weight</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ring_buffer_expected_upper_bound</span><span class="p">(</span>
                        <span class="n">stats</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">standard_deviation</span><span class="p">,</span> <span class="n">rates</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
                        <span class="n">machine_timestep</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">n_items</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_sigma</span><span class="p">),</span>
                    <span class="n">total_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">])</span>
                <span class="n">max_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                    <span class="n">max_weights</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">],</span> <span class="n">biggest_weight</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">])</span>

        <span class="c1"># Convert these to powers</span>
        <span class="n">max_weight_powers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">0</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">max_weights</span><span class="p">)</span>

        <span class="c1"># If 2^max_weight_power equals the max weight, we have to add another</span>
        <span class="c1"># power, as range is 0 - (just under 2^max_weight_power)!</span>
        <span class="n">max_weight_powers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">w</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="k">else</span> <span class="n">w</span>
            <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">max_weight_powers</span><span class="p">,</span> <span class="n">max_weights</span><span class="p">))</span>

        <span class="c1"># If we have synapse dynamics that uses signed weights,</span>
        <span class="c1"># Add another bit of shift to prevent overflows</span>
        <span class="k">if</span> <span class="n">weights_signed</span><span class="p">:</span>
            <span class="n">max_weight_powers</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">max_weight_powers</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">max_weight_powers</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_weight_scale</span><span class="p">(</span><span class="n">ring_buffer_to_input_left_shift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the amount to scale the weights by to convert them from \</span>
<span class="sd">            floating point values to 16-bit fixed point numbers which can be \</span>
<span class="sd">            shifted left by ring_buffer_to_input_left_shift to produce an\</span>
<span class="sd">            s1615 fixed point number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">16</span> <span class="o">-</span> <span class="p">(</span><span class="n">ring_buffer_to_input_left_shift</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_write_synapse_parameters</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">ring_buffer_shifts</span><span class="p">,</span> <span class="n">weight_scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the ring buffer shifts and scaling factors.&quot;&quot;&quot;</span>

        <span class="c1"># Write the ring buffer shifts</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPSE_PARAMS</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">ring_buffer_shifts</span><span class="p">)</span>

        <span class="c1"># Return the weight scaling factors</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_weight_scale</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_scale</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ring_buffer_shifts</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_write_padding</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">synaptic_matrix_region</span><span class="p">,</span> <span class="n">next_block_start_address</span><span class="p">):</span>
        <span class="n">next_block_allowed_address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span>\
            <span class="o">.</span><span class="n">get_next_allowed_address</span><span class="p">(</span><span class="n">next_block_start_address</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">next_block_allowed_address</span> <span class="o">!=</span> <span class="n">next_block_start_address</span><span class="p">:</span>

            <span class="c1"># Pad out data file with the added alignment bytes:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">comment</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Writing population table required padding</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="n">synaptic_matrix_region</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">set_register_value</span><span class="p">(</span>
                <span class="n">register_id</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">next_block_allowed_address</span> <span class="o">-</span> <span class="n">next_block_start_address</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_repeated_value</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="mh">0xDD</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">repeats_is_register</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">data_type</span><span class="o">=</span><span class="n">DataType</span><span class="o">.</span><span class="n">UINT8</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">next_block_allowed_address</span>
        <span class="k">return</span> <span class="n">next_block_start_address</span>

    <span class="k">def</span> <span class="nf">_write_synaptic_matrix_and_master_population_table</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span> <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span>
            <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span>
            <span class="n">master_pop_table_region</span><span class="p">,</span> <span class="n">synaptic_matrix_region</span><span class="p">,</span>
            <span class="n">direct_matrix_region</span><span class="p">,</span> <span class="n">routing_info</span><span class="p">,</span>
            <span class="n">graph_mapper</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Simultaneously generates both the master population table and</span>
<span class="sd">            the synaptic matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">comment</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Writing Synaptic Matrix and Master Population Table:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Track writes inside the synaptic matrix region:</span>
        <span class="n">block_addr</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Get the edges</span>
        <span class="n">in_edges</span> <span class="o">=</span> <span class="n">machine_graph</span><span class="o">.</span><span class="n">get_edges_ending_at_vertex</span><span class="p">(</span><span class="n">machine_vertex</span><span class="p">)</span>

        <span class="c1"># Set up the master population table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">initialise_table</span><span class="p">()</span>

        <span class="c1"># Set up for single synapses - write the offset of the single synapses</span>
        <span class="c1"># initially 0</span>
        <span class="n">single_synapses</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="n">synaptic_matrix_region</span><span class="p">)</span>
        <span class="n">single_addr</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Store a list of synapse info to be generated on the machine</span>
        <span class="n">generate_on_machine</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># For each machine edge in the vertex, create a synaptic list</span>
        <span class="k">for</span> <span class="n">machine_edge</span> <span class="ow">in</span> <span class="n">in_edges</span><span class="p">:</span>
            <span class="n">app_edge</span> <span class="o">=</span> <span class="n">graph_mapper</span><span class="o">.</span><span class="n">get_application_edge</span><span class="p">(</span><span class="n">machine_edge</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">ProjectionApplicationEdge</span><span class="p">):</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">comment</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Writing matrix for m_edge:</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">machine_edge</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>

                <span class="n">pre_vertex_slice</span> <span class="o">=</span> <span class="n">graph_mapper</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span>
                    <span class="n">machine_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">)</span>
                <span class="n">pre_slices</span> <span class="o">=</span> <span class="n">graph_mapper</span><span class="o">.</span><span class="n">get_slices</span><span class="p">(</span><span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">)</span>
                <span class="n">pre_slice_index</span> <span class="o">=</span> <span class="n">graph_mapper</span><span class="o">.</span><span class="n">get_machine_vertex_index</span><span class="p">(</span>
                    <span class="n">machine_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">synapse_info</span> <span class="ow">in</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">synapse_information</span><span class="p">:</span>
                    <span class="n">rinfo</span> <span class="o">=</span> <span class="n">routing_info</span><span class="o">.</span><span class="n">get_routing_info_for_edge</span><span class="p">(</span>
                        <span class="n">machine_edge</span><span class="p">)</span>

                    <span class="c1"># If connector is being built on SpiNNaker,</span>
                    <span class="c1"># compute matrix sizes only</span>
                    <span class="n">connector</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">connector</span>
                    <span class="n">dynamics</span> <span class="o">=</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">synapse_dynamics</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span>
                            <span class="n">connector</span><span class="p">,</span> <span class="n">AbstractGenerateConnectorOnMachine</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="n">connector</span><span class="o">.</span><span class="n">generate_on_machine</span><span class="p">(</span>
                                <span class="n">synapse_info</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">delays</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamics</span><span class="p">,</span> <span class="n">AbstractGenerateOnMachine</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="n">dynamics</span><span class="o">.</span><span class="n">generate_on_machine</span> <span class="ow">and</span>
                            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_direct</span><span class="p">(</span>
                                <span class="n">single_addr</span><span class="p">,</span> <span class="n">connector</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span>
                                <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">synapse_dynamics</span><span class="p">,</span>
                                <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">)):</span>
                        <span class="n">generate_on_machine</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                            <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_slices</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span>
                            <span class="n">pre_slice_index</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__write_block</span><span class="p">(</span>
                            <span class="n">spec</span><span class="p">,</span> <span class="n">synaptic_matrix_region</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span>
                            <span class="n">pre_slices</span><span class="p">,</span> <span class="n">pre_slice_index</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span>
                            <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span>
                            <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">,</span> <span class="n">single_synapses</span><span class="p">,</span>
                            <span class="n">weight_scales</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">,</span>
                            <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span>
                            <span class="n">machine_edge</span><span class="o">=</span><span class="n">machine_edge</span><span class="p">)</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span>
                               <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

        <span class="c1"># Skip blocks that will be written on the machine, but add them</span>
        <span class="c1"># to the master population table</span>
        <span class="n">generator_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">gen_data</span> <span class="ow">in</span> <span class="n">generate_on_machine</span><span class="p">:</span>
            <span class="p">(</span><span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_slices</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">pre_slice_index</span><span class="p">,</span>
                <span class="n">app_edge</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">)</span> <span class="o">=</span> <span class="n">gen_data</span>
            <span class="n">block_addr</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_on_chip_data</span><span class="p">(</span>
                <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_slices</span><span class="p">,</span> <span class="n">pre_slice_index</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span>
                <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">,</span>
                <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span>
                <span class="n">generator_data</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span>
                   <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">finish_master_pop_table</span><span class="p">(</span>
            <span class="n">spec</span><span class="p">,</span> <span class="n">master_pop_table_region</span><span class="p">)</span>

        <span class="c1"># Write the size and data of single synapses to the direct region</span>
        <span class="k">if</span> <span class="n">single_synapses</span><span class="p">:</span>
            <span class="n">single_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">single_synapses</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                <span class="n">region</span><span class="o">=</span><span class="n">direct_matrix_region</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">single_data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s1">&#39;DirectMatrix&#39;</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="n">direct_matrix_region</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">single_data</span><span class="p">)</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">single_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
                <span class="n">region</span><span class="o">=</span><span class="n">direct_matrix_region</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">BYTES_PER_WORD</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;DirectMatrix&quot;</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="n">direct_matrix_region</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">generator_data</span>

    <span class="k">def</span> <span class="nf">__generate_on_chip_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_slices</span><span class="p">,</span> <span class="n">pre_slice_index</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span>
            <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">,</span>
            <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span>
            <span class="n">generator_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generate data for the synapse expander</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the size of the matrices that will be required</span>
        <span class="n">max_row_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_max_row_info</span><span class="p">(</span>
            <span class="n">synapse_info</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">)</span>

        <span class="c1"># If delay edge exists, tell this about the data too, so it can</span>
        <span class="c1"># generate its own data</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_n_synapses</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span>
                <span class="n">app_edge</span><span class="o">.</span><span class="n">delay_edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">app_edge</span><span class="o">.</span><span class="n">delay_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">add_generator_data</span><span class="p">(</span>
                <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_n_synapses</span><span class="p">,</span>
                <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_n_synapses</span><span class="p">,</span>
                <span class="n">pre_slices</span><span class="p">,</span> <span class="n">pre_slice_index</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span> <span class="n">post_slice_index</span><span class="p">,</span>
                <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span>
                <span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_n_synapses</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Found delayed items but no delay &quot;</span>
                <span class="s2">&quot;machine edge for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">app_edge</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>

        <span class="c1"># Skip over the normal bytes but still write a master pop entry</span>
        <span class="n">synaptic_matrix_offset</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>
        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_n_synapses</span><span class="p">:</span>
            <span class="n">synaptic_matrix_offset</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_next_allowed_address</span><span class="p">(</span><span class="n">block_addr</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="n">synaptic_matrix_offset</span><span class="p">,</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_words</span><span class="p">,</span>
                <span class="n">rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>
            <span class="n">n_bytes_undelayed</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_bytes</span> <span class="o">*</span> <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
            <span class="n">block_addr</span> <span class="o">=</span> <span class="n">synaptic_matrix_offset</span> <span class="o">+</span> <span class="n">n_bytes_undelayed</span>

            <span class="c1"># The synaptic matrix offset is in words for the generator</span>
            <span class="n">synaptic_matrix_offset</span> <span class="o">//=</span> <span class="n">BYTES_PER_WORD</span>
        <span class="k">elif</span> <span class="n">rinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">block_addr</span> <span class="o">&gt;</span> <span class="n">all_syn_block_sz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Too much synaptic memory has been written: </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">block_addr</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">))</span>

        <span class="c1"># Skip over the delayed bytes but still write a master pop entry</span>
        <span class="n">delayed_synaptic_matrix_offset</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>
        <span class="n">delay_rinfo</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">n_delay_stages</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">delay_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span>
                     <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">delay_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delay_key_index</span><span class="p">:</span>
            <span class="n">delay_rinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delay_key_index</span><span class="p">[</span><span class="n">delay_key</span><span class="p">]</span>
        <span class="n">d_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_n_synapses</span><span class="p">:</span>
            <span class="n">n_delay_stages</span> <span class="o">=</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span>
            <span class="n">delayed_synaptic_matrix_offset</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_next_allowed_address</span><span class="p">(</span>
                    <span class="n">block_addr</span><span class="p">)</span>
            <span class="n">d_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="n">delayed_synaptic_matrix_offset</span><span class="p">,</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_words</span><span class="p">,</span>
                <span class="n">delay_rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>
            <span class="n">n_bytes_delayed</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_bytes</span> <span class="o">*</span> <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">*</span>
                <span class="n">n_delay_stages</span><span class="p">)</span>
            <span class="n">block_addr</span> <span class="o">=</span> <span class="n">delayed_synaptic_matrix_offset</span> <span class="o">+</span> <span class="n">n_bytes_delayed</span>

            <span class="c1"># The delayed synaptic matrix offset is in words for the generator</span>
            <span class="n">delayed_synaptic_matrix_offset</span> <span class="o">//=</span> <span class="n">BYTES_PER_WORD</span>
        <span class="k">elif</span> <span class="n">delay_rinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delay_rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">block_addr</span> <span class="o">&gt;</span> <span class="n">all_syn_block_sz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Too much synaptic memory has been written:&quot;</span>
                <span class="s2">&quot; </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">block_addr</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">))</span>

        <span class="c1"># Get additional data for the synapse expander</span>
        <span class="n">generator_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">GeneratorData</span><span class="p">(</span>
            <span class="n">synaptic_matrix_offset</span><span class="p">,</span> <span class="n">delayed_synaptic_matrix_offset</span><span class="p">,</span>
            <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_words</span><span class="p">,</span> <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_words</span><span class="p">,</span>
            <span class="n">max_row_info</span><span class="o">.</span><span class="n">undelayed_max_n_synapses</span><span class="p">,</span>
            <span class="n">max_row_info</span><span class="o">.</span><span class="n">delayed_max_n_synapses</span><span class="p">,</span> <span class="n">pre_slices</span><span class="p">,</span> <span class="n">pre_slice_index</span><span class="p">,</span>
            <span class="n">post_slices</span><span class="p">,</span> <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
            <span class="n">synapse_info</span><span class="p">,</span> <span class="n">n_delay_stages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">machine_time_step</span><span class="p">))</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__gen_on_machine</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">d_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">d_index</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Delay index </span><span class="si">{}</span><span class="s2"> and normal index </span><span class="si">{}</span><span class="s2"> do not match&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d_index</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">__write_block</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">synaptic_matrix_region</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_slices</span><span class="p">,</span>
            <span class="n">pre_slice_index</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span> <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span>
            <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span> <span class="n">n_synapse_types</span><span class="p">,</span> <span class="n">single_synapses</span><span class="p">,</span>
            <span class="n">weight_scales</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">,</span>
            <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">machine_edge</span><span class="p">):</span>
        <span class="p">(</span><span class="n">row_data</span><span class="p">,</span> <span class="n">row_length</span><span class="p">,</span> <span class="n">delayed_row_data</span><span class="p">,</span> <span class="n">delayed_row_length</span><span class="p">,</span>
         <span class="n">delayed_source_ids</span><span class="p">,</span> <span class="n">delay_stages</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span><span class="o">.</span><span class="n">get_synapses</span><span class="p">(</span>
             <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_slices</span><span class="p">,</span> <span class="n">pre_slice_index</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span>
             <span class="n">post_slice_index</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
             <span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="p">,</span> <span class="n">n_synapse_types</span><span class="p">,</span>
             <span class="n">weight_scales</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span>
             <span class="n">app_edge</span><span class="o">=</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">machine_edge</span><span class="o">=</span><span class="n">machine_edge</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">delay_edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">app_edge</span><span class="o">.</span><span class="n">delay_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">add_delays</span><span class="p">(</span>
                <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">delayed_source_ids</span><span class="p">,</span> <span class="n">delay_stages</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">delayed_source_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Found delayed source IDs but no delay &quot;</span>
                <span class="s2">&quot;machine edge for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">app_edge</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pre_run_connection_holders</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">conn_holder</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pre_run_connection_holders</span><span class="p">[</span>
                    <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">]:</span>
                <span class="n">conn_holder</span><span class="o">.</span><span class="n">add_connections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_synapses</span><span class="p">(</span>
                    <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
                    <span class="n">row_length</span><span class="p">,</span> <span class="n">delayed_row_length</span><span class="p">,</span> <span class="n">n_synapse_types</span><span class="p">,</span>
                    <span class="n">weight_scales</span><span class="p">,</span> <span class="n">row_data</span><span class="p">,</span> <span class="n">delayed_row_data</span><span class="p">,</span>
                    <span class="n">machine_time_step</span><span class="p">))</span>
                <span class="n">conn_holder</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>

        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">row_data</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__write_row_data</span><span class="p">(</span>
                <span class="n">spec</span><span class="p">,</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">connector</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span>
                <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">row_length</span><span class="p">,</span> <span class="n">row_data</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">,</span>
                <span class="n">single_synapses</span><span class="p">,</span> <span class="n">synaptic_matrix_region</span><span class="p">,</span> <span class="n">block_addr</span><span class="p">,</span>
                <span class="n">single_addr</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">row_data</span>

        <span class="k">if</span> <span class="n">block_addr</span> <span class="o">&gt;</span> <span class="n">all_syn_block_sz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Too much synaptic memory has been written: </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">block_addr</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">))</span>

        <span class="n">delay_rinfo</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">delay_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span>
                     <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">delay_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delay_key_index</span><span class="p">:</span>
            <span class="n">delay_rinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delay_key_index</span><span class="p">[</span><span class="n">delay_key</span><span class="p">]</span>
        <span class="n">d_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">delayed_row_data</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">d_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__write_row_data</span><span class="p">(</span>
                <span class="n">spec</span><span class="p">,</span> <span class="n">synapse_info</span><span class="o">.</span><span class="n">connector</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span>
                <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">delayed_row_length</span><span class="p">,</span> <span class="n">delayed_row_data</span><span class="p">,</span>
                <span class="n">delay_rinfo</span><span class="p">,</span> <span class="n">single_synapses</span><span class="p">,</span> <span class="n">synaptic_matrix_region</span><span class="p">,</span>
                <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">delay_rinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delay_rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">delayed_row_data</span>

        <span class="k">if</span> <span class="n">block_addr</span> <span class="o">&gt;</span> <span class="n">all_syn_block_sz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Too much synaptic memory has been written: </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">block_addr</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">d_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">d_index</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Delay index </span><span class="si">{}</span><span class="s2"> and normal index </span><span class="si">{}</span><span class="s2"> do not match&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">d_index</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">__is_direct</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">connector</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
            <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Determine if the given connection can be done with a &quot;direct&quot;\</span>
<span class="sd">            synaptic matrix - this must have an exactly 1 entry per row</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
            <span class="n">connector</span><span class="o">.</span><span class="n">use_direct_matrix</span><span class="p">(</span><span class="n">synapse_info</span><span class="p">)</span> <span class="ow">and</span>
            <span class="p">(</span><span class="n">single_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">)</span> <span class="o">&lt;=</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__one_to_one_connection_dtcm_max_bytes</span><span class="p">)</span> <span class="ow">and</span>
            <span class="p">(</span><span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span> <span class="o">==</span> <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">)</span> <span class="ow">and</span>
            <span class="p">(</span><span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span> <span class="o">==</span> <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__write_row_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">connector</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
            <span class="n">row_length</span><span class="p">,</span> <span class="n">row_data</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">,</span> <span class="n">single_synapses</span><span class="p">,</span>
            <span class="n">synaptic_matrix_region</span><span class="p">,</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">app_edge</span><span class="p">,</span>
            <span class="n">synapse_info</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">row_length</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_direct</span><span class="p">(</span>
                <span class="n">single_addr</span><span class="p">,</span> <span class="n">connector</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
                <span class="n">app_edge</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">):</span>
            <span class="n">single_rows</span> <span class="o">=</span> <span class="n">row_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)[:,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">single_synapses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">single_rows</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="n">single_addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">,</span> <span class="n">is_single</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">single_addr</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">single_rows</span><span class="p">)</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">block_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_padding</span><span class="p">(</span>
                <span class="n">spec</span><span class="p">,</span> <span class="n">synaptic_matrix_region</span><span class="p">,</span> <span class="n">block_addr</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span><span class="n">synaptic_matrix_region</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">row_data</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">update_master_population_table</span><span class="p">(</span>
                <span class="n">block_addr</span><span class="p">,</span> <span class="n">row_length</span><span class="p">,</span> <span class="n">rinfo</span><span class="o">.</span><span class="n">first_key_and_mask</span><span class="p">)</span>
            <span class="n">block_addr</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_data</span><span class="p">)</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
        <span class="k">return</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">single_addr</span><span class="p">,</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">_get_ring_buffer_shifts</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">machine_timestep</span><span class="p">,</span>
            <span class="n">weight_scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the ring buffer shifts for this vertex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_ring_buffer_to_input_left_shifts</span><span class="p">(</span>
                    <span class="n">application_vertex</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">machine_timestep</span><span class="p">,</span>
                    <span class="n">weight_scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span>

<div class="viewcode-block" id="SynapticManager.write_data_spec"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.synaptic_manager.SynapticManager.write_data_spec">[docs]</a>    <span class="k">def</span> <span class="nf">write_data_spec</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">application_vertex</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span>
            <span class="n">placement</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">routing_info</span><span class="p">,</span>
            <span class="n">graph_mapper</span><span class="p">,</span> <span class="n">weight_scale</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">):</span>
        <span class="c1"># Create an index of delay keys into this vertex</span>
        <span class="k">for</span> <span class="n">m_edge</span> <span class="ow">in</span> <span class="n">machine_graph</span><span class="o">.</span><span class="n">get_edges_ending_at_vertex</span><span class="p">(</span><span class="n">machine_vertex</span><span class="p">):</span>
            <span class="n">app_edge</span> <span class="o">=</span> <span class="n">graph_mapper</span><span class="o">.</span><span class="n">get_application_edge</span><span class="p">(</span><span class="n">m_edge</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">,</span> <span class="n">DelayExtensionVertex</span><span class="p">):</span>
                <span class="n">pre_vertex_slice</span> <span class="o">=</span> <span class="n">graph_mapper</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span>
                    <span class="n">m_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__delay_key_index</span><span class="p">[</span><span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="o">.</span><span class="n">source_vertex</span><span class="p">,</span>
                                       <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span>
                                       <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">routing_info</span><span class="o">.</span><span class="n">get_routing_info_for_edge</span><span class="p">(</span><span class="n">m_edge</span><span class="p">)</span>

        <span class="n">post_slices</span> <span class="o">=</span> <span class="n">graph_mapper</span><span class="o">.</span><span class="n">get_slices</span><span class="p">(</span><span class="n">application_vertex</span><span class="p">)</span>
        <span class="n">post_slice_idx</span> <span class="o">=</span> <span class="n">graph_mapper</span><span class="o">.</span><span class="n">get_machine_vertex_index</span><span class="p">(</span><span class="n">machine_vertex</span><span class="p">)</span>

        <span class="c1"># Reserve the memory</span>
        <span class="n">in_edges</span> <span class="o">=</span> <span class="n">application_graph</span><span class="o">.</span><span class="n">get_edges_ending_at_vertex</span><span class="p">(</span>
            <span class="n">application_vertex</span><span class="p">)</span>
        <span class="n">all_syn_block_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_synaptic_blocks_size</span><span class="p">(</span>
            <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">in_edges</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reserve_memory_regions</span><span class="p">(</span>
            <span class="n">spec</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span>
            <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">graph_mapper</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span>
            <span class="n">application_vertex</span><span class="p">)</span>

        <span class="n">ring_buffer_shifts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ring_buffer_shifts</span><span class="p">(</span>
            <span class="n">application_vertex</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span>
            <span class="n">weight_scale</span><span class="p">)</span>
        <span class="n">weight_scales</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_synapse_parameters</span><span class="p">(</span>
            <span class="n">spec</span><span class="p">,</span> <span class="n">ring_buffer_shifts</span><span class="p">,</span> <span class="n">weight_scale</span><span class="p">)</span>

        <span class="n">gen_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_synaptic_matrix_and_master_population_table</span><span class="p">(</span>
            <span class="n">spec</span><span class="p">,</span> <span class="n">post_slices</span><span class="p">,</span> <span class="n">post_slice_idx</span><span class="p">,</span> <span class="n">machine_vertex</span><span class="p">,</span>
            <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">all_syn_block_sz</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span>
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">POPULATION_TABLE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPTIC_MATRIX</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">DIRECT_MATRIX</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">routing_info</span><span class="p">,</span> <span class="n">graph_mapper</span><span class="p">,</span> <span class="n">machine_graph</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="p">,</span>
                          <span class="n">AbstractSynapseDynamicsStructural</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">write_structural_parameters</span><span class="p">(</span>
                    <span class="n">spec</span><span class="p">,</span> <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPSE_DYNAMICS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span> <span class="n">application_graph</span><span class="p">,</span>
                    <span class="n">application_vertex</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">graph_mapper</span><span class="p">,</span>
                    <span class="n">routing_info</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_indices</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">write_parameters</span><span class="p">(</span>
                    <span class="n">spec</span><span class="p">,</span>
                    <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPSE_DYNAMICS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="n">machine_time_step</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__weight_scales</span><span class="p">[</span><span class="n">placement</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight_scales</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_write_on_machine_data_spec</span><span class="p">(</span>
            <span class="n">spec</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span> <span class="n">gen_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="SynapticManager.clear_connection_cache"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.synaptic_manager.SynapticManager.clear_connection_cache">[docs]</a>    <span class="k">def</span> <span class="nf">clear_connection_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__retrieved_blocks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span></div>

<div class="viewcode-block" id="SynapticManager.get_connections_from_machine"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.synaptic_manager.SynapticManager.get_connections_from_machine">[docs]</a>    <span class="k">def</span> <span class="nf">get_connections_from_machine</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">machine_edge</span><span class="p">,</span> <span class="n">graph_mapper</span><span class="p">,</span>
            <span class="n">routing_infos</span><span class="p">,</span> <span class="n">synapse_info</span><span class="p">,</span> <span class="n">machine_time_step</span><span class="p">,</span>
            <span class="n">using_extra_monitor_cores</span><span class="p">,</span> <span class="n">placements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">monitor_api</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">monitor_cores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">handle_time_out_configuration</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">fixed_routes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">app_edge</span> <span class="o">=</span> <span class="n">graph_mapper</span><span class="o">.</span><span class="n">get_application_edge</span><span class="p">(</span><span class="n">machine_edge</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">app_edge</span><span class="p">,</span> <span class="n">ProjectionApplicationEdge</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Get details for extraction</span>
        <span class="n">pre_vertex_slice</span> <span class="o">=</span> <span class="n">graph_mapper</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">machine_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">)</span>
        <span class="n">post_vertex_slice</span> <span class="o">=</span> <span class="n">graph_mapper</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">machine_edge</span><span class="o">.</span><span class="n">post_vertex</span><span class="p">)</span>

        <span class="c1"># Get the key for the pre_vertex</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">routing_infos</span><span class="o">.</span><span class="n">get_first_key_for_edge</span><span class="p">(</span><span class="n">machine_edge</span><span class="p">)</span>

        <span class="c1"># Get the key for the delayed pre_vertex</span>
        <span class="n">delayed_key</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">delay_edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">delayed_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delay_key_index</span><span class="p">[</span>
                <span class="n">app_edge</span><span class="o">.</span><span class="n">pre_vertex</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span>
                <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span><span class="p">]</span><span class="o">.</span><span class="n">first_key</span>

        <span class="c1"># Get the block for the connections from the pre_vertex</span>
        <span class="n">synapse_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span>
                       <span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_indices</span><span class="p">[</span><span class="n">synapse_key</span><span class="p">]</span>
        <span class="n">master_pop_table</span><span class="p">,</span> <span class="n">direct_synapses</span><span class="p">,</span> <span class="n">indirect_synapses</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">__compute_addresses</span><span class="p">(</span><span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">)</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">max_row_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieve_synaptic_block</span><span class="p">(</span>
            <span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">master_pop_table</span><span class="p">,</span> <span class="n">indirect_synapses</span><span class="p">,</span>
            <span class="n">direct_synapses</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
            <span class="n">using_extra_monitor_cores</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span> <span class="n">monitor_api</span><span class="p">,</span>
            <span class="n">extra_monitor</span><span class="p">,</span> <span class="n">monitor_cores</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="o">=</span><span class="n">fixed_routes</span><span class="p">)</span>

        <span class="c1"># Get the block for the connections from the delayed pre_vertex</span>
        <span class="n">delayed_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">delayed_max_row_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">delayed_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">delayed_data</span><span class="p">,</span> <span class="n">delayed_max_row_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieve_synaptic_block</span><span class="p">(</span>
                <span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">master_pop_table</span><span class="p">,</span> <span class="n">indirect_synapses</span><span class="p">,</span>
                <span class="n">direct_synapses</span><span class="p">,</span> <span class="n">delayed_key</span><span class="p">,</span>
                <span class="n">pre_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">*</span> <span class="n">app_edge</span><span class="o">.</span><span class="n">n_delay_stages</span><span class="p">,</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">using_extra_monitor_cores</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span>
                <span class="n">monitor_api</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="p">,</span> <span class="n">monitor_cores</span><span class="p">,</span>
                <span class="n">handle_time_out_configuration</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="o">=</span><span class="n">fixed_routes</span><span class="p">)</span>

        <span class="c1"># Convert the blocks into connections</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_synapses</span><span class="p">(</span>
            <span class="n">synapse_info</span><span class="p">,</span> <span class="n">pre_vertex_slice</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span>
            <span class="n">max_row_length</span><span class="p">,</span> <span class="n">delayed_max_row_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weight_scales</span><span class="p">[</span><span class="n">placement</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">delayed_data</span><span class="p">,</span>
            <span class="n">machine_time_step</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__compute_addresses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Helper for computing the addresses of the master pop table and\</span>
<span class="sd">            synaptic-matrix-related bits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">master_pop_table</span> <span class="o">=</span> <span class="n">locate_memory_region_for_placement</span><span class="p">(</span>
            <span class="n">placement</span><span class="p">,</span> <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">POPULATION_TABLE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">transceiver</span><span class="p">)</span>
        <span class="n">synaptic_matrix</span> <span class="o">=</span> <span class="n">locate_memory_region_for_placement</span><span class="p">(</span>
            <span class="n">placement</span><span class="p">,</span> <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">SYNAPTIC_MATRIX</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">transceiver</span><span class="p">)</span>
        <span class="n">direct_synapses</span> <span class="o">=</span> <span class="n">locate_memory_region_for_placement</span><span class="p">(</span>
            <span class="n">placement</span><span class="p">,</span> <span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">DIRECT_MATRIX</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">transceiver</span><span class="p">)</span> <span class="o">+</span> <span class="n">BYTES_PER_WORD</span>
        <span class="k">return</span> <span class="n">master_pop_table</span><span class="p">,</span> <span class="n">direct_synapses</span><span class="p">,</span> <span class="n">synaptic_matrix</span>

    <span class="k">def</span> <span class="nf">_extract_synaptic_matrix_data_location</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">master_pop_table_address</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">extract_synaptic_matrix_data_location</span><span class="p">(</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">master_pop_table_address</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">,</span>
            <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">pre_slice</span><span class="p">,</span> <span class="n">post_slice</span><span class="p">,</span> <span class="n">max_row_length</span><span class="p">,</span>
                       <span class="n">delayed_max_row_length</span><span class="p">,</span> <span class="n">n_synapse_types</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span>
                       <span class="n">data</span><span class="p">,</span> <span class="n">delayed_data</span><span class="p">,</span> <span class="n">timestep</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span><span class="o">.</span><span class="n">read_synapses</span><span class="p">(</span>
            <span class="n">info</span><span class="p">,</span> <span class="n">pre_slice</span><span class="p">,</span> <span class="n">post_slice</span><span class="p">,</span> <span class="n">max_row_length</span><span class="p">,</span>
            <span class="n">delayed_max_row_length</span><span class="p">,</span> <span class="n">n_synapse_types</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
            <span class="n">delayed_data</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_retrieve_synaptic_block</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">txrx</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">master_pop_table_address</span><span class="p">,</span>
            <span class="n">indirect_synapses_address</span><span class="p">,</span> <span class="n">direct_synapses_address</span><span class="p">,</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">using_monitors</span><span class="p">,</span> <span class="n">placements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">monitor_api</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">monitor_cores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">handle_time_out_configuration</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read in a synaptic block from a given processor and vertex on\</span>
<span class="sd">            the machine</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># See if we have already got this block</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">placement</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__retrieved_blocks</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__retrieved_blocks</span><span class="p">[</span><span class="n">placement</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>

        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_synaptic_matrix_data_location</span><span class="p">(</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">master_pop_table_address</span><span class="p">,</span> <span class="n">txrx</span><span class="p">,</span> <span class="n">placement</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">max_row_length</span><span class="p">,</span> <span class="n">synaptic_block_offset</span><span class="p">,</span> <span class="n">is_single</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">max_row_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">block</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">max_row_length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">synaptic_block_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if exploiting the extra monitor cores, need to set the machine</span>
            <span class="c1"># for data extraction mode</span>
            <span class="k">if</span> <span class="n">using_monitors</span> <span class="ow">and</span> <span class="n">handle_time_out_configuration</span><span class="p">:</span>
                <span class="n">monitor_api</span><span class="o">.</span><span class="n">load_system_routing_tables</span><span class="p">(</span>
                    <span class="n">txrx</span><span class="p">,</span> <span class="n">monitor_cores</span><span class="p">,</span> <span class="n">placements</span><span class="p">)</span>
                <span class="n">monitor_api</span><span class="o">.</span><span class="n">set_cores_for_data_streaming</span><span class="p">(</span>
                    <span class="n">txrx</span><span class="p">,</span> <span class="n">monitor_cores</span><span class="p">,</span> <span class="n">placements</span><span class="p">)</span>

            <span class="c1"># read in the synaptic block</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_single</span><span class="p">:</span>
                <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__read_multiple_synaptic_blocks</span><span class="p">(</span>
                    <span class="n">txrx</span><span class="p">,</span> <span class="n">monitor_api</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">max_row_length</span><span class="p">,</span>
                    <span class="n">indirect_synapses_address</span> <span class="o">+</span> <span class="n">synaptic_block_offset</span><span class="p">,</span>
                    <span class="n">using_monitors</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="p">,</span> <span class="n">placements</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">block</span><span class="p">,</span> <span class="n">max_row_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__read_single_synaptic_block</span><span class="p">(</span>
                    <span class="n">txrx</span><span class="p">,</span> <span class="n">monitor_api</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span>
                    <span class="n">direct_synapses_address</span> <span class="o">+</span> <span class="n">synaptic_block_offset</span><span class="p">,</span>
                    <span class="n">using_monitors</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="p">,</span> <span class="n">placements</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">using_monitors</span> <span class="ow">and</span> <span class="n">handle_time_out_configuration</span><span class="p">:</span>
                <span class="n">monitor_api</span><span class="o">.</span><span class="n">unset_cores_for_data_streaming</span><span class="p">(</span>
                    <span class="n">txrx</span><span class="p">,</span> <span class="n">monitor_cores</span><span class="p">,</span> <span class="n">placements</span><span class="p">)</span>
                <span class="n">monitor_api</span><span class="o">.</span><span class="n">load_application_routing_tables</span><span class="p">(</span>
                    <span class="n">txrx</span><span class="p">,</span> <span class="n">monitor_cores</span><span class="p">,</span> <span class="n">placements</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__retrieved_blocks</span><span class="p">[</span><span class="n">placement</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> \
            <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">max_row_length</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">block</span><span class="p">,</span> <span class="n">max_row_length</span>

    <span class="k">def</span> <span class="nf">__read_multiple_synaptic_blocks</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">,</span> <span class="n">monitor_api</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">max_row_length</span><span class="p">,</span>
            <span class="n">address</span><span class="p">,</span> <span class="n">using_monitors</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="p">,</span> <span class="n">placements</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read in an array of synaptic blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># calculate the synaptic block size in bytes</span>
        <span class="n">synaptic_block_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_io</span><span class="o">.</span><span class="n">get_block_n_bytes</span><span class="p">(</span>
            <span class="n">max_row_length</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">)</span>

        <span class="c1"># read in the synaptic block</span>
        <span class="k">if</span> <span class="n">using_monitors</span><span class="p">:</span>
            <span class="n">extra_monitor</span><span class="o">.</span><span class="n">update_transaction_id_from_machine</span><span class="p">(</span><span class="n">transceiver</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">monitor_api</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span>
                <span class="n">extra_monitor</span><span class="p">,</span>
                <span class="n">placements</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span><span class="n">extra_monitor</span><span class="p">),</span> <span class="n">address</span><span class="p">,</span>
                <span class="n">synaptic_block_size</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transceiver</span><span class="o">.</span><span class="n">read_memory</span><span class="p">(</span>
            <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">synaptic_block_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__read_single_synaptic_block</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">,</span> <span class="n">data_receiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
            <span class="n">using_monitors</span><span class="p">,</span> <span class="n">extra_monitor</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="p">,</span> <span class="n">placements</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read in a single synaptic block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The data is one per row</span>
        <span class="n">synaptic_block_size</span> <span class="o">=</span> <span class="n">n_rows</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>

        <span class="c1"># read in the synaptic row data</span>
        <span class="k">if</span> <span class="n">using_monitors</span><span class="p">:</span>
            <span class="n">extra_monitor</span><span class="o">.</span><span class="n">update_transaction_id_from_machine</span><span class="p">(</span><span class="n">transceiver</span><span class="p">)</span>
            <span class="n">single_block</span> <span class="o">=</span> <span class="n">data_receiver</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span>
                <span class="n">extra_monitor</span><span class="p">,</span>
                <span class="n">placements</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span><span class="n">extra_monitor</span><span class="p">),</span>
                <span class="n">address</span><span class="p">,</span> <span class="n">synaptic_block_size</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_block</span> <span class="o">=</span> <span class="n">transceiver</span><span class="o">.</span><span class="n">read_memory</span><span class="p">(</span>
                <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">synaptic_block_size</span><span class="p">)</span>

        <span class="c1"># Convert the block into a set of rows</span>
        <span class="n">numpy_block</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">BYTES_PER_WORD</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint32&quot;</span><span class="p">)</span>
        <span class="n">numpy_block</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">single_block</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;uint32&quot;</span><span class="p">)</span>
        <span class="n">numpy_block</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">numpy_block</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()),</span> <span class="mi">1</span>

    <span class="c1"># inherited from AbstractProvidesIncomingPartitionConstraints</span>
<div class="viewcode-block" id="SynapticManager.get_incoming_partition_constraints"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.synaptic_manager.SynapticManager.get_incoming_partition_constraints">[docs]</a>    <span class="k">def</span> <span class="nf">get_incoming_partition_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poptable_type</span><span class="o">.</span><span class="n">get_edge_constraints</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_write_on_machine_data_spec</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">post_vertex_slice</span><span class="p">,</span> <span class="n">weight_scales</span><span class="p">,</span> <span class="n">generator_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write the data spec for the synapse expander</span>

<span class="sd">        :param spec: The specification to write to</span>
<span class="sd">        :param post_vertex_slice: The slice of the vertex being written</span>
<span class="sd">        :param weight_scales: scaling of weights on each synapse</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">generator_data</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">n_bytes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_SYNAPSES_BASE_GENERATOR_SDRAM_USAGE_IN_BYTES</span> <span class="o">+</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">generator_data</span><span class="p">:</span>
            <span class="n">n_bytes</span> <span class="o">+=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>

        <span class="n">spec</span><span class="o">.</span><span class="n">reserve_memory_region</span><span class="p">(</span>
            <span class="n">region</span><span class="o">=</span><span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">CONNECTOR_BUILDER</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="n">n_bytes</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ConnectorBuilderRegion&quot;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">switch_write_focus</span><span class="p">(</span>
            <span class="n">region</span><span class="o">=</span><span class="n">POPULATION_BASED_REGIONS</span><span class="o">.</span><span class="n">CONNECTOR_BUILDER</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">generator_data</span><span class="p">))</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">get_n_bits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_synapse_types</span><span class="p">))</span>
        <span class="n">n_neuron_id_bits</span> <span class="o">=</span> <span class="n">get_n_bits</span><span class="p">(</span><span class="n">post_vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">n_neuron_id_bits</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weight_scales</span><span class="p">:</span>
            <span class="c1"># if the weights are high enough and the population size large</span>
            <span class="c1"># enough, then weight_scales &lt; 1 will result in a zero scale</span>
            <span class="c1"># if converted to an int, so this needs to be an S1615</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">DataType</span><span class="o">.</span><span class="n">S1615</span>
            <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">dtype</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">dtype</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">write_value</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">generator_data</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">gen_data</span><span class="p">)</span>

<div class="viewcode-block" id="SynapticManager.gen_on_machine"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.synaptic_manager.SynapticManager.gen_on_machine">[docs]</a>    <span class="k">def</span> <span class="nf">gen_on_machine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; True if the synapses should be generated on the machine</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">hi_atom</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gen_on_machine</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SynapticManager.reset_ring_buffer_shifts"><a class="viewcode-back" href="../../../../../spynnaker.pyNN.models.neuron.html#spynnaker.pyNN.models.neuron.synaptic_manager.SynapticManager.reset_ring_buffer_shifts">[docs]</a>    <span class="k">def</span> <span class="nf">reset_ring_buffer_shifts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ring_buffer_shifts</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">changes_during_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__synapse_dynamics</span><span class="o">.</span><span class="n">changes_during_run</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">sPyNNaker  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>