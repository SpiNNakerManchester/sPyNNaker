
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>spynnaker.pyNN.utilities.neo_buffer_database &#8212; sPyNNaker 6.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinxdoc.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">sPyNNaker 6.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../pyNN.html" accesskey="U">spynnaker.pyNN</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spynnaker.pyNN.utilities.neo_buffer_database</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for spynnaker.pyNN.utilities.neo_buffer_database</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2022 The University of Manchester</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">quantities</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">spinn_utilities.log</span> <span class="kn">import</span> <span class="n">FormatAdapter</span>
<span class="kn">from</span> <span class="nn">spinnman.messages.eieio.data_messages</span> <span class="kn">import</span> <span class="n">EIEIODataHeader</span>
<span class="kn">from</span> <span class="nn">data_specification.enums</span> <span class="kn">import</span> <span class="n">DataType</span>
<span class="kn">from</span> <span class="nn">pacman.model.graphs.common</span> <span class="kn">import</span> <span class="n">Slice</span>
<span class="kn">from</span> <span class="nn">pacman.utilities.utility_calls</span> <span class="kn">import</span> <span class="n">get_field_based_index</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.interface.buffer_management.storage_objects</span> \
    <span class="kn">import</span> <span class="nn">BufferDatabase</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BYTES_PER_WORD</span><span class="p">,</span> <span class="n">BITS_PER_WORD</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.exceptions</span> <span class="kn">import</span> <span class="n">ConfigurationException</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.data</span> <span class="kn">import</span> <span class="n">SpynnakerDataView</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.exceptions</span> <span class="kn">import</span> <span class="n">SpynnakerException</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.buffer_data_type</span> <span class="kn">import</span> <span class="n">BufferDataType</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.constants</span> <span class="kn">import</span> <span class="n">SPIKES</span>
<span class="kn">from</span> <span class="nn">spynnaker.pyNN.utilities.neo_csv</span> <span class="kn">import</span> <span class="n">NeoCsv</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">FormatAdapter</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">))</span>


<div class="viewcode-block" id="NeoBufferDatabase"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase">[docs]</a><span class="k">class</span> <span class="nc">NeoBufferDatabase</span><span class="p">(</span><span class="n">BufferDatabase</span><span class="p">,</span> <span class="n">NeoCsv</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extra support for Neo on top of the Database for SQLite 3.</span>

<span class="sd">    This is the same database as used by BufferManager but with</span>
<span class="sd">    extra tables and access methods added.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=c-extension-no-member</span>

    <span class="n">__N_BYTES_FOR_TIMESTAMP</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span>
    <span class="n">__TWO_WORDS</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">Struct</span><span class="p">(</span><span class="s2">&quot;&lt;II&quot;</span><span class="p">)</span>
    <span class="n">__NEO_DDL_FILE</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s2">&quot;db.sql&quot;</span><span class="p">)</span>
    <span class="c1">#: rewiring: shift values to decode recorded value</span>
    <span class="n">__PRE_ID_SHIFT</span> <span class="o">=</span> <span class="mi">9</span>
    <span class="n">__POST_ID_SHIFT</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">__POST_ID_FACTOR</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">8</span>
    <span class="n">__FIRST_BIT</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1">#: number of words per rewiring entry</span>
    <span class="n">__REWIRING_N_WORDS</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">database_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">read_only</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param database_file:</span>
<span class="sd">            The name of a file that contains (or will contain) an SQLite</span>
<span class="sd">            database holding the data.</span>
<span class="sd">            If omitted the default location will be used.</span>
<span class="sd">        :type database_file: None or str</span>
<span class="sd">        :param bool read_only:</span>
<span class="sd">            By default the database is read-only if given a database file.</span>
<span class="sd">            This allows to override that (mainly for clear)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">database_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">database_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_database_file</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">read_only</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">read_only</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">read_only</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">read_only</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">database_file</span><span class="p">,</span> <span class="n">read_only</span><span class="o">=</span><span class="n">read_only</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__NEO_DDL_FILE</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">sql</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="c1"># pylint: disable=no-member</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_SQLiteDB__db</span><span class="o">.</span><span class="n">executescript</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>

<div class="viewcode-block" id="NeoBufferDatabase.write_segment_metadata"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.write_segment_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">write_segment_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the global information from the Views.</span>

<span class="sd">        This writes information held in :py:class:`SpynnakerDataView` so that</span>
<span class="sd">        the database is usable stand-alone.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The database must be writable for this to work!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="c1"># t_stop intentionally left None to show no run data</span>
            <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                INSERT INTO segment</span>
<span class="sd">                    (simulation_time_step_ms, segment_number, rec_datetime,</span>
<span class="sd">                     dt, simulator)</span>
<span class="sd">                 VALUES (?, ?, ?, ?, ?)</span>
<span class="sd">                &quot;&quot;&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_simulation_time_step_ms</span><span class="p">(),</span>
                      <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_segment_counter</span><span class="p">(),</span>
                      <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span>
                      <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_simulation_time_step_ms</span><span class="p">(),</span>
                      <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_sim_name</span><span class="p">()])</span></div>

<div class="viewcode-block" id="NeoBufferDatabase.write_t_stop"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.write_t_stop">[docs]</a>    <span class="k">def</span> <span class="nf">write_t_stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Records the current run time as `t_Stop`.</span>

<span class="sd">        This writes information held in :py:class:`SpynnakerDataView` so that</span>
<span class="sd">        the database is usable stand-alone.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The database must be writable for this to work!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t_stop</span> <span class="o">=</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_current_run_time_ms</span><span class="p">()</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                UPDATE segment</span>
<span class="sd">                SET t_stop = ?</span>
<span class="sd">                &quot;&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">t_stop</span><span class="p">,</span> <span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__get_segment_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the metadata for the segment.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :return: segment number, record time, last run time recorded,</span>
<span class="sd">            simulator timestep in ms, simulator name</span>
<span class="sd">        :rtype: tuple(int, ~datetime.datetime, float, float, str)</span>
<span class="sd">        :raises \</span>
<span class="sd">            ~spinn_front_end_common.utilities.exceptions.ConfigurationException:</span>
<span class="sd">            If the recording metadata not setup correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                SELECT segment_number, rec_datetime, t_stop, dt, simulator</span>
<span class="sd">                FROM segment</span>
<span class="sd">                LIMIT 1</span>
<span class="sd">                &quot;&quot;&quot;</span><span class="p">):</span>
            <span class="n">t_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_REC_DATETIME</span><span class="p">],</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">t_str</span><span class="p">,</span> <span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S.</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_T_STOP</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">t_stop</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Data from a virtual run will be empty&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t_stop</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_T_STOP</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_SEGMENT_NUMBER</span><span class="p">],</span> <span class="n">time</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_DT</span><span class="p">],</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_SIMULATOR</span><span class="p">],</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
        <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span>
            <span class="s2">&quot;No recorded data. Did the simulation run?&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_simulation_time_step_ms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The simulation time step, in milliseconds.</span>

<span class="sd">        The value that would be/have been returned by</span>
<span class="sd">        SpynnakerDataView.get_simulation_time_step_ms()</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        :return: The timestep</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                SELECT simulation_time_step_ms</span>
<span class="sd">                FROM segment</span>
<span class="sd">                LIMIT 1</span>
<span class="sd">                &quot;&quot;&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;simulation_time_step_ms&quot;</span><span class="p">]</span>
        <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span><span class="s2">&quot;No segment data&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_population_id</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">population</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets an ID for this population label.</span>
<span class="sd">        Will create a new population if required.</span>

<span class="sd">        For speed does not verify the additional fields if a record already</span>
<span class="sd">        exists.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param ~spynnaker.pyNN.models.populations.Population population:</span>
<span class="sd">            the population to record for</span>
<span class="sd">        :return: The ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                SELECT pop_id FROM population</span>
<span class="sd">                WHERE label = ?</span>
<span class="sd">                LIMIT 1</span>
<span class="sd">                &quot;&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pop_label</span><span class="p">,)):</span>
            <span class="k">return</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;pop_id&quot;</span><span class="p">]</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            INSERT INTO population</span>
<span class="sd">            (label, first_id, description, pop_size)</span>
<span class="sd">            VALUES (?, ?, ?, ?)</span>
<span class="sd">            &quot;&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pop_label</span><span class="p">,</span> <span class="n">population</span><span class="o">.</span><span class="n">first_id</span><span class="p">,</span> <span class="n">population</span><span class="o">.</span><span class="n">describe</span><span class="p">(),</span>
                  <span class="n">population</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cursor</span><span class="o">.</span><span class="n">lastrowid</span>

    <span class="k">def</span> <span class="nf">__get_recording_id</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span>
            <span class="n">sampling_interval_ms</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">buffered_type</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span>
            <span class="n">atoms_shape</span><span class="p">,</span> <span class="n">n_colour_bits</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets an ID for this population and recording label combination.</span>
<span class="sd">        Will create a new population/recording record if required.</span>

<span class="sd">        For speed does not verify the additional fields if a record already</span>
<span class="sd">        exists.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param str variable:</span>
<span class="sd">        :param ~spynnaker.pyNN.models.populations.Population population:</span>
<span class="sd">            the population to record for</span>
<span class="sd">        :param Population population:</span>
<span class="sd">        :param sampling_interval:</span>
<span class="sd">            The simulation time in milliseconds between sampling.</span>
<span class="sd">            Typically the sampling rate * simulation_timestep_ms</span>
<span class="sd">        :type sampling_interval_ms: float or None</span>
<span class="sd">        :type data_type: DataType or None</span>
<span class="sd">        :param BufferDataType buffered_type:</span>
<span class="sd">        :param str units:</span>
<span class="sd">        :param tuple atoms_shape:</span>
<span class="sd">        :param int n_colour_bits:</span>
<span class="sd">        :return: The ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                SELECT rec_id FROM recording_view</span>
<span class="sd">                WHERE label = ? AND variable = ?</span>
<span class="sd">                LIMIT 1</span>
<span class="sd">                &quot;&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;rec_id&quot;</span><span class="p">]</span>
        <span class="n">pop_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_population_id</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">population</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data_type</span><span class="p">:</span>
            <span class="n">data_type_name</span> <span class="o">=</span> <span class="n">data_type</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_type_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            INSERT INTO recording</span>
<span class="sd">            (pop_id, variable, data_type, buffered_type, t_start,</span>
<span class="sd">            sampling_interval_ms, units, atoms_shape, n_colour_bits)</span>
<span class="sd">            VALUES (?, ?, ?, ?, 0, ?, ?, ?, ?)</span>
<span class="sd">            &quot;&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pop_id</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">data_type_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">buffered_type</span><span class="p">),</span>
                  <span class="n">sampling_interval_ms</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">atoms_shape</span><span class="p">),</span>
                  <span class="n">n_colour_bits</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cursor</span><span class="o">.</span><span class="n">lastrowid</span>

    <span class="k">def</span> <span class="nf">__get_population_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the metadata for the population with this label</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :return: population size, first ID and description</span>
<span class="sd">        :rtype: (int, int, str)</span>
<span class="sd">        :raises \</span>
<span class="sd">            ~spinn_front_end_common.utilities.exceptions.ConfigurationException:</span>
<span class="sd">            If the recording metadata not setup correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                SELECT pop_size, first_id, description</span>
<span class="sd">                FROM population</span>
<span class="sd">                WHERE label = ?</span>
<span class="sd">                LIMIT 1</span>
<span class="sd">                &quot;&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pop_label</span><span class="p">,)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;pop_size&quot;</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;first_id&quot;</span><span class="p">]),</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;description&quot;</span><span class="p">],</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
        <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No metadata for </span><span class="si">{</span><span class="n">pop_label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="NeoBufferDatabase.get_population_metdadata"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.get_population_metdadata">[docs]</a>    <span class="k">def</span> <span class="nf">get_population_metdadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the metadata for the population with this label</span>

<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :return: population size, first id and description</span>
<span class="sd">        :rtype: (int, int, str)</span>
<span class="sd">        :raises \</span>
<span class="sd">            ~spinn_front_end_common.utilities.exceptions.ConfigurationException:</span>
<span class="sd">            If the recording metadata not setup correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_population_metadata</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">)</span></div>

<div class="viewcode-block" id="NeoBufferDatabase.get_recording_populations"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.get_recording_populations">[docs]</a>    <span class="k">def</span> <span class="nf">get_recording_populations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets a list of the labels of Populations recording.</span>
<span class="sd">        Or to be exact the ones with metadata saved so likely to be recording.</span>

<span class="sd">        .. note::</span>
<span class="sd">            These are actually the labels of the Application Vertices.</span>
<span class="sd">            Typically the Population label, corrected for `None` or</span>
<span class="sd">            duplicate values</span>

<span class="sd">        :return: List of population labels</span>
<span class="sd">        :rtype: list(str)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    SELECT label</span>
<span class="sd">                    FROM population</span>
<span class="sd">                    &quot;&quot;&quot;</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">],</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="NeoBufferDatabase.get_population"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.get_population">[docs]</a>    <span class="k">def</span> <span class="nf">get_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets an Object with the same data retrieval API as a Population.</span>

<span class="sd">        Retrieval is limited to recorded data and a little metadata needed to</span>
<span class="sd">        create a single Neo Segment wrapped in a Neo Block.</span>

<span class="sd">        .. note::</span>
<span class="sd">            As each database only includes data for one run (with resets</span>
<span class="sd">            creating another database) the structure is relatively simple.</span>

<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :return: An Object which acts like a Population for getting neo data</span>
<span class="sd">        :rtype: DataPopulation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># delayed import due to circular dependencies</span>
        <span class="kn">from</span> <span class="nn">.data_population</span> <span class="kn">import</span> <span class="n">DataPopulation</span>
        <span class="c1"># DataPopulation validates the pop_label so no need to do hre too</span>
        <span class="k">return</span> <span class="n">DataPopulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_database_file</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">)</span></div>

<div class="viewcode-block" id="NeoBufferDatabase.get_recording_variables"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.get_recording_variables">[docs]</a>    <span class="k">def</span> <span class="nf">get_recording_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of the names of variables recording.</span>
<span class="sd">        Or, to be exact, list of the names of variables with metadata so likely</span>
<span class="sd">        to be recording.</span>

<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :return: List of variable names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_recording_variables</span><span class="p">(</span><span class="n">pop_label</span><span class="p">,</span> <span class="n">cursor</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__get_recording_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">cursor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :return: List of variable registered as recording.</span>
<span class="sd">        Even if there is no data</span>
<span class="sd">        :rtype: list(str)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                SELECT variable</span>
<span class="sd">                FROM recording_view</span>
<span class="sd">                WHERE label = ?</span>
<span class="sd">                GROUP BY variable</span>
<span class="sd">                &quot;&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pop_label</span><span class="p">,)):</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="NeoBufferDatabase.get_recording_metadeta"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.get_recording_metadeta">[docs]</a>    <span class="k">def</span> <span class="nf">get_recording_metadeta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the metadata ID for this population and recording label</span>
<span class="sd">        combination.</span>

<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param str variable:</span>
<span class="sd">        :return: data_type, t_start, sampling_interval_ms, first_id, pop_size,</span>
<span class="sd">            units</span>
<span class="sd">        :rtype: (DataType, float, float, int, int, str)</span>
<span class="sd">        :raises \</span>
<span class="sd">            ~spinn_front_end_common.utilities.exceptions.ConfigurationException:</span>
<span class="sd">            If the recording metadata not setup correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_recording_metadeta</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sampling_interval_ms</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span> <span class="o">=</span> <span class="n">info</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">datatype</span><span class="p">,</span> <span class="n">sampling_interval_ms</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__get_recording_metadeta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the metadata id for this population and recording label</span>
<span class="sd">        combination.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typical the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param str variable:</span>
<span class="sd">        :return:</span>
<span class="sd">            id, data_type, buffered_type,  t_start,</span>
<span class="sd">            sampling_interval_ms, first_id, pop_size, units</span>
<span class="sd">        :rtype:</span>
<span class="sd">            tuple(int, DataType, BufferedDataType, float, float, int, int, str)</span>
<span class="sd">        :raises \</span>
<span class="sd">            ~spinn_front_end_common.utilities.exceptions.ConfigurationException:</span>
<span class="sd">            If the recording metadata not setup correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                SELECT rec_id,  data_type, buffered_type,  t_start,</span>
<span class="sd">                       sampling_interval_ms, pop_size, units, atoms_shape,</span>
<span class="sd">                        n_colour_bits</span>
<span class="sd">                FROM recording_view</span>
<span class="sd">                WHERE label = ? AND variable = ?</span>
<span class="sd">                LIMIT 1</span>
<span class="sd">                &quot;&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;data_type&quot;</span><span class="p">]:</span>
                <span class="n">data_type_st</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;data_type&quot;</span><span class="p">],</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
                <span class="n">data_type</span> <span class="o">=</span> <span class="n">DataType</span><span class="p">[</span><span class="n">data_type_st</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data_type</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]:</span>
                <span class="n">units</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">],</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">units</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">buffered_type</span> <span class="o">=</span> <span class="n">BufferDataType</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;buffered_type&quot;</span><span class="p">],</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)]</span>
            <span class="n">atoms_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">string_to_array</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;atoms_shape&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;rec_id&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">buffered_type</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;t_start&quot;</span><span class="p">],</span>
                    <span class="n">row</span><span class="p">[</span><span class="s2">&quot;sampling_interval_ms&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;pop_size&quot;</span><span class="p">],</span> <span class="n">units</span><span class="p">,</span>
                    <span class="n">atoms_shape</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;n_colour_bits&quot;</span><span class="p">])</span>
        <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;No metadata for </span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2"> on </span><span class="si">{</span><span class="n">pop_label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_region_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param int rec_id:</span>
<span class="sd">        :return:</span>
<span class="sd">            region_id, neurons, vertex_slice, selective_recording, base_key</span>
<span class="sd">        :rtype: iterable(tuple(int, ~numpy.ndarray, Slice, bool, int))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            SELECT region_id, recording_neurons_st, vertex_slice, base_key</span>
<span class="sd">            FROM region_metadata</span>
<span class="sd">            WHERE rec_id = ?</span>
<span class="sd">            ORDER BY region_metadata_id</span>
<span class="sd">            &quot;&quot;&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">rec_id</span><span class="p">]))</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
            <span class="n">vertex_slice</span> <span class="o">=</span> <span class="n">Slice</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;vertex_slice&quot;</span><span class="p">],</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
            <span class="n">recording_neurons_st</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;recording_neurons_st&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">recording_neurons_st</span><span class="p">:</span>
                <span class="n">neurons</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">string_to_array</span><span class="p">(</span>
                    <span class="n">recording_neurons_st</span><span class="p">))</span>
                <span class="n">selective_recording</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span> <span class="o">!=</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">n_atoms</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selective_recording</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">neurons</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;region_id&quot;</span><span class="p">],</span> <span class="n">neurons</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span>
                   <span class="n">selective_recording</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;base_key&quot;</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__get_spikes_by_region</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">neurons</span><span class="p">,</span> <span class="n">simulation_time_step_ms</span><span class="p">,</span>
            <span class="n">selective_recording</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">,</span> <span class="n">spike_ids</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds spike data for this region to the lists.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param int region_id: Region data came from</span>
<span class="sd">        :param array(int) neurons: mapping of local ID to global ID</span>
<span class="sd">        :param float simulation_time_step_ms:</span>
<span class="sd">        :param bool selective_recording: flag to say if</span>
<span class="sd">        :param list(float) spike_times: List to add spike times to</span>
<span class="sd">        :param list(int) spike_ids: List to add spike IDs to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">neurons_recording</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">neurons_recording</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">n_words</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">neurons_recording</span> <span class="o">/</span> <span class="n">BITS_PER_WORD</span><span class="p">))</span>
        <span class="n">n_bytes</span> <span class="o">=</span> <span class="n">n_words</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
        <span class="n">n_words_with_timestamp</span> <span class="o">=</span> <span class="n">n_words</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">record_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_contents</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">record_raw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">raw_data</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">record_raw</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;&lt;i4&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_words_with_timestamp</span><span class="p">])</span>

        <span class="n">record_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">raw_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">simulation_time_step_ms</span><span class="p">)</span>
        <span class="n">spikes</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">byteswap</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">(</span><span class="n">spikes</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">)))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_bytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">time_indices</span><span class="p">,</span> <span class="n">local_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bits</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">selective_recording</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">time_indice</span><span class="p">,</span> <span class="n">local</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">time_indices</span><span class="p">,</span> <span class="n">local_indices</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">local</span> <span class="o">&lt;</span> <span class="n">neurons_recording</span><span class="p">:</span>
                    <span class="n">spike_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neurons</span><span class="p">[</span><span class="n">local</span><span class="p">])</span>
                    <span class="n">spike_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">record_time</span><span class="p">[</span><span class="n">time_indice</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">neurons</span><span class="p">[</span><span class="n">local_indices</span><span class="p">]</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">record_time</span><span class="p">[</span><span class="n">time_indices</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">spike_ids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">spike_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_neuron_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the spikes for this population/recording ID.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param int rec_id:</span>
<span class="sd">        :return: numpy array of spike IDs and spike times, all IDs recording</span>
<span class="sd">        :rtype: tuple(~numpy.ndarray, list(int))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spike_times</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">spike_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">simulation_time_step_ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_simulation_time_step_ms</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">neurons</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">selective_recording</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">__get_region_metadata</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">):</span>
            <span class="n">indexes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_spikes_by_region</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">neurons</span><span class="p">,</span> <span class="n">simulation_time_step_ms</span><span class="p">,</span>
                <span class="n">selective_recording</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">,</span> <span class="n">spike_ids</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">spike_ids</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">spike_ids</span><span class="p">))],</span> <span class="n">indexes</span>

    <span class="k">def</span> <span class="nf">__get_eieio_spike_by_region</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">simulation_time_step_ms</span><span class="p">,</span> <span class="n">base_key</span><span class="p">,</span>
            <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">atoms_shape</span><span class="p">,</span> <span class="n">n_colour_bits</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds spike data for this region to the list.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param int region_id: Region data came from</span>
<span class="sd">        :param float simulation_time_step_ms:</span>
<span class="sd">        :param int base_key:</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">        :param tuple(int) atoms_shape:</span>
<span class="sd">        :param int n_colour_bits:</span>
<span class="sd">        :return: all recording indexes spikes or not</span>
<span class="sd">        :rtype: list(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spike_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_contents</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">)</span>

        <span class="n">number_of_bytes_written</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_data</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">get_field_based_index</span><span class="p">(</span><span class="n">base_key</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">n_colour_bits</span><span class="p">)</span>
        <span class="n">slice_ids</span> <span class="o">=</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">get_raster_ids</span><span class="p">(</span><span class="n">atoms_shape</span><span class="p">)</span>
        <span class="n">colour_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n_colour_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">inv_colour_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">colour_mask</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span>
        <span class="k">while</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">number_of_bytes_written</span><span class="p">:</span>
            <span class="n">length</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__TWO_WORDS</span><span class="o">.</span><span class="n">unpack_from</span><span class="p">(</span><span class="n">spike_data</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="n">time</span> <span class="o">*=</span> <span class="n">simulation_time_step_ms</span>
            <span class="n">data_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>

            <span class="n">eieio_header</span> <span class="o">=</span> <span class="n">EIEIODataHeader</span><span class="o">.</span><span class="n">from_bytestring</span><span class="p">(</span>
                <span class="n">spike_data</span><span class="p">,</span> <span class="n">data_offset</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">eieio_header</span><span class="o">.</span><span class="n">eieio_type</span><span class="o">.</span><span class="n">payload_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only read spikes as keys&quot;</span><span class="p">)</span>

            <span class="n">data_offset</span> <span class="o">+=</span> <span class="n">eieio_header</span><span class="o">.</span><span class="n">size</span>
            <span class="n">timestamps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">time</span><span class="p">],</span> <span class="n">eieio_header</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
            <span class="n">key_bytes</span> <span class="o">=</span> <span class="n">eieio_header</span><span class="o">.</span><span class="n">eieio_type</span><span class="o">.</span><span class="n">key_bytes</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span>
                <span class="n">spike_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;&lt;u</span><span class="si">{</span><span class="n">key_bytes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">count</span><span class="o">=</span><span class="n">eieio_header</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">data_offset</span><span class="p">)</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">inv_colour_mask</span><span class="p">)</span>
            <span class="n">local_ids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">])</span>
            <span class="n">neuron_ids</span> <span class="o">=</span> <span class="n">slice_ids</span><span class="p">[</span><span class="n">local_ids</span><span class="p">]</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">neuron_ids</span><span class="p">,</span> <span class="n">timestamps</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">slice_ids</span>

    <span class="k">def</span> <span class="nf">__get_eieio_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">atoms_shape</span><span class="p">,</span> <span class="n">n_colour_bits</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the spikes for this population/recording ID.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param int rec_id:</span>
<span class="sd">        :param tuple(int) atoms_shape:</span>
<span class="sd">        :param int n_colour_bits:</span>
<span class="sd">        :return: numpy array of spike IDs and spike times, all IDs recording</span>
<span class="sd">        :rtype: tuple(~numpy.ndarray, list(int))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">simulation_time_step_ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_simulation_time_step_ms</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">selective_recording</span><span class="p">,</span> <span class="n">base_key</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">__get_region_metadata</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">selective_recording</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to handle selective recording&quot;</span><span class="p">)</span>
            <span class="n">indexes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_eieio_spike_by_region</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">simulation_time_step_ms</span><span class="p">,</span>
                <span class="n">base_key</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">atoms_shape</span><span class="p">,</span>
                <span class="n">n_colour_bits</span><span class="p">,</span> <span class="n">results</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">results</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">indexes</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">result</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">result</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))],</span> <span class="n">indexes</span>

    <span class="k">def</span> <span class="nf">__get_multi_spikes_by_region</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">neurons</span><span class="p">,</span> <span class="n">simulation_time_step_ms</span><span class="p">,</span>
            <span class="n">spike_times</span><span class="p">,</span> <span class="n">spike_ids</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds spike data for this region to the lists.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param int region_id: Region data came from</span>
<span class="sd">        :param ~numpy.ndarray neurons:</span>
<span class="sd">        :param float simulation_time_step_ms:</span>
<span class="sd">        :param list(float) spike_times: List to add spike times to</span>
<span class="sd">        :param list(int) spike_ids: List to add spike IDs to</span>
<span class="sd">        :return: all recording indexes spikes or not</span>
<span class="sd">        :rtype: list(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_contents</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">)</span>

        <span class="n">n_words</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span> <span class="o">/</span> <span class="n">BITS_PER_WORD</span><span class="p">))</span>
        <span class="n">n_bytes_per_block</span> <span class="o">=</span> <span class="n">n_words</span> <span class="o">*</span> <span class="n">BYTES_PER_WORD</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw_data</span><span class="p">):</span>
            <span class="n">time</span><span class="p">,</span> <span class="n">n_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__TWO_WORDS</span><span class="o">.</span><span class="n">unpack_from</span><span class="p">(</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__TWO_WORDS</span><span class="o">.</span><span class="n">size</span>
            <span class="n">spike_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span>
                <span class="n">raw_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint8&quot;</span><span class="p">,</span>
                <span class="n">count</span><span class="o">=</span><span class="n">n_bytes_per_block</span> <span class="o">*</span> <span class="n">n_blocks</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">n_bytes_per_block</span> <span class="o">*</span> <span class="n">n_blocks</span>

            <span class="n">spikes</span> <span class="o">=</span> <span class="n">spike_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;&lt;i4&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">byteswap</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span>
            <span class="n">bits</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">(</span><span class="n">spikes</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">)))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_bytes_per_block</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span>
            <span class="n">local_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">bits</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">neurons</span><span class="p">[</span><span class="n">local_indices</span><span class="p">]</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">time</span> <span class="o">*</span> <span class="n">simulation_time_step_ms</span><span class="p">],</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
            <span class="n">spike_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">spike_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_multi_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the spikes for this population/recording ID.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param int rec_id:</span>
<span class="sd">        :return: numpy array of spike IDs and spike times, all IDs recording</span>
<span class="sd">        :rtype: tuple(~numpy.ndarray, list(int))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spike_times</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">spike_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">simulation_time_step_ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_simulation_time_step_ms</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">neurons</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">selective_recording</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">__get_region_metadata</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">selective_recording</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to handle selective recording&quot;</span><span class="p">)</span>
            <span class="n">indexes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_multi_spikes_by_region</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">neurons</span><span class="p">,</span> <span class="n">simulation_time_step_ms</span><span class="p">,</span>
                <span class="n">spike_times</span><span class="p">,</span> <span class="n">spike_ids</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">spike_ids</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">indexes</span>

        <span class="n">spike_ids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">spike_ids</span><span class="p">)</span>
        <span class="n">spike_times</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">spike_ids</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">spike_ids</span><span class="p">))],</span> <span class="n">indexes</span>

    <span class="k">def</span> <span class="nf">__combine_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">data_indexes</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param view_indexes:</span>
<span class="sd">        :param data_indexes:</span>
<span class="sd">        :param str variable:</span>
<span class="sd">        :return: indices</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># keep just the view indexes in the data</span>
        <span class="n">data_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">data_indexes</span><span class="p">)</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">view_indexes</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data_set</span><span class="p">]</span>
        <span class="c1"># check for missing and report</span>
        <span class="n">view_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">view_indexes</span><span class="p">)</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="n">view_set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">data_indexes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="n">missing_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>
            <span class="n">missing_list</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No </span><span class="si">{}</span><span class="s2"> available for neurons </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">,</span>
                           <span class="n">variable</span><span class="p">,</span> <span class="n">missing_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indexes</span>

    <span class="k">def</span> <span class="nf">__get_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">buffer_type</span><span class="p">,</span>
                     <span class="n">atoms_shape</span><span class="p">,</span> <span class="n">n_colour_bits</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the data as a Numpy array for one population and variable.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param int rec_id:</span>
<span class="sd">        :param list(int) view_indexes:</span>
<span class="sd">        :param buffer_type:</span>
<span class="sd">        :param tuple(int) atoms_shape:</span>
<span class="sd">        :param int n_colour_bits:</span>
<span class="sd">        :param str variable:</span>
<span class="sd">        :raises \</span>
<span class="sd">            ~spinn_front_end_common.utilities.exceptions.ConfigurationException:</span>
<span class="sd">            If the recording metadata not setup correctly</span>
<span class="sd">        :rtype: tuple(~numpy.ndarray, list(int))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">buffer_type</span> <span class="o">==</span> <span class="n">BufferDataType</span><span class="o">.</span><span class="n">NEURON_SPIKES</span><span class="p">:</span>
            <span class="n">spikes</span><span class="p">,</span> <span class="n">data_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_neuron_spikes</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">buffer_type</span> <span class="o">==</span> <span class="n">BufferDataType</span><span class="o">.</span><span class="n">EIEIO_SPIKES</span><span class="p">:</span>
            <span class="n">spikes</span><span class="p">,</span> <span class="n">data_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_eieio_spikes</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">atoms_shape</span><span class="p">,</span> <span class="n">n_colour_bits</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">buffer_type</span> <span class="o">==</span> <span class="n">BufferDataType</span><span class="o">.</span><span class="n">MULTI_SPIKES</span><span class="p">:</span>
            <span class="n">spikes</span><span class="p">,</span> <span class="n">data_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_multi_spikes</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">buffer_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">view_indexes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">(</span><span class="n">view_indexes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_indexes</span><span class="p">):</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_indexes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># keep just the view indexes in the data</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__combine_indexes</span><span class="p">(</span>
                <span class="n">view_indexes</span><span class="p">,</span> <span class="n">data_indexes</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
            <span class="c1"># keep just data columns in the view</span>
            <span class="n">spikes</span> <span class="o">=</span> <span class="n">spikes</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">spikes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">indexes</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">indexes</span>

    <span class="k">def</span> <span class="nf">__get_matrix_data_by_region</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">neurons</span><span class="p">,</span> <span class="n">data_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts data for this region.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param int region_id: Region data came from</span>
<span class="sd">        :param array(int) neurons: mapping of local ID to global ID</span>
<span class="sd">        :param DataType data_type: type of data to extract</span>
<span class="sd">        :return: times, data</span>
<span class="sd">        :rtype: tuple(~numpy.ndarray, ~numpy.ndarray)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># for buffering output info is taken form the buffer manager</span>
        <span class="n">record_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_contents</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">)</span>
        <span class="n">record_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">record_raw</span><span class="p">)</span>

        <span class="c1"># There is one column for time and one for each neuron recording</span>
        <span class="n">data_row_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span> <span class="o">*</span> <span class="n">data_type</span><span class="o">.</span><span class="n">size</span>
        <span class="n">full_row_length</span> <span class="o">=</span> <span class="n">data_row_length</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__N_BYTES_FOR_TIMESTAMP</span>
        <span class="n">n_rows</span> <span class="o">=</span> <span class="n">record_length</span> <span class="o">//</span> <span class="n">full_row_length</span>
        <span class="n">row_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">record_raw</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">n_rows</span><span class="p">,</span> <span class="n">full_row_length</span><span class="p">)</span>

        <span class="n">time_bytes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">row_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__N_BYTES_FOR_TIMESTAMP</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">n_rows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__N_BYTES_FOR_TIMESTAMP</span><span class="p">))</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">time_bytes</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;&lt;i4&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_rows</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">var_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_data</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__N_BYTES_FOR_TIMESTAMP</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">n_rows</span> <span class="o">*</span> <span class="n">data_row_length</span><span class="p">))</span>
        <span class="n">placement_data</span> <span class="o">=</span> <span class="n">data_type</span><span class="o">.</span><span class="n">decode_array</span><span class="p">(</span><span class="n">var_data</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">n_rows</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">neurons</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">placement_data</span>

    <span class="k">def</span> <span class="nf">__get_matrix_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">pop_size</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the matrix data  for this population/recording ID.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param int rec_id:</span>
<span class="sd">        :param DataType data_type: type of data to extract</span>
<span class="sd">        :param view_indexes:</span>
<span class="sd">            The indexes for which data should be returned. Or `None` for all</span>
<span class="sd">        :type view_indexes: list(int) or None</span>
<span class="sd">        :param int pop_size:</span>
<span class="sd">        :param str variable:</span>
<span class="sd">        :return: numpy array of the data, neurons</span>
<span class="sd">        :rtype: tuple(~numpy.ndarray, ~numpy.ndarray or list(int))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">signal_array</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">pop_times</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">pop_neurons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">neurons</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">__get_region_metadata</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">neurons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pop_neurons</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="n">neurons</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">times</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_matrix_data_by_region</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">neurons</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">signal_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">signal_array</span> <span class="o">=</span> <span class="n">data</span>
                <span class="n">pop_times</span> <span class="o">=</span> <span class="n">times</span>
            <span class="k">elif</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">pop_times</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
                <span class="n">signal_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">signal_array</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;times differ&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">signal_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal_array</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pop_neurons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">view_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SpynnakerException</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2"> data can not be extracted using a view&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">signal_array</span><span class="p">,</span> <span class="n">indexes</span>

        <span class="n">data_indexes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pop_neurons</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">view_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">view_indexes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">pop_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">view_indexes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_indexes</span><span class="p">):</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_indexes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># keep just the view indexes in the data</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__combine_indexes</span><span class="p">(</span>
                <span class="n">view_indexes</span><span class="p">,</span> <span class="n">data_indexes</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
            <span class="c1"># keep just data columns in the view</span>
            <span class="n">map_indexes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">data_indexes</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
            <span class="n">signal_array</span> <span class="o">=</span> <span class="n">signal_array</span><span class="p">[:,</span> <span class="n">map_indexes</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">signal_array</span><span class="p">,</span> <span class="n">indexes</span>

    <span class="k">def</span> <span class="nf">__get_rewires_by_region</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">rewire_values</span><span class="p">,</span>
            <span class="n">rewire_postids</span><span class="p">,</span> <span class="n">rewire_preids</span><span class="p">,</span> <span class="n">rewire_times</span><span class="p">,</span> <span class="n">sampling_interval_ms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts rewires data for this region and adds it to the lists.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param int region_id: Region data came from</span>
<span class="sd">        :param ~pacman.model.graphs.common.Slice vertex_slice:</span>
<span class="sd">            slice of this region</span>
<span class="sd">        :param list(int) rewire_values:</span>
<span class="sd">        :param list(int) rewire_postids:</span>
<span class="sd">        :param list(int) rewire_preids:</span>
<span class="sd">        :param list(int) rewire_times:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">record_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_contents</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">record_raw</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">record_raw</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;&lt;i4&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__REWIRING_N_WORDS</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">record_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">raw_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sampling_interval_ms</span><span class="p">)</span>
        <span class="n">rewires_raw</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">rew_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rewires_raw</span><span class="p">)</span>
        <span class="c1"># rewires is 0 (elimination) or 1 (formation) in the first bit</span>
        <span class="n">rewires</span> <span class="o">=</span> <span class="p">[</span><span class="n">rewires_raw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">__FIRST_BIT</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rew_length</span><span class="p">)]</span>
        <span class="c1"># the post-neuron ID is stored in the next 8 bytes</span>
        <span class="n">post_ids</span> <span class="o">=</span> <span class="p">[((</span><span class="nb">int</span><span class="p">(</span><span class="n">rewires_raw</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">__POST_ID_SHIFT</span><span class="p">)</span> <span class="o">%</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">__POST_ID_FACTOR</span><span class="p">)</span> <span class="o">+</span> <span class="n">vertex_slice</span><span class="o">.</span><span class="n">lo_atom</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rew_length</span><span class="p">)]</span>
        <span class="c1"># the pre-neuron ID is stored in the remaining 23 bytes</span>
        <span class="n">pre_ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">rewires_raw</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">__PRE_ID_SHIFT</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rew_length</span><span class="p">)]</span>

        <span class="n">rewire_values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rewires</span><span class="p">)</span>
        <span class="n">rewire_postids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">post_ids</span><span class="p">)</span>
        <span class="n">rewire_preids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pre_ids</span><span class="p">)</span>
        <span class="n">rewire_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">record_time</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_rewires</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">sampling_interval_ms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts rewires data for this region.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param int rec_id:</span>
<span class="sd">        :return: (rewire_values, rewire_postids, rewire_preids, rewire_times)</span>
<span class="sd">        :rtype: ~numpy.ndarray(tuple(int, int, int, int))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rewire_times</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">rewire_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">rewire_postids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">rewire_preids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">__get_region_metadata</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">):</span>
            <span class="c1"># as no neurons for &quot;rewires&quot; selective_recording will be true</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">__get_rewires_by_region</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">,</span> <span class="n">rewire_values</span><span class="p">,</span>
                <span class="n">rewire_postids</span><span class="p">,</span> <span class="n">rewire_preids</span><span class="p">,</span> <span class="n">rewire_times</span><span class="p">,</span>
                <span class="n">sampling_interval_ms</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rewire_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span>
            <span class="p">(</span><span class="n">rewire_times</span><span class="p">,</span> <span class="n">rewire_preids</span><span class="p">,</span> <span class="n">rewire_postids</span><span class="p">,</span> <span class="n">rewire_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span>
            <span class="p">(</span><span class="n">rewire_values</span><span class="p">,</span> <span class="n">rewire_postids</span><span class="p">,</span> <span class="n">rewire_preids</span><span class="p">,</span> <span class="n">rewire_times</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">__get_recorded_pynn7</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">sampling_interval_ms</span><span class="p">,</span>
            <span class="n">as_matrix</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">pop_size</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get recorded data in PyNN 0.7 format. Must not be spikes.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param int rec_id:</span>
<span class="sd">        :param DataType data_type: type of data to extract</span>
<span class="sd">        :param float sampling_interval_ms:</span>
<span class="sd">        :param bool as_matrix:</span>
<span class="sd">        :param view_indexes:</span>
<span class="sd">            The indexes for which data should be returned. Or `None` for all</span>
<span class="sd">        :type view_indexes: list(int) or None</span>
<span class="sd">        :param int pop_size:</span>
<span class="sd">        :param str variable:</span>
<span class="sd">        :rtype: ~numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_matrix_data</span><span class="p">(</span>
            <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">pop_size</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">as_matrix</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>

        <span class="c1"># Convert to triples as Pynn 0,7 did</span>
        <span class="n">n_machine_time_steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">n_neurons</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
        <span class="n">column_length</span> <span class="o">=</span> <span class="n">n_machine_time_steps</span> <span class="o">*</span> <span class="n">n_neurons</span>
        <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">sampling_interval_ms</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_machine_time_steps</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">n_machine_time_steps</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">),</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">column_length</span><span class="p">)))</span>

<div class="viewcode-block" id="NeoBufferDatabase.spinnaker_get_data"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.spinnaker_get_data">[docs]</a>    <span class="k">def</span> <span class="nf">spinnaker_get_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">view_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ConfigurationException</span><span class="p">(</span>
                    <span class="s2">&quot;Only one type of data at a time is supported&quot;</span><span class="p">)</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="c1"># called to trigger the virtual data warning if applicable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_segment_info</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span>
            <span class="p">(</span><span class="n">rec_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">buffered_type</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sampling_interval_ms</span><span class="p">,</span>
             <span class="n">pop_size</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">atoms_shape</span><span class="p">,</span> <span class="n">n_colour_bits</span><span class="p">)</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">__get_recording_metadeta</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">buffered_type</span> <span class="o">==</span> <span class="n">BufferDataType</span><span class="o">.</span><span class="n">MATRIX</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_recorded_pynn7</span><span class="p">(</span>
                    <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">sampling_interval_ms</span><span class="p">,</span>
                    <span class="n">as_matrix</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">pop_size</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
            <span class="c1"># NO BufferedDataType.REWIRES get_spike will go boom</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">as_matrix</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Ignoring as matrix for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_spikes</span><span class="p">(</span>
                    <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">buffered_type</span><span class="p">,</span> <span class="n">atoms_shape</span><span class="p">,</span>
                    <span class="n">n_colour_bits</span><span class="p">,</span> <span class="n">variable</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="NeoBufferDatabase.get_spike_counts"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.get_spike_counts">[docs]</a>    <span class="k">def</span> <span class="nf">get_spike_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">view_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="c1"># called to trigger the virtual data warning if applicable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_segment_info</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span>
            <span class="p">(</span><span class="n">rec_id</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">buffered_type</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">pop_size</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">atoms_shape</span><span class="p">,</span>
             <span class="n">n_colour_bits</span><span class="p">)</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">__get_recording_metadeta</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">SPIKES</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">view_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">view_indexes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">pop_size</span><span class="p">)</span>

            <span class="c1"># get_spike will go boom if buffered_type not spikes</span>
            <span class="n">spikes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_spikes</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">buffered_type</span><span class="p">,</span> <span class="n">atoms_shape</span><span class="p">,</span>
                <span class="n">n_colour_bits</span><span class="p">,</span> <span class="n">SPIKES</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">spikes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                                <span class="n">minlength</span><span class="o">=</span><span class="n">pop_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">view_indexes</span><span class="p">}</span></div>

    <span class="k">def</span> <span class="nf">__add_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the data as a Numpy array for one population and variable.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param str variable:</span>
<span class="sd">        :param ~neo.core.Block block: neo block</span>
<span class="sd">        :param ~neo.core.Segment segment: Segment to add data to</span>
<span class="sd">        :param float t_stop:</span>
<span class="sd">        :raises \</span>
<span class="sd">            ~spinn_front_end_common.utilities.exceptions.ConfigurationException:</span>
<span class="sd">            If the recording metadata not setup correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">rec_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">buffer_type</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">sampling_interval_ms</span><span class="p">,</span>
         <span class="n">pop_size</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">atoms_shape</span><span class="p">,</span> <span class="n">n_colour_bits</span><span class="p">)</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_recording_metadeta</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">buffer_type</span> <span class="o">==</span> <span class="n">BufferDataType</span><span class="o">.</span><span class="n">MATRIX</span><span class="p">:</span>
            <span class="n">signal_array</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_matrix_data</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">pop_size</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
            <span class="n">sampling_rate</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">/</span><span class="n">sampling_interval_ms</span> <span class="o">*</span> <span class="n">quantities</span><span class="o">.</span><span class="n">Hz</span>
            <span class="n">t_start</span> <span class="o">=</span> <span class="n">t_start</span> <span class="o">*</span> <span class="n">quantities</span><span class="o">.</span><span class="n">ms</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_insert_matrix_data</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="n">signal_array</span><span class="p">,</span>
                <span class="n">indexes</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">buffer_type</span> <span class="o">==</span> <span class="n">BufferDataType</span><span class="o">.</span><span class="n">REWIRES</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">view_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SpynnakerException</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2"> can not be extracted using a view&quot;</span><span class="p">)</span>
            <span class="n">event_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_rewires</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">sampling_interval_ms</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_insert_neo_rewirings</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">event_array</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">view_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">view_indexes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">pop_size</span><span class="p">)</span>
            <span class="n">spikes</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_spikes</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">buffer_type</span><span class="p">,</span> <span class="n">atoms_shape</span><span class="p">,</span>
                <span class="n">n_colour_bits</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
            <span class="n">sampling_rate</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">sampling_interval_ms</span> <span class="o">*</span> <span class="n">quantities</span><span class="o">.</span><span class="n">Hz</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_insert_spike_data</span><span class="p">(</span>
                <span class="n">view_indexes</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span>
                <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__read_and_csv_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">csv_writer</span><span class="p">,</span>
                            <span class="n">view_indexes</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the data for one variable and adds it to the CSV file.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param str variable:</span>
<span class="sd">        :param ~csv.writer csv_writer: Open CSV writer to write to</span>
<span class="sd">        :param view_indexes:</span>
<span class="sd">        :type view_indexes: None, ~numpy.array or list(int)</span>
<span class="sd">        :param float t_stop:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">rec_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">buffer_type</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">sampling_interval_ms</span><span class="p">,</span>
         <span class="n">pop_size</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">atoms_shape</span><span class="p">,</span> <span class="n">n_colour_bits</span><span class="p">)</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_recording_metadeta</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">buffer_type</span> <span class="o">==</span> <span class="n">BufferDataType</span><span class="o">.</span><span class="n">MATRIX</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csv_variable_metdata</span><span class="p">(</span>
                <span class="n">csv_writer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MATRIX</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span>
                <span class="n">sampling_interval_ms</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>
            <span class="n">signal_array</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_matrix_data</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">pop_size</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csv_matrix_data</span><span class="p">(</span><span class="n">csv_writer</span><span class="p">,</span> <span class="n">signal_array</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">buffer_type</span> <span class="o">==</span> <span class="n">BufferDataType</span><span class="o">.</span><span class="n">REWIRES</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csv_variable_metdata</span><span class="p">(</span>
                <span class="n">csv_writer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EVENT</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span>
                <span class="n">sampling_interval_ms</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">view_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SpynnakerException</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2"> can not be extracted using a view&quot;</span><span class="p">)</span>
            <span class="n">event_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_rewires</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">sampling_interval_ms</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csv_rewirings</span><span class="p">(</span><span class="n">csv_writer</span><span class="p">,</span> <span class="n">event_array</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csv_variable_metdata</span><span class="p">(</span>
                <span class="n">csv_writer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SPIKES</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span>
                <span class="n">sampling_interval_ms</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>
            <span class="n">spikes</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_spikes</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">buffer_type</span><span class="p">,</span> <span class="n">atoms_shape</span><span class="p">,</span>
                <span class="n">n_colour_bits</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csv_spike_data</span><span class="p">(</span><span class="n">csv_writer</span><span class="p">,</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_empty_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">annotations</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param variables:</span>
<span class="sd">            One or more variable names or `None` for all available</span>
<span class="sd">        :type variables: str, list(str) or None</span>
<span class="sd">        :param view_indexes: List of neurons IDs to include or `None` for all</span>
<span class="sd">        :type view_indexes: None or list(int)</span>
<span class="sd">        :param annotations: annotations to put on the neo block</span>
<span class="sd">        :type annotations: None or dict(str, ...)</span>
<span class="sd">        :return: The Neo block</span>
<span class="sd">        :rtype: ~neo.core.Block</span>
<span class="sd">        :raises \</span>
<span class="sd">            ~spinn_front_end_common.utilities.exceptions.ConfigurationException:</span>
<span class="sd">            If the recording metadata not setup correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">simulator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_segment_info</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span>
        <span class="n">pop_size</span><span class="p">,</span> <span class="n">first_id</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_population_metadata</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insert_empty_block</span><span class="p">(</span>
            <span class="n">pop_label</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">pop_size</span><span class="p">,</span> <span class="n">first_id</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">simulator</span><span class="p">,</span>
            <span class="n">annotations</span><span class="p">)</span>

<div class="viewcode-block" id="NeoBufferDatabase.get_empty_block"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.get_empty_block">[docs]</a>    <span class="k">def</span> <span class="nf">get_empty_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">annotations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a block with just metadata but not data segments.</span>

<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param variables:</span>
<span class="sd">            One or more variable names or `None` for all available</span>
<span class="sd">        :type variables: str, list(str) or None</span>
<span class="sd">        :param view_indexes: List of neurons IDs to include or `None` for all</span>
<span class="sd">        :type view_indexes: None or list(int)</span>
<span class="sd">        :param annotations: annotations to put on the neo block</span>
<span class="sd">        :type annotations: None or dict(str, ...)</span>
<span class="sd">        :return: The Neo block</span>
<span class="sd">        :rtype: ~neo.core.Block</span>
<span class="sd">        :raises \</span>
<span class="sd">            ~spinn_front_end_common.utilities.exceptions.ConfigurationException:</span>
<span class="sd">            If the recording metadata not setup correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_empty_block</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">annotations</span><span class="p">)</span></div>

<div class="viewcode-block" id="NeoBufferDatabase.get_full_block"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.get_full_block">[docs]</a>    <span class="k">def</span> <span class="nf">get_full_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">annotations</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a block with metadata and data for this segment.</span>
<span class="sd">        Any previous segments will be empty.</span>

<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param variables:</span>
<span class="sd">            One or more variable names or `None` for all available</span>
<span class="sd">        :type variables: str, list(str) or None</span>
<span class="sd">        :param view_indexes: List of neurons IDs to include or `None` for all</span>
<span class="sd">        :type view_indexes: None or list(int)</span>
<span class="sd">        :param annotations: annotations to put on the neo block</span>
<span class="sd">        :type annotations: None or dict(str, ...)</span>
<span class="sd">        :return: The Neo block</span>
<span class="sd">        :rtype: ~neo.core.Block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_empty_block</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">annotations</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__add_segment</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">block</span></div>

<div class="viewcode-block" id="NeoBufferDatabase.csv_segment"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.csv_segment">[docs]</a>    <span class="k">def</span> <span class="nf">csv_segment</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>  <span class="n">csv_file</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">view_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the data including metadata to a CSV file.</span>

<span class="sd">        :param str csvfile: Path to file to write block metadata to</span>
<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typical the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param variables:</span>
<span class="sd">            One or more variable names or `None` for all available</span>
<span class="sd">        :type variables: str, list(str) or None</span>
<span class="sd">        :param view_indexes: List of neurons IDs to include or `None` for all</span>
<span class="sd">        :type view_indexes: None or list(int)</span>
<span class="sd">        :raises \</span>
<span class="sd">            ~spinn_front_end_common.utilities.exceptions.ConfigurationException:</span>
<span class="sd">            If the recording metadata not setup correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">csv_file</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SpynnakerException</span><span class="p">(</span><span class="s2">&quot;PLease call csv_block_metadata first&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">csvfile</span><span class="p">:</span>
            <span class="n">csv_writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">csvfile</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
                                    <span class="n">quoting</span><span class="o">=</span><span class="n">csv</span><span class="o">.</span><span class="n">QUOTE_MINIMAL</span><span class="p">)</span>

            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
                <span class="n">segment_number</span><span class="p">,</span> <span class="n">rec_datetime</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">__get_segment_info</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_csv_segment_metadata</span><span class="p">(</span>
                    <span class="n">csv_writer</span><span class="p">,</span> <span class="n">segment_number</span><span class="p">,</span> <span class="n">rec_datetime</span><span class="p">)</span>

                <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__clean_variables</span><span class="p">(</span>
                    <span class="n">variables</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">cursor</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__read_and_csv_data</span><span class="p">(</span>
                        <span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">csv_writer</span><span class="p">,</span>
                        <span class="n">view_indexes</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">)</span></div>

<div class="viewcode-block" id="NeoBufferDatabase.csv_block_metadata"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.csv_block_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">csv_block_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">csv_file</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">annotations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the data including metadata to a CSV file.</span>
<span class="sd">        Overwrites any previous data in the file.</span>

<span class="sd">        :param str csvfile: Path to file to write block metadata to</span>
<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param annotations: annotations to put on the neo block</span>
<span class="sd">        :type annotations: None or dict(str, ...)</span>
<span class="sd">        :raises \</span>
<span class="sd">            ~spinn_front_end_common.utilities.exceptions.ConfigurationException:</span>
<span class="sd">            If the recording metadata not setup correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>  <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">csvfile</span><span class="p">:</span>
            <span class="n">csv_writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">csvfile</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
                                    <span class="n">quoting</span><span class="o">=</span><span class="n">csv</span><span class="o">.</span><span class="n">QUOTE_MINIMAL</span><span class="p">)</span>

            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_segment_info</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span>
                <span class="n">pop_size</span><span class="p">,</span> <span class="n">first_id</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">__get_population_metadata</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_csv_block_metadat</span><span class="p">(</span>
                    <span class="n">csv_writer</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">pop_size</span><span class="p">,</span> <span class="n">first_id</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span>
                    <span class="n">annotations</span><span class="p">)</span></div>

<div class="viewcode-block" id="NeoBufferDatabase.add_segment"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.add_segment">[docs]</a>    <span class="k">def</span> <span class="nf">add_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">view_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a segment to the block.</span>

<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param variables:</span>
<span class="sd">            One or more variable names or `None` for all available</span>
<span class="sd">        :type variables: str, list(str) or None</span>
<span class="sd">        :param view_indexes: List of neurons IDs to include or `None` for all</span>
<span class="sd">        :type view_indexes: None or list(int)</span>
<span class="sd">        :raises \</span>
<span class="sd">            ~spinn_front_end_common.utilities.exceptions.ConfigurationException:</span>
<span class="sd">            If the recording metadata not setup correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__add_segment</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__clean_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">cursor</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">variables</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_recording_variables</span><span class="p">(</span><span class="n">pop_label</span><span class="p">,</span> <span class="n">cursor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">variables</span>

    <span class="k">def</span> <span class="nf">__add_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a segment to the block.</span>

<span class="sd">        :param ~sqlite3.Cursor cursor:</span>
<span class="sd">        :param  ~neo.core.Block block:</span>
<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typically the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param variables:</span>
<span class="sd">            One or more variable names or `None` for all available</span>
<span class="sd">        :type variables: str, list(str) or None</span>
<span class="sd">        :param view_indexes: List of neurons IDs to include or `None` for all</span>
<span class="sd">        :type view_indexes: None or list(int)</span>
<span class="sd">        :raises \</span>
<span class="sd">            ~spinn_front_end_common.utilities.exceptions.ConfigurationException:</span>
<span class="sd">            If the recording metadata not setup correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segment_number</span><span class="p">,</span> <span class="n">rec_datetime</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">__get_segment_info</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span>
        <span class="n">segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insert_empty_segment</span><span class="p">(</span>
            <span class="n">block</span><span class="p">,</span> <span class="n">segment_number</span><span class="p">,</span> <span class="n">rec_datetime</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__clean_variables</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">cursor</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__add_data</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="n">view_indexes</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">)</span>

<div class="viewcode-block" id="NeoBufferDatabase.clear_data"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.clear_data">[docs]</a>    <span class="k">def</span> <span class="nf">clear_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears the data for one population and given variables.</span>

<span class="sd">        .. note:::</span>
<span class="sd">            The database must be writable for this to work!</span>

<span class="sd">        :param str pop_label: The label for the population of interest</span>

<span class="sd">            .. note::</span>
<span class="sd">                This is actually the label of the Application Vertex.</span>
<span class="sd">                Typical the Population label, corrected for `None` or</span>
<span class="sd">                duplicate values</span>

<span class="sd">        :param list(str) variables: names of variable to get data for</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_current_run_time_ms</span><span class="p">()</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__clean_variables</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">cursor</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    UPDATE recording SET</span>
<span class="sd">                        t_start = ?</span>
<span class="sd">                    WHERE rec_id in</span>
<span class="sd">                        (SELECT rec_id</span>
<span class="sd">                        FROM recording_view</span>
<span class="sd">                        WHERE label = ? AND variable = ?)</span>
<span class="sd">                    &quot;&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">))</span>
                <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    UPDATE region SET</span>
<span class="sd">                        content = CAST(&#39;&#39; AS BLOB), content_len = 0,</span>
<span class="sd">                        fetches = 0, append_time = NULL</span>
<span class="sd">                    WHERE region_id in</span>
<span class="sd">                        (SELECT region_id</span>
<span class="sd">                        FROM region_metadata NATURAL JOIN recording_view</span>
<span class="sd">                        WHERE label = ? AND variable = ?)</span>
<span class="sd">                    &quot;&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">))</span>
                <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    DELETE FROM region_extra</span>
<span class="sd">                    WHERE region_id in</span>
<span class="sd">                        (SELECT region_id</span>
<span class="sd">                        FROM region_metadata NATURAL JOIN recording_view</span>
<span class="sd">                        WHERE label = ? AND variable = ?)</span>
<span class="sd">                    &quot;&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pop_label</span><span class="p">,</span> <span class="n">variable</span><span class="p">))</span></div>

<div class="viewcode-block" id="NeoBufferDatabase.write_metadata"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.write_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">write_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the current metadata to the database.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The database must be writable for this to work!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">population</span> <span class="ow">in</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">iterate_populations</span><span class="p">():</span>
                <span class="c1"># pylint: disable=protected-access</span>
                <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">population</span><span class="o">.</span><span class="n">_vertex</span><span class="o">.</span><span class="n">get_recording_variables</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__write_metadata</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__write_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">app_vertex</span> <span class="o">=</span> <span class="n">population</span><span class="o">.</span><span class="n">_vertex</span>
        <span class="n">buffered_data_type</span> <span class="o">=</span> \
            <span class="n">app_vertex</span><span class="o">.</span><span class="n">get_buffer_data_type</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

        <span class="n">data_type</span> <span class="o">=</span> <span class="n">app_vertex</span><span class="o">.</span><span class="n">get_data_type</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="n">sampling_interval_ms</span> <span class="o">=</span> \
            <span class="n">app_vertex</span><span class="o">.</span><span class="n">get_sampling_interval_ms</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

        <span class="n">units</span> <span class="o">=</span> <span class="n">app_vertex</span><span class="o">.</span><span class="n">get_units</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="n">atoms_shape</span> <span class="o">=</span> <span class="n">app_vertex</span><span class="o">.</span><span class="n">atoms_shape</span>
        <span class="n">n_colour_bits</span> <span class="o">=</span> <span class="n">app_vertex</span><span class="o">.</span><span class="n">n_colour_bits</span>
        <span class="n">rec_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_recording_id</span><span class="p">(</span>
            <span class="n">cursor</span><span class="p">,</span> <span class="n">app_vertex</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span>
            <span class="n">population</span><span class="p">,</span> <span class="n">sampling_interval_ms</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span>
            <span class="n">buffered_data_type</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">atoms_shape</span><span class="p">,</span> <span class="n">n_colour_bits</span><span class="p">)</span>
        <span class="n">region</span> <span class="o">=</span> <span class="n">app_vertex</span><span class="o">.</span><span class="n">get_recording_region</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="n">machine_vertices</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">app_vertex</span><span class="o">.</span><span class="n">splitter</span><span class="o">.</span><span class="n">machine_vertices_for_recording</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">machine_vertices</span><span class="p">:</span>
            <span class="n">placement</span> <span class="o">=</span> <span class="n">SpynnakerDataView</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span>
                <span class="n">vertex</span><span class="p">)</span>
            <span class="n">region_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_region_id</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">p</span><span class="p">,</span>
                <span class="n">region</span><span class="p">)</span>
            <span class="n">vertex_slice</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">vertex_slice</span>
            <span class="n">neurons</span> <span class="o">=</span> <span class="n">app_vertex</span><span class="o">.</span><span class="n">get_neurons_recording</span><span class="p">(</span>
                <span class="n">variable</span><span class="p">,</span> <span class="n">vertex_slice</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">neurons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">recording_neurons_st</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">recording_neurons_st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_to_string</span><span class="p">(</span>
                    <span class="n">neurons</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">buffered_data_type</span> <span class="o">==</span> <span class="n">BufferDataType</span><span class="o">.</span><span class="n">EIEIO_SPIKES</span><span class="p">:</span>
                <span class="n">base_key</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get_virtual_key</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base_key</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                INSERT INTO region_metadata</span>
<span class="sd">                (rec_id, region_id, recording_neurons_st,</span>
<span class="sd">                 base_key, vertex_slice)</span>
<span class="sd">                VALUES (?, ?, ?, ?, ?)</span>
<span class="sd">                &quot;&quot;&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="n">rec_id</span><span class="p">,</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">recording_neurons_st</span><span class="p">,</span>
                 <span class="n">base_key</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">vertex_slice</span><span class="p">)))</span>

<div class="viewcode-block" id="NeoBufferDatabase.array_to_string"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.array_to_string">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">array_to_string</span><span class="p">(</span><span class="n">indexes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a list of integers into a compact string.</span>
<span class="sd">        Works best if the list is sorted.</span>

<span class="sd">        IDs are comma separated, except when a series of IDs is sequential then</span>
<span class="sd">        the start:end is used.</span>

<span class="sd">        :param list(int) indexes:</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

        <span class="n">previous</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>
        <span class="n">in_range</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">previous</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">in_range</span><span class="p">:</span>
                    <span class="n">results</span> <span class="o">+=</span> <span class="s2">&quot;:&quot;</span>
                    <span class="n">in_range</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">in_range</span><span class="p">:</span>
                    <span class="n">results</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>
                <span class="n">results</span> <span class="o">+=</span> <span class="s2">&quot;,&quot;</span>
                <span class="n">results</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="n">in_range</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">if</span> <span class="n">in_range</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="NeoBufferDatabase.string_to_array"><a class="viewcode-back" href="../../../../spynnaker.pyNN.utilities.html#spynnaker.pyNN.utilities.neo_buffer_database.NeoBufferDatabase.string_to_array">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">string_to_array</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a string into a list of integers.</span>
<span class="sd">        Assumes the string was created by :py:meth:`array_to_string`</span>

<span class="sd">        :param str string:</span>
<span class="sd">        :rtype: list(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">string</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+[,:]*&quot;</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">part</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">part</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">val</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">sPyNNaker 6.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../pyNN.html" >spynnaker.pyNN</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spynnaker.pyNN.utilities.neo_buffer_database</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-2023.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.2.0.
    </div>
  </body>
</html>